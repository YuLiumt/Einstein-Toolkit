<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Yu Liu">
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Parameter file - Yu Liu's Notebook</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Parameter file";
    var mkdocs_page_input_path = "ET/parameter file.md";
    var mkdocs_page_url = "/Einstein-Toolkit/ET/parameter file/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-36723568-3', 'https://yuliumt.github.io');
      ga('send', 'pageview');
  </script>
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Yu Liu's Notebook</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Einstein Toolkit</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../Introduction/">Introduction</a>
                </li>
                <li class="">
                    
    <a class="" href="../Install/">Install</a>
                </li>
                <li class="">
                    
    <a class="" href="../Cactus/">Cactus</a>
                </li>
                <li class="">
                    
    <a class="" href="../Thorn/">Thorn</a>
                </li>
                <li class="">
                    
    <a class="" href="../parameter/">Parameter</a>
                </li>
                <li class="">
                    
    <a class="" href="../Visualization/">Visualization</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">General Relativity</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../GR/Solutions/">Solutions</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Gravitational Wave</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../GW/Introduction/">Introduction</a>
                </li>
                <li class="">
                    
    <a class="" href="../../GW/Linearized Waves/">Linearized Waves</a>
                </li>
                <li class="">
                    
    <a class="" href="../../GW/Extracting Gravitational Waveforms/">Extracting Gravitational Waveforms</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Numerical Relativity</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../NR/Introduction/">Introduction</a>
                </li>
                <li class="">
                    
    <a class="" href="../../NR/3+1 Decomposition/">3+1 Decomposition</a>
                </li>
                <li class="">
                    
    <a class="" href="../../NR/Numerical Methods/">Numerical Methods</a>
                </li>
                <li class="">
                    
    <a class="" href="../../NR/ADM/">ADM</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Search Pipeline</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../SP/Introduction/">Introduction</a>
                </li>
                <li class="">
                    
    <a class="" href="../../SP/matched filter/">Matched Filtering</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Example</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../Example/Poisson/">Poisson</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Yu Liu's Notebook</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
    
    <li>Parameter file</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/YuLiumt/Einstein-Toolkit/edit/master/docs/ET/parameter file.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="flesh-parameters">Flesh parameters</h2>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span># Flesh parameters
Cactus::&lt;Flesh parameters&gt; = &lt;Value&gt;
</pre></div>
</td></tr></table>

<p>The default value is shown in square brackets, while curly braces show allowed parameter values.</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cactus::cctk_run_title</td>
<td>Description of this simulation [""]</td>
</tr>
<tr>
<td>Cactus::cctk_full_warnings</td>
<td>Give detailed information for each warning statement [yes]</td>
</tr>
<tr>
<td>Cactus::highlight_warning_messages</td>
<td>Highlight CCTK warning messages [yes]</td>
</tr>
<tr>
<td>Cactus::cctk_timer_output</td>
<td>Give timing information [off] {off, full}</td>
</tr>
<tr>
<td>Cactus::allow_mixeddim_gfs</td>
<td>Allow use of GFs from different dimensions [no]</td>
</tr>
<tr>
<td>Cactus::cctk_brief_output</td>
<td>Give only brief output [no]</td>
</tr>
<tr>
<td>Cactus::cctk_show_banners</td>
<td>Show any registered banners for the different thorns [yes]</td>
</tr>
<tr>
<td>Cactus::cctk_show_schedule</td>
<td>Print the scheduling tree to standard output [yes]</td>
</tr>
<tr>
<td>Cactus::cctk_strong_param_check</td>
<td>Die on parameter errors in CCTK_PARAMCHECK [yes]</td>
</tr>
<tr>
<td>Cactus::recovery_mode</td>
<td>How to behave when recovering from a checkpoint [strict] {strict, relaxed}</td>
</tr>
<tr>
<td>Cactus::info_format</td>
<td>Specifies the content and format of CCTK_INFO()/CCTK_VINFO messages. [basic] {"basic", "numeric time stamp", "human-readable time stamp", "full time stamp"}</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Value</th>
<th>Describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cactus::terminate</td>
<td>Condition on which to terminate evolution loop [iteration] {never, iteration, time, runtime, any, all}</td>
</tr>
<tr>
<td>Cactus::cctk_final_time</td>
<td>Final time for evolution, overridden by cctk_itlast unless it is positive [-1.0]</td>
</tr>
<tr>
<td>Cactus::cctk_initial_time</td>
<td>Initial time for evolution [0.0]</td>
</tr>
<tr>
<td>Cactus::cctk_itlast</td>
<td>Final iteration number [10]</td>
</tr>
<tr>
<td>Cactus::max_runtime</td>
<td>Terminate evolution loop after a certain elapsed runtime (in minutes); set to zero to disable this termination condition [0]</td>
</tr>
<tr>
<td>Cactus::terminate_next</td>
<td>Terminate on next iteration ? [no]</td>
</tr>
</tbody>
</table>
<h2 id="krancnumericaltools">KrancNumericalTools</h2>
<h3 id="genericfd">GenericFD</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>assume_stress_energy_state</td>
<td>-1</td>
<td>Assume stress_energy_state has a particular value</td>
<td>-1  :: "do not assume anything"<em>OR</em>  0:1 :: "assume off or on"</td>
</tr>
<tr>
<td>assume_use_jacobian</td>
<td>-1</td>
<td>Assume use_jacobian has a particular value</td>
<td>-1  :: "do not assume anything"<em>OR</em>  0:1 :: "assume off or on"</td>
</tr>
<tr>
<td>jacobian_group</td>
<td>""</td>
<td>Name of group containing Jacobian</td>
<td>"" :: "String of the form <implementation>::<groupname>"<em>OR</em></td>
</tr>
<tr>
<td>jacobian_determinant_group</td>
<td>""</td>
<td>Name of group containing Jacobian determinant</td>
<td>"" :: "String of the form <implementation>::<groupname>"<em>OR</em></td>
</tr>
<tr>
<td>jacobian_inverse_group</td>
<td>""</td>
<td>Name of group containing Jacobian inverse</td>
<td>"" :: "String of the form <implementation>::<groupname>"<em>OR</em></td>
</tr>
<tr>
<td>jacobian_derivative_group</td>
<td>""</td>
<td>Name of group containing Jacobian derivative</td>
<td>"" :: "String of the form <implementation>::<groupname>"<em>OR</em></td>
</tr>
<tr>
<td>allocate_genericfd_jacobian</td>
<td>"no"</td>
<td>Allocate memory for the GenericFD Jacobian (used for benchmarks)</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="cactusio">CactusIO</h2>
<h3 id="iojpeg">IOJpeg</h3>
<p>This thorn does output of 2D slices from Cactus grid functions and arrays
in jpeg image format.</p>
<p>It registers the I/O method "IOJpeg" with the flesh.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>out_every</td>
<td>-1</td>
<td>How often to do IOJpeg output, overrides IO::out_every</td>
<td>1:* :: "Every so many iterations"<em>OR</em>   0:  :: "Disable IOJpeg output"<em>OR</em>  -1:  :: "Choose the default from IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>out_vars</td>
<td>""</td>
<td>Variables to output by IOJpeg</td>
<td>".+" :: "Space-separated list of fully qualified variable/group names"<em>OR</em>  "^$" :: "An empty string to output nothing"<em>OR</em></td>
</tr>
<tr>
<td>out_dir</td>
<td>""</td>
<td>Output directory for IOJpeg files, overrides IO::out_dir</td>
<td>".+" :: "A valid directory name"<em>OR</em>  "^$" :: "An empty string to choose the default from IO::out_dir"<em>OR</em></td>
</tr>
<tr>
<td>mode</td>
<td>"standard"</td>
<td>Output mode to use</td>
<td>"remove"   :: "Remove files from old timesteps"<em>OR</em>  "standard" :: "Generate a file for each out_every timesteps"<em>OR</em></td>
</tr>
<tr>
<td>gridpoints</td>
<td>"hyperslab"</td>
<td>How to access grid points</td>
<td>"hyperslab"   :: "use locations of grid points"<em>OR</em>  "interpolate" :: "interpolate to arbitrary points"<em>OR</em></td>
</tr>
<tr>
<td>colormap_bias</td>
<td>0.5</td>
<td>Bias automatic colormap generation towards red (low) or blue (high)</td>
<td>-1:1 :: "Could be unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>colormap_quality</td>
<td>75</td>
<td>JPEG quality of level</td>
<td>0:100 :: "Percentage of full quality"<em>OR</em></td>
</tr>
<tr>
<td>colormap_factor</td>
<td>32</td>
<td>How to scale float values to rgb color</td>
<td>2:256 :: "Positive scaling"<em>OR</em></td>
</tr>
<tr>
<td>colormap</td>
<td>"custom"</td>
<td>How to set the colormap</td>
<td>"auto"     :: "Set automatically using min/max of grid variables"<em>OR</em>  "auto-old" :: "Set automatically using min/max of grid variables, using the old reduction interface which is still used by Carpet"<em>OR</em>  "custom"   :: "Set min/max manually"<em>OR</em></td>
</tr>
<tr>
<td>colormap_min</td>
<td>-1.0</td>
<td>minimum value to be mapped to colors</td>
<td><em>:</em> :: "Only for custom colormap scale"<em>OR</em></td>
</tr>
<tr>
<td>colormap_max</td>
<td>+1.0</td>
<td>maximum value to be mapped to colors</td>
<td><em>:</em> :: "Only for custom colormap scale"<em>OR</em></td>
</tr>
<tr>
<td>refinement_factor</td>
<td>1</td>
<td>Refine each 2D slice by a certain factor (using interpolation) ?</td>
<td>1:* :: "A factor greater 0"<em>OR</em></td>
</tr>
<tr>
<td>out2D_yzplane_x</td>
<td>-424242</td>
<td>x-coord for 2D planes in yz</td>
<td><em>:</em>      :: "A value between [xmin, xmax]"<em>OR</em>  -424242: :: "Default to IO::out_yzplane_x"<em>OR</em></td>
</tr>
<tr>
<td>out2D_xzplane_y</td>
<td>-424242</td>
<td>y-coord for 2D planes in xz</td>
<td><em>:</em>      :: "A value between [ymin, ymax]"<em>OR</em>  -424242: :: "Default to IO::out_xzplane_y"<em>OR</em></td>
</tr>
<tr>
<td>out2D_xyplane_z</td>
<td>-424242</td>
<td>z-coord for 2D planes in xy</td>
<td><em>:</em>      :: "A value between [zmin, zmax]"<em>OR</em>  -424242: :: "Default to IO::out_xyplane_z"<em>OR</em></td>
</tr>
<tr>
<td>out2D_yzplane_xi</td>
<td>-1</td>
<td>x-index (from 0) for 2D planes in yz</td>
<td>0:* :: "An index between [0, nx)"<em>OR</em>  -1:  :: "Choose the default from IO::out_yzplane_xi"<em>OR</em></td>
</tr>
<tr>
<td>out2D_xzplane_yi</td>
<td>-1</td>
<td>y-index (from 0) for 2D planes in xz</td>
<td>0:* :: "An index between [0, ny)"<em>OR</em>  -1:  :: "Choose the default from IO::out_xzplane_yi"<em>OR</em></td>
</tr>
<tr>
<td>out2D_xyplane_zi</td>
<td>-1</td>
<td>z-index (from 0) for 2D planes in xy</td>
<td>0:* :: "An index between [0, nz)"<em>OR</em>  -1:  :: "Choose the default from IO::out_xyplane_zi"<em>OR</em></td>
</tr>
<tr>
<td>interpolator_name</td>
<td>"Lagrange</td>
<td>Name of the interpolator</td>
<td>".<em>" :: "must be a registered interpolator"*OR</em></td>
</tr>
<tr>
<td>interpolator_options</td>
<td>"order=2"</td>
<td>Options for the interpolator</td>
<td>".<em>" :: "must be a valid option specification"*OR</em></td>
</tr>
<tr>
<td>interpolator_coordinates</td>
<td>"cart3d"</td>
<td>Coordinate system</td>
<td>".<em>" :: "must be a registered coordinate system"*OR</em></td>
</tr>
<tr>
<td>multiply_by_radius</td>
<td>"no"</td>
<td>Multiply valus by r</td>
<td></td>
</tr>
<tr>
<td>array2d_x0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_y0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_z0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_npoints_i</td>
<td>10</td>
<td>Number of grid points for the 2D grid arrays in the i direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_dx_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_dy_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_dz_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_npoints_j</td>
<td>10</td>
<td>Number of grid points for the 2D grid arrays in the j direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_dx_j</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_dy_j</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_dz_j</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h2 id="externallibraries">ExternalLibraries</h2>
<h3 id="hwloc">hwloc</h3>
<p>Distribute the hwloc library; see
<a href="http://www.open-mpi.org/projects/hwloc/">http://www.open-mpi.org/projects/hwloc/</a>.</p>
<p>From the hwloc web site:</p>
<p>The Portable Hardware Locality (hwloc) software package provides a
portable abstraction (across OS, versions, architectures, ...) of the
hierarchical topology of modern architectures, including NUMA memory
nodes, sockets, shared caches, cores and simultaneous multithreading.
It also gathers various system attributes such as cache and memory
information. It primarily aims at helping applications with gathering
information about modern computing hardware so as to exploit it
accordingly and efficiently.</p>
<h3 id="lorene2">LORENE2</h3>
<p>Distribute the LORENE library; see <a href="http://www.lorene.obspm.fr/">http://www.lorene.obspm.fr/</a>.</p>
<p>From the web site:</p>
<p>LORENE: Langage Objet pour la RElativité NumériquE</p>
<p>LORENE is a set of C++ classes to solve various problems arising in
numerical relativity, and more generally in computational
astrophysics.  It provides tools to solve partial differential
equations by means of multi-domain spectral methods.</p>
<h3 id="blas">BLAS</h3>
<p>Distribute the Basic Linear Algebra Subroutines (BLAS); see
<a href="http://netlib.org/blas/">http://netlib.org/blas/</a>.</p>
<p>From the web site:</p>
<p>The BLAS (Basic Linear Algebra Subprograms) are routines that provide
standard building blocks for performing basic vector and matrix
operations.  The Level 1 BLAS perform scalar, vector and vector-vector
operations, the Level 2 BLAS perform matrix-vector operations, and the
Level 3 BLAS perform matrix-matrix operations.  Because the BLAS are
efficient, portable, and widely available, they are commonly used in
the development of high quality linear algebra software, LAPACK for
example.</p>
<h3 id="libjpeg">libjpeg</h3>
<p>Distribute the libjpeg library; see <a href="http://www.ijg.org/">http://www.ijg.org/</a></p>
<p>From the web site:</p>
<p>IJG is an informal group that writes and distributes a widely used
free library for JPEG image compression. The first version was
released on 7-Oct-1991.</p>
<p>The current version is release 8b of 16-May-2010. This is a stable and
solid foundation for many application's JPEG support.</p>
<h3 id="mpi">MPI</h3>
<p>Distribute the OpenMPI library; see <a href="http://www.open-mpi.org/">http://www.open-mpi.org/</a>.</p>
<p>From the OpenMPI web site:</p>
<p>Open MPI: Open Source High Performance Computing</p>
<p>A High Performance Message Passing Library</p>
<p>The Open MPI Project is an open source MPI-2 implementation that is
developed and maintained by a consortium of academic, research, and
industry partners. Open MPI is therefore able to combine the
expertise, technologies, and resources from all across the High
Performance Computing community in order to build the best MPI library
available. Open MPI offers advantages for system and software vendors,
application developers and computer science researchers.</p>
<h3 id="papi">PAPI</h3>
<p>Distribute the Performance Application Programming Interface; see
<a href="http://icl.cs.utk.edu/papi/index.html">http://icl.cs.utk.edu/papi/index.html</a>.</p>
<p>From the web site:</p>
<p>PAPI provides the tool designer and application engineer with a
consistent interface and methodology for use of the performance
counter hardware found in most major microprocessors. PAPI enables
software engineers to see, in near real time, the relation between
software performance and processor events.</p>
<p>In addition Component PAPI provides access to a collection of
components that expose performance measurement opportunites across the
hardware and software stack.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Output debug messages?</td>
<td></td>
</tr>
<tr>
<td>per_thread_statistics</td>
<td>"yes"</td>
<td>Collect statistics per thread (instead of per process)</td>
<td></td>
</tr>
<tr>
<td>define_statistics_clocks</td>
<td>"no"</td>
<td>Define multiple clocks for each PAPI counter, providing min/max/avg/sdv</td>
<td></td>
</tr>
<tr>
<td>use_multiplexing</td>
<td>"yes"</td>
<td>Use multiplexing to gather more, but less accurate information</td>
<td></td>
</tr>
<tr>
<td>out_every</td>
<td>0</td>
<td>Output statistics every so many iterations</td>
<td>0   :: "after initial data and shutdown"<em>OR</em>  1:* :: "every so many iterations"<em>OR</em>  -1  :: "no statistics output"<em>OR</em></td>
</tr>
<tr>
<td>events_flops</td>
<td>"PAPI_FP_OPS</td>
<td>PAPI events for flop/sec</td>
<td>"" :: ""<em>OR</em></td>
</tr>
<tr>
<td>events_ipc</td>
<td>"PAPI_TOT_CYC</td>
<td>PAPI events for instructions/cycle</td>
<td>"" :: ""<em>OR</em></td>
</tr>
<tr>
<td>events_icache</td>
<td>"PAPI_L1_ICA</td>
<td>PAPI events for instruction cache usage</td>
<td>"" :: ""<em>OR</em></td>
</tr>
<tr>
<td>events_dcache</td>
<td>"PAPI_L1_DCA</td>
<td>PAPI events for data cache usage</td>
<td>"" :: ""<em>OR</em></td>
</tr>
<tr>
<td>events_memory</td>
<td>"PAPI_LD_INS</td>
<td>PAPI evens for memory accesses</td>
<td>"" :: ""<em>OR</em></td>
</tr>
<tr>
<td>dgemm_N</td>
<td>1000</td>
<td>Matrix size; mem = 32 N^2 bytes, cpu = 2 N^3 flop</td>
<td>1:* :: "N=2000 requires 128 Mbyte and 16 Gflop; N=5000 requires 800 Mbyte and 250 Gflop"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="hdf5">HDF5</h3>
<p>Distribute the HDF5 library; see <a href="http://www.hdfgroup.org/HDF5/">http://www.hdfgroup.org/HDF5/</a>.</p>
<p>Provide some generic utility programs to manipulate HDF5 files. These
are independent of any specific Cactus file formats.</p>
<p>From the HDF5 web site:</p>
<p>HDF5 is a data model, library, and file format for storing and
managing data. It supports an unlimited variety of datatypes, and is
designed for flexible and efficient I/O and for high volume and
complex data. HDF5 is portable and is extensible, allowing
applications to evolve in their use of HDF5. The HDF5 Technology suite
includes tools and applications for managing, manipulating, viewing,
and analyzing data in the HDF5 format.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="lapack">LAPACK</h3>
<p>Distribute the Linear Algebra Package (LAPACK); see
<a href="http://netlib.org/lapack/">http://netlib.org/lapack/</a>.</p>
<p>From the web site:</p>
<p>LAPACK is written in Fortran 90 and provides routines for solving
systems of simultaneous linear equations, least-squares solutions of
linear systems of equations, eigenvalue problems, and singular value
problems.  The associated matrix factorizations (LU, Cholesky, QR,
SVD, Schur, generalized Schur) are also provided, as are related
computations such as reordering of the Schur factorizations and
estimating condition numbers.  Dense and banded matrices are handled,
but not general sparse matrices.  In all areas, similar functionality
is provided for real and complex matrices, in both single and double
precision.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="fftw3">FFTW3</h3>
<p>Distribute the FFTW Library; see <a href="http://www.fftw.org/">http://www.fftw.org/</a>.</p>
<p>From the web site: FFTW is a C subroutine library for computing the
discrete Fourier transform (DFT) in one or more dimensions, of
arbitrary input size, and of both real and complex data (as well as of
even/odd data, i.e. the discrete cosine/sine transforms or DCT/DST).
We believe that FFTW, which is free software, should become the FFT
library of choice for most applications.</p>
<p>Our benchmarks, performed on on a variety of platforms, show that
FFTW's performance is typically superior to that of other publicly
available FFT software, and is even competitive with vendor-tuned
codes. In contrast to vendor-tuned codes, however, FFTW's performance
is portable: the same program will perform well on most architectures
without modification. Hence the name, "FFTW," which stands for the
somewhat whimsical title of "Fastest Fourier Transform in the West."</p>
<p>The FFTW package was developed at MIT by Matteo Frigo and Steven G.
Johnson</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="lorene">LORENE</h3>
<p>Distribute the LORENE library; see <a href="http://www.lorene.obspm.fr/">http://www.lorene.obspm.fr/</a>.</p>
<p>From the web site:</p>
<p>LORENE: Langage Objet pour la RElativité NumériquE</p>
<p>LORENE is a set of C++ classes to solve various problems arising in
numerical relativity, and more generally in computational
astrophysics.  It provides tools to solve partial differential
equations by means of multi-domain spectral methods.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="zlib">zlib</h3>
<p>Distribute the zlib library; see <a href="http://www.zlib.net/">http://www.zlib.net/</a></p>
<p>From the web site:</p>
<p>A Massively Spiffy Yet Delicately Unobtrusive Compression Library
(Also Free, Not to Mention Unencumbered by Patents)</p>
<p>zlib is designed to be a free, general-purpose, legally unencumbered
-- that is, not covered by any patents -- lossless data-compression
library for use on virtually any computer hardware and operating
system. The zlib data format is itself portable across platforms.
Unlike the LZW compression method used in Unix compress(1) and in the
GIF image format, the compression method currently used in zlib
essentially never expands the data. (LZW can double or triple the file
size in extreme cases.) zlib's memory footprint is also independent of
the input data and can be reduced, if necessary, at some cost in
compression. A more precise, technical discussion of both points is
available on another page.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="opencl">OpenCL</h3>
<p>Configure with OpenCL; see <a href="http://www.khronos.org/opencl/">http://www.khronos.org/opencl/</a>.</p>
<p>From the web site:</p>
<p>OpenCL - The open standard for parallel programming of heterogeneous
systems</p>
<p>OpenCL(TM) is the first open, royalty-free standard for
cross-platform, parallel programming of modern processors found in
personal computers, servers and handheld/embedded devices. OpenCL
(Open Computing Language) greatly improves speed and responsiveness
for a wide spectrum of applications in numerous market categories from
gaming and entertainment to scientific and medical software.</p>
<ol>
<li>Available implementations</li>
</ol>
<p>There seem to be four OpenCL implementations available at this time.
Unfortunately, they each have their drawbacks:</p>
<ul>
<li>
<p>AMD: Available at
  <a href="http://developer.amd.com/zones/openclzone/pages/default.aspx">http://developer.amd.com/zones/openclzone/pages/default.aspx</a>. This
  supports both CPUs and ATI GPUs. Unfortunately, the OpenCL compiler
  seems to produce code with a low quality.</p>
</li>
<li>
<p>Apple: Included with the operating system, available by default.
  This supports both CPU and GPU. The compiler is based on LLVM.
  Unfortunately, there seem to be serious bugs -- for example, I can't
  get the cos function to provide correct results.</p>
</li>
<li>
<p>FreeOCL: Open source, available at
  <a href="https://code.google.com/p/freeocl/">https://code.google.com/p/freeocl/</a>. This is a stand-alone
  implementation for CPUs only.</p>
</li>
<li>
<p>Intel: Available at
  <a href="http://software.intel.com/en-us/articles/opencl-sdk/">http://software.intel.com/en-us/articles/opencl-sdk/</a>. This
  supports only (Intel?) CPUs. The compiler is based on LLVM, and the
  implementation is also based on Intel's TBB (Threading Building
  Blocks).</p>
</li>
<li>
<p>Nvidia: Available at <a href="http://developer.nvidia.com/opencl">http://developer.nvidia.com/opencl</a>, included
  in their CUDA distribution. This supports only GPUs.</p>
</li>
<li>
<p>pocl: Open source, available at <a href="https://launchpad.net/pocl">https://launchpad.net/pocl</a>. This
  OpenCL implementation is based on LLVM.</p>
</li>
</ul>
<p>In addition, Wikipedia <a href="http://en.wikipedia.org/wiki/OpenCL">http://en.wikipedia.org/wiki/OpenCL</a> lists two
IBM implementations for their Power processor and for Intel compatible
CPUs, respectively. The latter may be identical with or similar to
AMD's implementation.</p>
<ol>
<li>Disassembling OpenCL code</li>
</ol>
<p>Intel:</p>
<p>env PATH=$PATH:/usr/local/intel_ocl_sdk_1.5_x64/usr/lib64/OpenCL/vendors/intel CLASSPATH=/usr/local/intel_ocl_sdk_1.5_x64/usr/lib64/OpenCL/vendors/intel LD_LIBRARY_PATH=/usr/local/intel_ocl_sdk_1.5_x64/usr/lib64/OpenCL/vendors/intel /usr/local/intel_ocl_sdk_1.5_x64/usr/bin/ioc -input=mk-mclachlan-cl-rhs/ML_BSSN_CL_InitRHS.cl -asm=ML_BSSN_CL_InitRHS.cl.s</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="openblas">OpenBLAS</h3>
<p>Distribute OpenBLAS; see <a href="https://github.com/xianyi/OpenBLAS/wiki">https://github.com/xianyi/OpenBLAS/wiki</a>.</p>
<p>From the web site:</p>
<p>OpenBLAS is an optimized BLAS library based on GotoBLAS2 1.13 BSD
version.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="pciutils">pciutils</h3>
<p>Distribute the PCI Utilities; see <a href="http://mj.ucw.cz/sw/pciutils/">http://mj.ucw.cz/sw/pciutils/</a>.</p>
<p>From the pciutils web site:</p>
<p>The PCI Utilities are a collection of programs for inspecting and
manipulating configuration of PCI devices, all based on a common
portable library libpci which offers access to the PCI configuration
space on a variety of operating systems.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="gsl">GSL</h3>
<p>Distribute the GNU Scientific Library; see
<a href="http://www.gnu.org/software/gsl/">http://www.gnu.org/software/gsl/</a>.</p>
<p>From the web site:</p>
<p>The GNU Scientific Library (GSL) is a numerical library for C and C++
programmers.  It is free software under the GNU General Public
License.</p>
<p>The library provides a wide range of mathematical routines such as
random number generators, special functions and least-squares fitting.
There are over 1000 functions in total with an extensive test suite.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="pthreads">pthreads</h3>
<p>Provide access to the POSIX threads libraries.</p>
<p>This thorn does not actually provide the library it only offers a convenient
way to include it in a Cactus configuration.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="petsc">PETSc</h3>
<p>Distribute the PETSc library; see <a href="http://www.mcs.anl.gov/petsc">http://www.mcs.anl.gov/petsc</a>.</p>
<p>From the web site:</p>
<p>Portable, Extensible Toolkit for Scientific Computation</p>
<p>PETSc, pronounced PET-see (the S is silent), is a suite of data
structures and routines for the scalable (parallel) solution of
scientific applications modeled by partial differential equations. It
employs the MPI standard for parallelism.</p>
<h3 id="openssl">OpenSSL</h3>
<p>Distribute the OpenSSL library; see <a href="http://www.openssl.org/">http://www.openssl.org/</a>.</p>
<p>From the web site:</p>
<p>The OpenSSL Project is a collaborative effort to develop a robust,
commercial-grade, full-featured, and Open Source toolkit implementing
the Secure Sockets Layer (SSL v2/v3) and Transport Layer Security (TLS
v1) protocols as well as a full-strength general purpose cryptography
library. The project is managed by a worldwide community of volunteers
that use the Internet to communicate, plan, and develop the OpenSSL
toolkit and its related documentation.</p>
<p>OpenSSL is based on the excellent SSLeay library developed by Eric A.
Young and Tim J. Hudson. The OpenSSL toolkit is licensed under an
Apache-style licence, which basically means that you are free to get
and use it for commercial and non-commercial purposes subject to some
simple license conditions.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="cactusnumerical">CactusNumerical</h2>
<h3 id="periodic">Periodic</h3>
<p>Purpose of the thorn:</p>
<p>Periodic boundary conditions that do not depend on PUGH.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Produce screen output while applying boundary conditions</td>
<td></td>
</tr>
<tr>
<td>periodic</td>
<td>"no"</td>
<td>Periodic boundary conditions</td>
<td></td>
</tr>
<tr>
<td>periodic_x</td>
<td>"no"</td>
<td>Periodic boundary conditions in x-direction</td>
<td></td>
</tr>
<tr>
<td>periodic_y</td>
<td>"no"</td>
<td>Periodic boundary conditions in y-direction</td>
<td></td>
</tr>
<tr>
<td>periodic_z</td>
<td>"no"</td>
<td>Periodic boundary conditions in z-direction</td>
<td></td>
</tr>
<tr>
<td>poison_boundaries</td>
<td>"no"</td>
<td>Fill the symmetry boundary with a poison value before the symmetry is applied</td>
<td></td>
</tr>
<tr>
<td>poison_value</td>
<td>254</td>
<td>Integer value (0..255) used to poison new timelevels (with memset)</td>
<td>0:255 :: "Must fit into a byte.  Use 0 for zero, 255 for nan, and e.g. 113 for a large value."<em>OR</em></td>
</tr>
<tr>
<td>check_boundaries</td>
<td>"no"</td>
<td>Check the boundaries for poison</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="slab">Slab</h3>
<p>Purpose of the thorn:</p>
<p>This thorn provides routines that use MPI to transfer slabs of arrays
between processors.</p>
<p>There is a thorn TAT/SlabTest that contains additional routines for
testing this thorn.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>timer_output</td>
<td>"no"</td>
<td>Print slabbing timings at shutdown time</td>
<td></td>
</tr>
<tr>
<td>use_alltoallv</td>
<td>"no"</td>
<td>Use MPI_Alltoallv for communication?</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="rotatingsymmetry180">RotatingSymmetry180</h3>
<p>Provide a 180 degree rotational symmetry boundary condition.  This is
the kind of symmetry that exists e.g. in a binary black hole evolution
when the two black holes are identical.  The same setup also admits an
additional bitant symmetry.</p>
<p>Currently the symmetry is fixed to be located at the lower x boundary,
so that there is a rotation about the z axis.</p>
<p>The coordinate thorn does not know about this symmetry.  You will have
to set up the domain such that you have an upper bitant in the x
direction.</p>
<p>This symmetry boundary condition can be mixed with arbitrary symmetry
conditions in the z direction, e.g. bitant or periodicity.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Produce screen output while applying boundary conditions</td>
<td></td>
</tr>
<tr>
<td>hyperslabber</td>
<td>"TAT/Slab"</td>
<td>Hyperslabbing mechanism</td>
<td>"TAT/Slab"     :: ""<em>OR</em>  "GetHyperslab" :: ""<em>OR</em></td>
</tr>
<tr>
<td>use_coordbase</td>
<td>"no"</td>
<td>Get symmetry boundary location from CoordBase (and ignore symmetry_boundary_* parameters)</td>
<td></td>
</tr>
<tr>
<td>symmetry_boundary_x</td>
<td>0.0</td>
<td>x-coordinate of symmetry boundary (ignored if use_coordbase is set)</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>symmetry_boundary_y</td>
<td>0.0</td>
<td>y-coordinate of symmetry boundary (ignored if use_coordbase is set)</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>poison_boundaries</td>
<td>"no"</td>
<td>Fill the symmetry boundary with a poison value before the symmetry is applied</td>
<td></td>
</tr>
<tr>
<td>poison_value</td>
<td>254</td>
<td>Integer value (0..255) used to poison new timelevels (with memset)</td>
<td>0:255 :: "Must fit into a byte.  Use 0 for zero, 255 for nan, and e.g. 113 for a large value."<em>OR</em></td>
</tr>
<tr>
<td>check_boundaries</td>
<td>"no"</td>
<td>Check the boundaries for poison</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="rotatingsymmetry90">RotatingSymmetry90</h3>
<p>Provide a 90 degree rotational symmetry boundary condition.  This is
the kind of symmetry that exists e.g. in a single black hole evolution
when the black hole has spin.  The same setup also admits an
additional bitant symmetry.</p>
<p>Currently the symmetry is fixed to be located at the lower x and y
boundaries, so that there is a rotation about the z axis.</p>
<p>The coordinate thorn does not know about this symmetry.  You will have
to set up the domain such that you have an upper quadrant in the x and
y directions.</p>
<p>This symmetry boundary condition can be mixed with arbitrary symmetry
conditions in the z direction, e.g. bitant or periodicity.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Produce screen output while applying boundary conditions</td>
<td></td>
</tr>
<tr>
<td>poison_boundaries</td>
<td>"no"</td>
<td>Fill the symmetry boundary with a poison value before the symmetry is applied</td>
<td></td>
</tr>
<tr>
<td>poison_value</td>
<td>254</td>
<td>Integer value (0..255) used to poison new timelevels (with memset)</td>
<td>0:255 :: "Must fit into a byte.  Use 0 for zero, 255 for nan, and e.g. 113 for a large value."<em>OR</em></td>
</tr>
<tr>
<td>check_boundaries</td>
<td>"no"</td>
<td>Check the boundaries for poison</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="interptoarray">InterpToArray</h3>
<p>Purpose of the thorn:</p>
<p>Interpolate grid functions to grid arrays on a regular grid of
locations, so that these can e.g. be output more easily.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>interpolator_name</td>
<td>"Lagrange</td>
<td>Name of the interpolator</td>
<td>".<em>" :: "must be a registered interpolator"*OR</em></td>
</tr>
<tr>
<td>interpolator_options</td>
<td>"order=2"</td>
<td>Options for the interpolator</td>
<td>".<em>" :: "must be a valid option specification"*OR</em></td>
</tr>
<tr>
<td>interpolator_coordinates</td>
<td>"cart3d"</td>
<td>Coordinate system</td>
<td>".<em>" :: "must be a registered coordinate system"*OR</em></td>
</tr>
<tr>
<td>use_carpetinterp2</td>
<td>"no"</td>
<td>Use InterpGridArrays rather than CCTK_InterpGridArrays</td>
<td></td>
</tr>
<tr>
<td>carpetinterp2_interpolator_order</td>
<td>2</td>
<td>Order of interpolation for CarpetInterp2</td>
<td>0:* :: "any order supported by CarpetInterp2"<em>OR</em></td>
</tr>
<tr>
<td>nghosts</td>
<td>0</td>
<td>Number of ghost zones</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>nscalars</td>
<td>0</td>
<td>Number of grid scalars</td>
<td>0:100 :: ""<em>OR</em></td>
</tr>
<tr>
<td>scalar_x0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>scalar_y0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>scalar_z0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>narrays1d</td>
<td>0</td>
<td>Number of 1D grid arrays</td>
<td>0:100 :: ""<em>OR</em></td>
</tr>
<tr>
<td>array1d_x0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>array1d_y0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>array1d_z0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>array1d_npoints_i</td>
<td>0</td>
<td>Number of grid points for the 1D grid arrays in the i direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array1d_dx_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array1d_dy_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array1d_dz_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>narrays2d</td>
<td>0</td>
<td>Number of 2D grid arrays</td>
<td>0:100 :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_x0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_y0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_z0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_npoints_i</td>
<td>0</td>
<td>Number of grid points for the 2D grid arrays in the i direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_dx_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_dy_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_dz_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_npoints_j</td>
<td>0</td>
<td>Number of grid points for the 2D grid arrays in the j direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_dx_j</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_dy_j</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array2d_dz_j</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>narrays3d</td>
<td>0</td>
<td>Number of 3D grid arrays</td>
<td>0:100 :: ""<em>OR</em></td>
</tr>
<tr>
<td>array3d_x0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>array3d_y0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>array3d_z0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>array3d_npoints_i</td>
<td>0</td>
<td>Number of grid points for the 3D grid arrays in the i direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array3d_dx_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array3d_dy_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array3d_dz_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array3d_npoints_j</td>
<td>0</td>
<td>Number of grid points for the 3D grid arrays in the j direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array3d_dx_j</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array3d_dy_j</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array3d_dz_j</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array3d_npoints_k</td>
<td>0</td>
<td>Number of grid points for the 3D grid arrays in the k direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array3d_dx_k</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array3d_dy_k</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array3d_dz_k</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>nparrays1d</td>
<td>0</td>
<td>Number of 1D parallel grid arrays</td>
<td>0:100 :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray1d_x0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray1d_y0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray1d_z0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray1d_npoints_i</td>
<td>0</td>
<td>Number of grid points for the 1D grid parrays in the i direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray1d_dx_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray1d_dy_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray1d_dz_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>nparrays2d</td>
<td>0</td>
<td>Number of 2D parallel grid arrays</td>
<td>0:100 :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray2d_x0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray2d_y0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray2d_z0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray2d_npoints_i</td>
<td>0</td>
<td>Number of grid points for the 2D parallel grid arrays in the i direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray2d_dx_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray2d_dy_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray2d_dz_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray2d_npoints_j</td>
<td>0</td>
<td>Number of grid points for the 2D parallel grid arrays in the j direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray2d_dx_j</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray2d_dy_j</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray2d_dz_j</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>nparrays3d</td>
<td>0</td>
<td>Number of 3D grid parrays</td>
<td>0:100 :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray3d_x0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray3d_y0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray3d_z0</td>
<td>0.0</td>
<td>Origin</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray3d_npoints_i</td>
<td>0</td>
<td>Number of grid points for the 3D parallel grid arrays in the i direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray3d_dx_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray3d_dy_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray3d_dz_i</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray3d_npoints_j</td>
<td>0</td>
<td>Number of grid points for the 3D parallel grid arrays in the j direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray3d_dx_j</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray3d_dy_j</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray3d_dz_j</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray3d_npoints_k</td>
<td>0</td>
<td>Number of grid points for the 3D parallel grid arrays in the k direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray3d_dx_k</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray3d_dy_k</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>parray3d_dz_k</td>
<td>0.0</td>
<td>Spacing</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="testlocalreduce">TestLocalReduce</h3>
<p>not documented</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>array_nx</td>
<td>4</td>
<td>Size of arrays in x direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array_ny</td>
<td>5</td>
<td>Size of arrays in y direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array_nz</td>
<td>10</td>
<td>Size of arrays in z direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="testlocalinterp2">TestLocalInterp2</h3>
<p>not documented</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>warn_level</td>
<td>1</td>
<td>Warn level used to advertise failures</td>
<td>0:4 :: "A valid error level"<em>OR</em></td>
</tr>
<tr>
<td>tolerance</td>
<td>1.0e-15</td>
<td>Test tolerance</td>
<td>(0:* :: "Any positive value"<em>OR</em></td>
</tr>
<tr>
<td>test_symmetric_interpolation</td>
<td>"no"</td>
<td>Test symmetry preserving property of interpolation</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="noise">Noise</h3>
<p>Purpose of the thorn:</p>
<p>This thorn adds random noise to grid variables at initial data and/or
boundaries, for performing the "robust stability" tests proposed by
Jeff Winicour.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>apply_id_noise</td>
<td>"no"</td>
<td>Add random noise to initial data</td>
<td></td>
</tr>
<tr>
<td>apply_bc_noise</td>
<td>"no"</td>
<td>Add random noise to initial data</td>
<td></td>
</tr>
<tr>
<td>id_vars</td>
<td>""</td>
<td>Initial data variables to modify with noise</td>
<td>.* :: "A regex which matches everything"<em>OR</em></td>
</tr>
<tr>
<td>bc_vars</td>
<td>""</td>
<td>Variables to modify with noise at boundary</td>
<td>.* :: "A regex which matches everything"<em>OR</em></td>
</tr>
<tr>
<td>amplitude</td>
<td>0.000001</td>
<td>Maximum absolute value of random data</td>
<td>0: :: "Positive number"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="localinterp">LocalInterp</h3>
<ol>
<li>Purpose</li>
</ol>
<p>This thorn does processor-local interpolation of N-dimensional data
arrays.  In general there may be many input arrays (all defined on the
same uniform Cartesian grid) all being interpolated to the same set
of interpolation points.</p>
<p>History</p>
<p>This interpolator was written by Thomas Radke in early 2001 (drawing
on older code by Paul Walker), and supports the interpolation operator
  "uniform cartesian"
for the new Cactus interpolation API CCTK_InterpLocalUniform().
(Note that the word "cartesian" is in lower case here!)</p>
<p>This interpolator originally lived in the PUGHInterp thorn, but
it turned to have very little to do with PUGH, so was moved here in
winter 2001-2002.</p>
<p>From winter 2001-2002 to July 2003 this thorn also contained another
interpolator written by Jonathan Thornburg, but in July 2003 that
interpolator was moved to AEIThorns/AEILocalInterp because it was
(is) GPL and Cactus policies are that this arrangement (CactusBase)
is reserved for code under the Cactus-flesh license (= GPL except
that it's like LGPL for linking with other thorns).</p>
<p>Because CVS can't delete directories, this thorn still contains a lot
of empty-except-for-CVS-directories directory trees left over from
Jonathan Thornburg's interpolator.  You can/should ignore these.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="tensortypes">TensorTypes</h3>
<p>Purpose of the thorn:</p>
<p>Provide information about various types of tensors.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="dissipation">Dissipation</h3>
<p>Purpose of the thorn:</p>
<p>Add fourth order Kreiss-Oliger dissipation to the right hand side of
evolution equations.  This thorn works only for time evolutions that
use MoL.  I thank Scott Hawley who wrote a very similar thorn
HawleyThorns/Dissipation for evolutions that do not use MoL; this
thorn here is modelled after his.</p>
<p>For a description of the artificial dissipation, see H. Kreiss and
J. Oliger, "Methods for the Approximate Solution of Time Dependent
Problems", vol. 10 of Global Atmospheric Research Programme (GARP):
GARP Publication Series (GARP Publication, 1973).</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>produce log output</td>
<td></td>
</tr>
<tr>
<td>order</td>
<td>3</td>
<td>Dissipation order</td>
<td>1 :: "first order accurate dissipation (using a second derivative)"<em>OR</em>  3 :: "third order accurate dissipation (using a fourth derivative)"<em>OR</em>  5 :: "fifth order accurate dissipation (using a sixth derivative)"<em>OR</em>  7 :: "seventh order accurate dissipation (using an eighth derivative)"<em>OR</em>  9 :: "ninth order accurate dissipation (using a tenth derivative)"<em>OR</em></td>
</tr>
<tr>
<td>epsdis</td>
<td>0.2</td>
<td>Dissipation strength</td>
<td><em>:</em> :: "0 for no dissipation.  Unstable for epsdis&lt;0 and epsdis&gt;&#8531;"<em>OR</em></td>
</tr>
<tr>
<td>vars</td>
<td>""</td>
<td>List of evolved grid functions that should have dissipation added</td>
<td>.* :: "must be a valid list of grid functions"<em>OR</em></td>
</tr>
<tr>
<td>use_dissipation_near_excision</td>
<td>"yes"</td>
<td>Apply excision near the excision boundary (does not work for high orders)</td>
<td></td>
</tr>
<tr>
<td>extra_dissipation_in_horizons</td>
<td>"no"</td>
<td>extra dissipation in horizons</td>
<td></td>
</tr>
<tr>
<td>update_ah_every</td>
<td>1</td>
<td>how often to update the AH information for dissipation</td>
<td>0:* :: "positive iteration number"<em>OR</em></td>
</tr>
<tr>
<td>ah_slope</td>
<td>0.2</td>
<td>Slope inside AH</td>
<td><em>:</em> :: "Slope from the outside value to the inside value in AHs"<em>OR</em></td>
</tr>
<tr>
<td>ah_radius_offset</td>
<td>0.0</td>
<td>Offset to the distance from the AH.</td>
<td><em>:</em> :: "negative values shift inwards, positive outwards"<em>OR</em></td>
</tr>
<tr>
<td>ah_max_epsdis</td>
<td>-1.0</td>
<td>maximal epsdis</td>
<td><em>:</em> :: "&lt;0 for 'off', &gt;=0 for maximal epsdis in horizon"<em>OR</em></td>
</tr>
<tr>
<td>respect_emask</td>
<td>"no"</td>
<td>respect excision mask</td>
<td></td>
</tr>
<tr>
<td>extra_dissipation_at_outerbound</td>
<td>"no"</td>
<td>increase dissipation at outer boundary</td>
<td></td>
</tr>
<tr>
<td>outer_bound_npoints</td>
<td>3</td>
<td>number of points in which dissipation should be increased</td>
<td>0:* :: "positive number"<em>OR</em></td>
</tr>
<tr>
<td>ob_slope</td>
<td>5</td>
<td>slope at outer boundary</td>
<td>0:* :: "increase dissipation"<em>OR</em></td>
</tr>
<tr>
<td>outer_boundary_max_epsdis</td>
<td>-1.0</td>
<td>maximal epsdis</td>
<td><em>:</em> :: "&lt;0 for 'off', &gt;=0 for maximal epsdis at the outer boundary"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="localreduce">LocalReduce</h3>
<p>Local array reduction implementation, using the new local reduction API. New features added, please refer to the thorn documentation for details and to the TestLocalReduce thorn for examples of usage. </p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="summationbyparts">SummationByParts</h3>
<p>Purpose of the thorn:</p>
<p>Calculate derivates of grid functions using finite difference stencils
that satisfy summation by parts.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>norm_type</td>
<td>"Diagonal"</td>
<td>Type of norm</td>
<td>"Diagonal" :: "Diagonal norm"<em>OR</em>  "Full restricted" :: "Full restricted norm"<em>OR</em></td>
</tr>
<tr>
<td>operator_type</td>
<td>"Optimized"</td>
<td>Type of operator</td>
<td>"Minimal Bandwidth" :: "Minimal bandwidth (except for 8-4 which is minimal spectral radius)"<em>OR</em>  "Optimized" :: "Optimized for performance"<em>OR</em></td>
</tr>
<tr>
<td>sbp_1st_deriv</td>
<td>"yes"</td>
<td>Should the 1<sup>st</sup> derivative operator be SBP</td>
<td></td>
</tr>
<tr>
<td>sbp_2nd_deriv</td>
<td>"yes"</td>
<td>Should the 2<sup>nd</sup> derivative operator be SBP</td>
<td></td>
</tr>
<tr>
<td>sbp_upwind_deriv</td>
<td>"yes"</td>
<td>Should the upwind derivative operator be SBP</td>
<td></td>
</tr>
<tr>
<td>order</td>
<td>2</td>
<td>Order of accuracy</td>
<td>2:8:2 :: ""<em>OR</em></td>
</tr>
<tr>
<td>onesided_outer_boundaries</td>
<td>"yes"</td>
<td>Evaluate derivatives within ghost zones of the outer boundary</td>
<td></td>
</tr>
<tr>
<td>onesided_interpatch_boundaries</td>
<td>"yes"</td>
<td>Evaluate derivatives near the local grid boundary if it is an inter-patch boundary</td>
<td></td>
</tr>
<tr>
<td>use_dissipation</td>
<td>"no"</td>
<td>Should we add dissipation</td>
<td></td>
</tr>
<tr>
<td>use_variable_deltas</td>
<td>"no"</td>
<td>Use extra grid functions to allow for variable delta's in the dissipation operators</td>
<td></td>
</tr>
<tr>
<td>use_shiftout</td>
<td>"no"</td>
<td>Should we use the boundary_shift_out parameters from CoordBase to shift the stencils of derivatives and dissipation</td>
<td></td>
</tr>
<tr>
<td>poison_derivatives</td>
<td>"no"</td>
<td>Should we poison Dvar at boundary_shiftout perimeter when taking derivatives</td>
<td></td>
</tr>
<tr>
<td>poison_dissipation</td>
<td>"no"</td>
<td>Should we poison rhs at boundary_shiftout perimeter when applying dissipation</td>
<td></td>
</tr>
<tr>
<td>poison_value</td>
<td>666.0</td>
<td>Degree of intoxication</td>
<td><em>:</em> :: "Anything you want"<em>OR</em></td>
</tr>
<tr>
<td>scale_with_h</td>
<td>"no"</td>
<td>Should we scale the dissipation with the grid spacing h</td>
<td></td>
</tr>
<tr>
<td>dissipation_type</td>
<td>"Mattson-Svard-Nordstrom"</td>
<td>Type of dissipation operator</td>
<td>"Mattson-Svard-Nordstrom" :: "Mattson, Svaerd and Nordstroem type"<em>OR</em>  "Kreiss-Oliger" :: "Kreiss-Oliger modified near the boundaries"<em>OR</em></td>
</tr>
<tr>
<td>epsdis</td>
<td>0.2</td>
<td>Dissipation strength</td>
<td><em>:</em> :: "Values typical between 0 and 1"<em>OR</em></td>
</tr>
<tr>
<td>vars</td>
<td>""</td>
<td>List of evolved grid functions that should have dissipation added</td>
<td>.* :: "Must be a valid list of grid functions"<em>OR</em></td>
</tr>
<tr>
<td>zero_derivs_y</td>
<td>"no"</td>
<td>set all derivatives to 0 in the y-direction</td>
<td></td>
</tr>
<tr>
<td>zero_derivs_z</td>
<td>"no"</td>
<td>set all derivatives to 0 in the z-direction</td>
<td></td>
</tr>
<tr>
<td>check_grid_sizes</td>
<td>"yes"</td>
<td>Should we check grid sizes and ghost zones</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="sphericalsurface">SphericalSurface</h3>
<p>Purpose of the thorn:</p>
<p>Store spherical surfaces.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>nsurfaces</td>
<td>0</td>
<td>Number of surfaces</td>
<td>0:42 :: ""<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>no</td>
<td>Shall I be verbose?</td>
<td></td>
</tr>
<tr>
<td>maxntheta</td>
<td>19</td>
<td>do not set this parameter directly</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>maxnphi</td>
<td>38</td>
<td>do not set this parameter directly</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="localinterp2">LocalInterp2</h3>
<ol>
<li>Purpose</li>
</ol>
<p>This thorn does processor-local interpolation of N-dimensional data
arrays.  In general there may be many input arrays (all defined on the
same uniform Cartesian grid) all being interpolated to the same set
of interpolation points.</p>
<p>History</p>
<p>This interpolator was written by Thomas Radke in early 2001 (drawing
on older code by Paul Walker), and supports the interpolation operator
  "uniform cartesian"
for the new Cactus interpolation API CCTK_InterpLocalUniform().
(Note that the word "cartesian" is in lower case here!)</p>
<p>This interpolator originally lived in the PUGHInterp thorn, but
it turned to have very little to do with PUGH, so was moved here in
winter 2001-2002.</p>
<p>From winter 2001-2002 to July 2003 this thorn also contained another
interpolator written by Jonathan Thornburg, but in July 2003 that
interpolator was moved to AEIThorns/AEILocalInterp because it was
(is) GPL and Cactus policies are that this arrangement (CactusBase)
is reserved for code under the Cactus-flesh license (= GPL except
that it's like LGPL for linking with other thorns).</p>
<p>At the beginning of 2015 the low-level interpolation kernels of this
thorn were rewritten in C++ by David Radice.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="cartoon2d">Cartoon2D</h3>
<ol>
<li>Purpose</li>
</ol>
<p>Implements a "cartoon" axisymmetric evolution according to the method
described in gr-qc/9908012.  The original idea for 'Cartoon2D' was due
to Steve Brandt.</p>
<p>See doc/documentation.tex for usage notes.</p>
<p>See the test/ directory for sample parameter files.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>cartoon_active</td>
<td>"no"</td>
<td>Activate cartoon boundary condition</td>
<td></td>
</tr>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Verbose information</td>
<td></td>
</tr>
<tr>
<td>stencil</td>
<td>"yes"</td>
<td>Use custom 2D stencil if available</td>
<td></td>
</tr>
<tr>
<td>order</td>
<td>4</td>
<td>Cartoon's interpolation order</td>
<td>1:5 :: "From linear to fifth order."<em>OR</em></td>
</tr>
<tr>
<td>eno_order</td>
<td>4</td>
<td>The interpolation order applied to the ENO interpolator</td>
<td>1:5 :: "From linear to fifth order."<em>OR</em></td>
</tr>
<tr>
<td>allow_grid_resize</td>
<td>"no"</td>
<td>Allow grid to be resized in a cartoon-compatible way</td>
<td></td>
</tr>
<tr>
<td>old_excision</td>
<td>"no"</td>
<td>Are we doing excision based on the old style mask?</td>
<td></td>
</tr>
<tr>
<td>new_excision</td>
<td>"no"</td>
<td>Are we doing excision based on the new style mask?</td>
<td></td>
</tr>
<tr>
<td>old_style_excision_var</td>
<td>""</td>
<td>The variable to be checked for old style excision</td>
<td>".<em>" :: "Expected to be \'Spacemask::emask\'"*OR</em></td>
</tr>
<tr>
<td>new_style_excision_var</td>
<td>""</td>
<td>The variable to be checked for new style excision</td>
<td>".<em>" :: "Expected to be \'Spacemask::space_mask\'"*OR</em></td>
</tr>
<tr>
<td>new_mask_field_name</td>
<td>""</td>
<td>The name of the field that describes excision for the new mask</td>
<td>".<em>" :: "Could be anything"*OR</em></td>
</tr>
<tr>
<td>new_mask_excised_name</td>
<td>""</td>
<td>The name of the descriptor that says the point is excised for the new mask</td>
<td>".<em>" :: "Could be anything"*OR</em></td>
</tr>
</tbody>
</table>
<h3 id="slabtest">SlabTest</h3>
<p>Purpose of the thorn:</p>
<p>This thorn tests the slab transfer routines of the thorn Slab.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="mol"><a href="http://cactuscode.org/documentation/thorns/CactusBase-MoL.pdf">MoL</a></h3>
<p>The Method of Lines (MoL) converts a partial differential equation(s) into an ordinary differential equation containing some spatial differential operator.</p>
<p>If you already have a thorn that uses the method of lines, then there are four main parameters that are relevant to change the integration method. The keyword <code class="codehilite">MoL_ODE_Method</code> chooses between the different methods. The parameter <code class="codehilite">MoL_Intermediate_Steps</code> controls the number of intermediate steps for the ODE solver. The parameter <code class="codehilite">MoL_Num_Scratch_Levels</code> controls the amount of scratch space used. 
Another parameter is <code class="codehilite">MoL_Memory_Always_On</code> which switches on memory for the scratch space always if true and only during evolution if false.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>MoL_Num_Evolved_Vars</td>
<td>0</td>
<td>The maximum number of variables to be evolved by MoL (DPRECATED)</td>
<td>0:* :: "Anything non negative. Added to by other thorns."</td>
</tr>
<tr>
<td>MoL_Num_Evolved_Vars_Slow</td>
<td>0</td>
<td>The maximum number of 'slow' variables to be evolved by MoL (DPRECATED)</td>
<td>0:* :: "Anything non negative. Added to by other thorns."</td>
</tr>
<tr>
<td>MoL_Num_Constrained_Vars</td>
<td>0</td>
<td>The maximum number of constrained variables with timelevels that MoL needs to know about (DPRECATED)</td>
<td>0:* :: "Anything non negative. Added to by other thorns."</td>
</tr>
<tr>
<td>MoL_Num_SaveAndRestore_Vars</td>
<td>0</td>
<td>The maximum number of variables to be evolved outside of MoL but that MoL needs to know about (DPRECATED)</td>
<td>0:*  :: "Anything non negative. Added to by other thorns."</td>
</tr>
<tr>
<td>MoL_Max_Evolved_Array_Size</td>
<td>0</td>
<td>The maximum total size of any grid arrays to be evolved</td>
<td>0:* :: "Anything non negative. Accumulated by other thorns"</td>
</tr>
<tr>
<td>MoL_Num_ArrayEvolved_Vars</td>
<td>0</td>
<td>The maximum number of array variables to be evolved by MoL (DPRECATED)</td>
<td>0:* :: "Anything non negative. Added to by other thorns."</td>
</tr>
<tr>
<td>MoL_Num_ArrayConstrained_Vars</td>
<td>0</td>
<td>The maximum number of array constrained variables with timelevels that MoL needs to know about (DPRECATED)</td>
<td>0:*   :: "Anything non negative. Added to by other thorns."</td>
</tr>
<tr>
<td>MoL_Num_ArraySaveAndRestore_Vars</td>
<td>0</td>
<td>The maximum number of array variables to be evolved outside of MoL but that MoL needs to know about (DPRECATED)</td>
<td>0:*   :: "Anything non negative. Added to by other thorns."</td>
</tr>
<tr>
<td>MoL_Num_Scratch_Levels</td>
<td>0</td>
<td>Number of scratch levels required by the ODE method</td>
<td>0:* :: "Anything non negative"</td>
</tr>
<tr>
<td>ODE_Method</td>
<td>"ICN"</td>
<td>The ODE method use by MoL to do time integration</td>
<td>"Generic"   :: "Generic Shu-Osher Runge-Kutta type"<em>OR</em>  "ICN"      :: "Iterative Crank Nicholson"<em>OR</em>  "ICN-avg"   :: "Iterative Crank Nicholson with averaging"<em>OR</em>  "Euler"  :: "Euler"<em>OR</em>  "RK2"       :: "Efficient RK2"<em>OR</em>  "RK2-central"   :: "Central RK2"<em>OR</em>  "RK3"     :: "Efficient RK3"<em>OR</em>  "RK4"       :: "Efficient RK4"<em>OR</em>  "RK45"        :: "RK45 (Fehlberg) with error estimation"<em>OR</em>  "RK45CK"      :: "RK45CK (Cash-Karp) with error estimation"<em>OR</em>  "RK65"        :: "RK65 with error estimation"<em>OR</em>  "RK87"        :: "RK87 with error estimation"<em>OR</em>  "AB"          :: "Adams-Bashforth"<em>OR</em>  "RK2-MR-2:1"  :: "2<sup>nd</sup> order 2:1 multirate RK scheme based on RK2 due to Schlegel et al 2009. This requires init_RHS_zero='no'."<em>OR</em>  "RK4-MR-2:1"  :: "3<sup>rd</sup> order 2:1 multirate RK scheme based on RK43 due to Schlegel et al 2009. This requires init_RHS_zero='no'."<em>OR</em>  "RK4-RK2"     :: "RK4 as fast method and RK2 as slow method"<em>OR</em></td>
</tr>
<tr>
<td>Generic_Type</td>
<td>"RK"</td>
<td>If using the generic method, which sort</td>
<td>"RK"        :: "One of the standard TVD Runge-Kutta methods"<em>OR</em>  "ICN"     :: "Iterative Crank Nicholson as a generic method"<em>OR</em>  "Table"       :: "Given from the generic method descriptor parameter"<em>OR</em>  "Classic RK3"    :: "Efficient RK3 - classical version"<em>OR</em></td>
</tr>
<tr>
<td>ICN_avg_theta</td>
<td>0.5</td>
<td>theta of averaged ICN method, usually 0.5</td>
<td>0:1 :: "0 &lt;= theta &lt;= 1"<em>OR</em></td>
</tr>
<tr>
<td>ICN_avg_swapped</td>
<td>"no"</td>
<td>Use swapped averages in ICN method?</td>
<td></td>
</tr>
<tr>
<td>AB_Type</td>
<td>"1"</td>
<td>If using the the AB method, which sort</td>
<td>"1" :: "same as forward Euler"<em>OR</em>  "2" :: "second order"<em>OR</em>  "3" :: "third order"<em>OR</em>  "4" :: "fourth order"<em>OR</em>  "5" :: "fifth order"<em>OR</em></td>
</tr>
<tr>
<td>AB_initially_reduce_order</td>
<td>"yes"</td>
<td>Reduce order of accuracy initially so that no past timelevels of initial data are required</td>
<td></td>
</tr>
<tr>
<td>MoL_Intermediate_Steps</td>
<td>3</td>
<td>Number of intermediate steps taken by the ODE method</td>
<td>1:*     :: "Anything greater than 1"<em>OR</em></td>
</tr>
<tr>
<td>MoL_Memory_Always_On</td>
<td>"yes"</td>
<td>Do we keep the scratch arrays allocated all the time?</td>
<td></td>
</tr>
<tr>
<td>MoL_Tiny</td>
<td>1.e-15</td>
<td>Effective local machine zero; required by generic solvers</td>
<td>0:*     :: "Defaults to 1.e-15"<em>OR</em></td>
</tr>
<tr>
<td>initial_data_is_crap</td>
<td>"no"</td>
<td>If the initial data routine fails to set up the previous time levels, copy the current backwards</td>
<td></td>
</tr>
<tr>
<td>run_MoL_PostStep_in_Post_Recover_Variables</td>
<td>"yes"</td>
<td>Schedule the PostStep parts after recovery so that symmetries are automatically done correctly.</td>
<td></td>
</tr>
<tr>
<td>set_ID_boundaries</td>
<td>"yes"</td>
<td>Should boundaries be overwritten (via synchronization, prolongation, boundary conditions) by MoL?</td>
<td></td>
</tr>
<tr>
<td>Generic_Method_Descriptor</td>
<td>"GenericIntermediateSteps</td>
<td>A string used to create a table containing the description of the generic method</td>
<td>".<em>"          :: "Should contain the Alpha and Beta arrays, and the number of intermediate steps"*OR</em></td>
</tr>
<tr>
<td>MoL_NaN_Check</td>
<td>"no"</td>
<td>Should the RHS GFs be checked for NaNs?</td>
<td></td>
</tr>
<tr>
<td>disable_prolongation</td>
<td>"yes"</td>
<td>If Mesh refinement is enabled should we use buffer zones in intermediate steps?</td>
<td></td>
</tr>
<tr>
<td>skip_initial_copy</td>
<td>"no"</td>
<td>Skip initial copy from previous to current time level</td>
<td></td>
</tr>
<tr>
<td>init_RHS_zero</td>
<td>"yes"</td>
<td>Initialise the RHS to zero</td>
<td></td>
</tr>
<tr>
<td>adaptive_stepsize</td>
<td>"no"</td>
<td>Choose the time step size adaptively</td>
<td></td>
</tr>
<tr>
<td>maximum_absolute_error</td>
<td>1.0e-6</td>
<td>Maximum allowed absolute error for adaptive stepsize control</td>
<td>0.0:<em>) :: ""*OR</em></td>
</tr>
<tr>
<td>maximum_relative_error</td>
<td>1.0e-6</td>
<td>Maximum allowed relative error for adaptive stepsize control</td>
<td>0.0:<em>) :: ""*OR</em></td>
</tr>
<tr>
<td>RHS_error_weight</td>
<td>1.0</td>
<td>Weight of the RHS in the relative error calculation</td>
<td>0.0:* :: "should be between zero and one"<em>OR</em></td>
</tr>
<tr>
<td>safety_factor</td>
<td>0.9</td>
<td>Safety factor for stepsize control</td>
<td>(0.0:<em>) :: "should be less than one"*OR</em></td>
</tr>
<tr>
<td>maximum_decrease</td>
<td>10.0</td>
<td>Maximum stepsize decrease factor</td>
<td>(1.0:<em>) :: "should be larger than one"*OR</em></td>
</tr>
<tr>
<td>maximum_increase</td>
<td>5.0</td>
<td>Maximum stepsize increase factor</td>
<td>(1.0:<em>) :: "should be larger than one"*OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>"normal"</td>
<td>How verbose should MoL be?</td>
<td>"none"     :: "No output at all (not implemented)"<em>OR</em>  "normal"   :: "Standard verbosity"<em>OR</em>  "register" :: "List the variables registered as well"<em>OR</em>  "extreme"  :: "Everything you never wanted to know"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="spacemask">SpaceMask</h3>
<p>Provides utilities for assigning states to individual grid points
using a mask grid function.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>use_mask</td>
<td>"no"</td>
<td>Turn on storage for mask?</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="norms">Norms</h3>
<p>Purpose of the thorn:</p>
<p>Compute norms of the state vector, e.g. for Mexico tests.  These are
special norms that make a difference between variables which have a
second derivative taken and variables which have not; see
gr-qc/0503056.  These norms include the gradients of those variables
that have a second derivative taken.  In doing so, they take all
wavelenghts into account -- in contrast, a norm that would be based
simply on using centered differences to calculate gradients would not.</p>
<p>References:</p>
<p>Gioel Calabrese, Ian Hinder, Sascha Husa: Numerical stability for
finite difference approximations of Einstein's equations,
gr-qc/0503056 (2005)</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>max_nr_vars</td>
<td>100</td>
<td>maximum number of variables for which norms to compute</td>
<td>0:* :: "positive"<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>0</td>
<td>verbosity of output</td>
<td>0:9 :: "higher number means more verbose output"<em>OR</em></td>
</tr>
<tr>
<td>gridfunctions_1st</td>
<td>""</td>
<td>Set of grid functions to compute norms for 2<sup>nd</sup> order variables</td>
<td>".<em>" :: "List of grid function names"*OR</em></td>
</tr>
<tr>
<td>gridfunctions_2nd</td>
<td>""</td>
<td>Set of grid functions to compute norms for 2<sup>nd</sup> order variables</td>
<td>".<em>" :: "List of grid function names"*OR</em></td>
</tr>
</tbody>
</table>
<h3 id="reflectionsymmetry">ReflectionSymmetry</h3>
<p>Provide reflection symmetries, i.e., bitant, quadrant, and octant mode.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Produce screen output while applying boundary conditions</td>
<td></td>
</tr>
<tr>
<td>reflection_x</td>
<td>"no"</td>
<td>Reflection symmetry at the lower x boundary</td>
<td></td>
</tr>
<tr>
<td>reflection_y</td>
<td>"no"</td>
<td>Reflection symmetry at the lower y boundary</td>
<td></td>
</tr>
<tr>
<td>reflection_z</td>
<td>"no"</td>
<td>Reflection symmetry at the lower z boundary</td>
<td></td>
</tr>
<tr>
<td>reflection_upper_x</td>
<td>"no"</td>
<td>Reflection symmetry at the upper x boundary</td>
<td></td>
</tr>
<tr>
<td>reflection_upper_y</td>
<td>"no"</td>
<td>Reflection symmetry at the upper y boundary</td>
<td></td>
</tr>
<tr>
<td>reflection_upper_z</td>
<td>"no"</td>
<td>Reflection symmetry at the upper z boundary</td>
<td></td>
</tr>
<tr>
<td>avoid_origin_x</td>
<td>"yes"</td>
<td>Stagger about the origin on the lower x boundary?</td>
<td></td>
</tr>
<tr>
<td>avoid_origin_y</td>
<td>"yes"</td>
<td>Stagger about the origin on the lower y boundary?</td>
<td></td>
</tr>
<tr>
<td>avoid_origin_z</td>
<td>"yes"</td>
<td>Stagger about the origin on the lower z boundary?</td>
<td></td>
</tr>
<tr>
<td>avoid_origin_upper_x</td>
<td>"yes"</td>
<td>Stagger about the origin on the upper x boundary?</td>
<td></td>
</tr>
<tr>
<td>avoid_origin_upper_y</td>
<td>"yes"</td>
<td>Stagger about the origin on the upper y boundary?</td>
<td></td>
</tr>
<tr>
<td>avoid_origin_upper_z</td>
<td>"yes"</td>
<td>Stagger about the origin on the upper z boundary?</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="einsteinevolve">EinsteinEvolve</h2>
<h3 id="newrad">NewRad</h3>
<p>Implement the "NewRad" radiative boundary conditions known from
BSSN_MoL.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>z_is_radial</td>
<td>"no"</td>
<td>Consider the local z direction to be the radial one; use with Llama</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="grhydro_initdata">GRHydro_InitData</h3>
<p>Provides simple initial data (shock tubes, ...) for the GRHydro code.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>initial_hydro</td>
<td>"xshock"</td>
<td></td>
<td>"shocktube" :: "Shocktube type"<em>OR</em>  "shocktube_hot" :: "Shocktube with hot nuclear EOS"<em>OR</em>  "only_atmo"  :: "Set only a low atmosphere"<em>OR</em>  "read_conformal":: "After reading in initial alp, rho and gxx from h5 files, sets the other quantities"<em>OR</em>  "simple_wave" :: "Set initial data from Anile Miller Motta, Phys.Fluids. 26, 1450 (1983)"<em>OR</em>  "monopole"    :: "Monopole at the center"<em>OR</em>  "cylexp"      :: "Cylindrical Explosion"<em>OR</em>  "rotor"       :: "Magnetic Rotor test from DelZanna,Bucciantini, and Londrillo A&amp;A 400, 397-413 (2003)"<em>OR</em>  "advectedloop":: "Magnetic advected loop test"<em>OR</em>  "alfvenwave"  :: "Circularly polarized Alfven wave"<em>OR</em>  "hydro_bondi_solution" :: "Spherical single black hole Bondi solution"<em>OR</em>  "hydro_bondi_solution_iso" :: "Spherical single black hole Bondi solution - TEST ISO CASE!!!!!!"<em>OR</em>  "magnetized_bondi_solution" :: "Magnetized Spherical single black hole Bondi solution"<em>OR</em>  "magnetized_bondi_solution_iso" :: "Magnetized Spherical single black hole Bondi solution - TEST ISO CASE!!!!!!"<em>OR</em>}<em>OR**OR*EXTENDS KEYWORD initial_Bvec*OR</em>{<em>OR</em>  "shocktube"  :: "Shocktube type"<em>OR</em>  "cylexp"     :: "Poloidal Magnetic Field"<em>OR</em>  "poloidalmagfield" :: "Poloidal Magnetic Field"<em>OR</em>  "magnetized Bondi" :: "radial magnetic field appropriate for Bondi test"<em>OR</em>}<em>OR**OR*EXTENDS KEYWORD initial_Avec*OR</em>{<em>OR</em>  "poloidalmagfield" :: "Poloidal Magnetic Field"<em>OR</em>}<em>OR**OR*EXTENDS KEYWORD initial_entropy*OR</em>{<em>OR</em>  "magnetized Bondi" :: "Initial entropy for a radial magnetic field appropriate for Bondi test"<em>OR</em>}<em>OR**OR**OR*shares:ADMBase*OR**OR*EXTENDS KEYWORD initial_data ""*OR</em>{<em>OR</em>#  "shocktube"    :: "Shock tube initial data for GRHydro"<em>OR</em>  "con2primtest"  :: "Testing the con -&gt; prim conversion"<em>OR</em>  "con2prim2con_test"   :: "Testing the con -&gt; prim -&gt; con conversion"<em>OR</em>  "prim2con2prim_test"  :: "Testing the prim -&gt; con -&gt; prim conversion"<em>OR</em>  "prim2con2prim_polytype_test"  :: "Testing the prim -&gt; con -&gt; prim conversion - polytype version"<em>OR</em>  "reconstruction_test" :: "Testing reconstruction"<em>OR</em>}<em>OR**OR*private:*OR**OR*KEYWORD shocktube_type "Diagonal or parallel shock?"*OR</em>{<em>OR</em>  "diagshock"  :: "Diagonal across all axes"<em>OR</em>  "diagshock2d"   :: "Diagonal across x-y axes"<em>OR</em>  "xshock"  :: "Parallel to x axis"<em>OR</em>  "yshock"  :: "Parallel to y axis"<em>OR</em>  "zshock"  :: "Parallel to z axis"<em>OR</em>  "sphere"  :: "spherically symmetric shock"<em>OR</em></td>
</tr>
<tr>
<td>shock_case</td>
<td>"Sod"</td>
<td>Simple, Sod's problem or other?</td>
<td>"Simple"  :: "GRAstro_Hydro test case"<em>OR</em>  "Sod"     :: "Sod's problem"<em>OR</em>  "Blast"   :: "Strong blast wave"<em>OR</em>  "Balsaralike1" :: "Hydro version of Balsara Test #1"<em>OR</em>  "Balsara0"    :: "Balsara Test #1, but unmagnetized"<em>OR</em>  "Balsara1"    :: "Balsara Test #1"<em>OR</em>  "Balsara2"    :: "Balsara Test #2"<em>OR</em>  "Balsara3"    :: "Balsara Test #3"<em>OR</em>  "Balsara4"    :: "Balsara Test #4"<em>OR</em>  "Balsara5"    :: "Balsara Test #5"<em>OR</em>  "Alfven"      :: "Generical Alfven Test"<em>OR</em>  "Komissarov1" :: "Komissarov Test #1"<em>OR</em>  "Komissarov2" :: "Komissarov Test #2"<em>OR</em>  "Komissarov3" :: "Komissarov Test #3"<em>OR</em>  "Komissarov4" :: "Komissarov Test #4"<em>OR</em>  "Komissarov5" :: "Komissarov Test #5"<em>OR</em>  "Komissarov6" :: "Komissarov Test #6"<em>OR</em>  "Komissarov7" :: "Komissarov Test #7"<em>OR</em>  "Komissarov8" :: "Komissarov Test #8"<em>OR</em>  "Komissarov9" :: "Komissarov Test #9"<em>OR</em></td>
</tr>
<tr>
<td>shock_xpos</td>
<td>0.0</td>
<td>Position of shock plane: x</td>
<td><em>:</em>  :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>shock_ypos</td>
<td>0.0</td>
<td>Position of shock plane: y</td>
<td><em>:</em>  :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>shock_zpos</td>
<td>0.0</td>
<td>Position of shock plane: z</td>
<td><em>:</em>  :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>shock_radius</td>
<td>1.0</td>
<td>Radius of sperical shock</td>
<td>0.0:*   :: "Anything positive"<em>OR</em></td>
</tr>
<tr>
<td>change_shock_direction</td>
<td>0.3</td>
<td>Change the shock direction</td>
<td>0:1     :: "It is the sound speed where the fluid velocity is zero"<em>OR</em></td>
</tr>
<tr>
<td>simple_wave_v_max</td>
<td>0.7</td>
<td>The v_max constant in Anile Miller Motta, Phys.Fluids. 26, 1450 (1983)</td>
<td>0:1     :: "It is the maximum velocity in the initial configuration (see p. 1457, bottom of first column)"<em>OR</em></td>
</tr>
<tr>
<td>attenuate_atmosphere</td>
<td>"no"</td>
<td>Attenuate the velocity in the atmosphere</td>
<td></td>
</tr>
<tr>
<td>Bx_init</td>
<td>0.0</td>
<td>Initial B-field in the x-dir</td>
<td><em>:</em>     :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>By_init</td>
<td>0.0</td>
<td>Initial B-field in the y-dir</td>
<td><em>:</em>     :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>Bz_init</td>
<td>0.0</td>
<td>Initial B-field in the z-dir</td>
<td><em>:</em>     :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>rho_init</td>
<td>1.0d-6</td>
<td>Initial rest mass density</td>
<td>(0:*    :: "Anything positive."<em>OR</em></td>
</tr>
<tr>
<td>velx_init</td>
<td>1.0d-1</td>
<td>Initial x velocity</td>
<td><em>:</em>    :: "Anything."<em>OR</em></td>
</tr>
<tr>
<td>vely_init</td>
<td>1.0d-1</td>
<td>Initial y velocity</td>
<td><em>:</em>    :: "Anything."<em>OR</em></td>
</tr>
<tr>
<td>velz_init</td>
<td>1.0d-1</td>
<td>Initial z velocity</td>
<td><em>:</em>    :: "Anything."<em>OR</em></td>
</tr>
<tr>
<td>eps_init</td>
<td>1.0d-6</td>
<td>Initial specific internal energy</td>
<td>(0:*    :: "Anything positive."<em>OR</em></td>
</tr>
<tr>
<td>press_init</td>
<td>6.666666666666667d-7</td>
<td>Initial pressure</td>
<td>(0:*    :: "Anything positive."<em>OR</em></td>
</tr>
<tr>
<td>use_c2p_with_entropy_eqn</td>
<td>no</td>
<td>Use the con2prim routine that uses the entropy equation instead of the energy equation</td>
<td></td>
</tr>
<tr>
<td>dens_init</td>
<td>1.29047362</td>
<td>Initial conserved mass density</td>
<td>(0:*    :: "Anything positive."<em>OR</em></td>
</tr>
<tr>
<td>sx_init</td>
<td>0.166666658</td>
<td>Initial x component of conserved momentum density</td>
<td><em>:</em>    :: "Anything."<em>OR</em></td>
</tr>
<tr>
<td>sy_init</td>
<td>0.166666658</td>
<td>Initial y component of conserved momentum density</td>
<td><em>:</em>    :: "Anything."<em>OR</em></td>
</tr>
<tr>
<td>sz_init</td>
<td>0.166666658</td>
<td>Initial z component of conserved momentum density</td>
<td><em>:</em>    :: "Anything."<em>OR</em></td>
</tr>
<tr>
<td>tau_init</td>
<td>0.484123939</td>
<td>Initial conserved total energy density</td>
<td>(0:*    :: "Anything positive."<em>OR</em></td>
</tr>
<tr>
<td>gxx_init</td>
<td>1.0</td>
<td>Initial xx metric componenent</td>
<td><em>:</em>    :: "Anything, but be carefull to set a positive definite 3-metric!"<em>OR</em></td>
</tr>
<tr>
<td>gxy_init</td>
<td>0.0</td>
<td>Initial xy metric componenent</td>
<td><em>:</em>    :: "Anything, but be carefull to set a positive definite 3-metric!"<em>OR</em></td>
</tr>
<tr>
<td>gxz_init</td>
<td>0.0</td>
<td>Initial xz metric componenent</td>
<td><em>:</em>    :: "Anything, but be carefull to set a positive definite 3-metric!"<em>OR</em></td>
</tr>
<tr>
<td>gyy_init</td>
<td>1.0</td>
<td>Initial yy metric componenent</td>
<td><em>:</em>    :: "Anything, but be carefull to set a positive definite 3-metric!"<em>OR</em></td>
</tr>
<tr>
<td>gyz_init</td>
<td>0.0</td>
<td>Initial yz metric componenent</td>
<td><em>:</em>    :: "Anything, but be carefull to set a positive definite 3-metric!"<em>OR</em></td>
</tr>
<tr>
<td>gzz_init</td>
<td>1.0</td>
<td>Initial zz metric componenent</td>
<td><em>:</em>    :: "Anything, but be carefull to set a positive definite 3-metric!"<em>OR</em></td>
</tr>
<tr>
<td>monopole_type</td>
<td>"Point"</td>
<td>Which kind of monopole?</td>
<td>"Point" :: "Single point with Bx /= 0"<em>OR</em>  "Gauss" :: "Gaussian w/radius R_Gauss"<em>OR</em>  "1dalt" :: "1-d alternating"<em>OR</em>  "2dalt" :: "2-d alternating"<em>OR</em>  "3dalt" :: "3-d alternating"<em>OR</em></td>
</tr>
<tr>
<td>R_Gauss</td>
<td>1.0</td>
<td>Radius for a Gaussian monopole</td>
<td>0:* :: "Any positive number"<em>OR</em></td>
</tr>
<tr>
<td>Monopole_point_Bx</td>
<td>1.0</td>
<td>Pointlike Monopole Bx value</td>
<td><em>:</em> :: "Any number"<em>OR</em></td>
</tr>
<tr>
<td>cyl_r_inner</td>
<td>0.8</td>
<td>Inner Radius</td>
<td>(0:* :: "Any positive number"<em>OR</em></td>
</tr>
<tr>
<td>cyl_r_outer</td>
<td>1.0</td>
<td>Outer Radius</td>
<td>(0:* :: "Any positive number"<em>OR</em></td>
</tr>
<tr>
<td>cyl_rho_inner</td>
<td>1.d-2</td>
<td>density in inner core</td>
<td>(0:* :: "any positive number"<em>OR</em></td>
</tr>
<tr>
<td>cyl_press_inner</td>
<td>1.d0</td>
<td>pressure in inner core</td>
<td>(0:* :: "any positive number"<em>OR</em></td>
</tr>
<tr>
<td>cyl_rho_outer</td>
<td>1.d-4</td>
<td>density in outer region</td>
<td>(0:* :: "any positive number"<em>OR</em></td>
</tr>
<tr>
<td>cyl_press_outer</td>
<td>3.d-5</td>
<td>pressure in outer region</td>
<td>(0:* :: "any positive number"<em>OR</em></td>
</tr>
<tr>
<td>advectedloop_type</td>
<td>"2D"</td>
<td>2-dimensional or 3-dimensional?</td>
<td>"2D"  :: "2-dimensional (B^z=0)"<em>OR</em>  "3D"  :: "3-dimensional (B^3=0, where B^3</td>
</tr>
<tr>
<td>advectedloop_case</td>
<td>"V^z=0"</td>
<td>V^z=0 or not?</td>
<td>"V^z=0"  :: "Useful to evaluate divB deviations"<em>OR</em>  "V^z/=0" :: "Useful to evaluate con2prim robustness in keeping V^z const."<em>OR</em></td>
</tr>
<tr>
<td>advectedloop_delA</td>
<td>"Exact"</td>
<td>How to calculate B^i field from the potential A^b</td>
<td>"Exact"   :: "Analytic, exact closed formula applied"<em>OR</em>  "Numeric" :: "Finite difference approximation of the derivatives applied"<em>OR</em></td>
</tr>
<tr>
<td>alfvenwave_type</td>
<td>"1D"</td>
<td>1-dimensional or 2-dimensional?</td>
<td>"1D"  :: "1-dimensional"<em>OR</em>  "2D"  :: "2-dimensional (in x-y plane)"<em>OR</em></td>
</tr>
<tr>
<td>alfvenwave_pressure</td>
<td>1.0</td>
<td>P_gas for the Alfven wave</td>
<td>(0:* :: "positive"<em>OR</em></td>
</tr>
<tr>
<td>mdot_sonicpt_bondi</td>
<td>12.566370614359172954</td>
<td>Accretion rate at sonic point in hydro units</td>
<td>(0:* :: "positive"<em>OR</em></td>
</tr>
<tr>
<td>bondi_bmag</td>
<td>0.01</td>
<td>B_0 parameter for magnetized Bondi</td>
<td>0:* :: "Anything positive"<em>OR</em></td>
</tr>
<tr>
<td>bondi_radial_offset</td>
<td>0.0</td>
<td>redefine r_grid=r_KS-r0 to avoid singularity on grid</td>
<td>0:* :: "Any positive number"<em>OR</em></td>
</tr>
<tr>
<td>set_bondi_beta_sonicpt</td>
<td>no</td>
<td>Set plasma beta parameter instead of bondi_bmag</td>
<td></td>
</tr>
<tr>
<td>bondi_Bvec_method</td>
<td>"direct"</td>
<td>how to compute the magnetic field vector</td>
<td>"direct"    :: "directly from Cartesian metric"<em>OR</em>  "transform" :: "transform Schwarzschild solution to Kerr Schild"<em>OR</em></td>
</tr>
<tr>
<td>bondi_evolve_only_annulus</td>
<td>"no"</td>
<td>reset to initial data outside of bondi_freeze_inner_radius and bondi_freeze_outer_radius</td>
<td></td>
</tr>
<tr>
<td>bondi_freeze_inner_radius</td>
<td>-1.</td>
<td>reset to initial at radii below this</td>
<td><em>:</em> :: "any value"<em>OR</em></td>
</tr>
<tr>
<td>bondi_freeze_outer_radius</td>
<td>1e300</td>
<td>reset to initial at radii above this</td>
<td><em>:</em> :: "any value"<em>OR</em></td>
</tr>
<tr>
<td>bondi_overwrite_boundary</td>
<td>"no"</td>
<td>reset data to initial data in outer boundary in boundary condition</td>
<td></td>
</tr>
<tr>
<td>poloidal_P_p</td>
<td>1</td>
<td>Index of pressure factor</td>
<td>(0:* :: "Any non-negative integer"<em>OR</em></td>
</tr>
<tr>
<td>rotor_xc</td>
<td>0.5</td>
<td>center of rotation</td>
<td><em>:</em> :: "Any location"<em>OR</em></td>
</tr>
<tr>
<td>rotor_yc</td>
<td>0.5</td>
<td>center of rotation</td>
<td><em>:</em> :: "Any location"<em>OR</em></td>
</tr>
<tr>
<td>rotor_bvcxl</td>
<td>1.0</td>
<td>intial component of Bvec[0]</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>rotor_bvcyl</td>
<td>0.0</td>
<td>intial component of Bvec[1]</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>rotor_bvczl</td>
<td>0.0</td>
<td>intial component of Bvec[2]</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>rotor_r_rot</td>
<td>0.1</td>
<td>radius of rotor</td>
<td>(0:* :: "any positive number"<em>OR</em></td>
</tr>
<tr>
<td>rotor_v_max</td>
<td>0.995</td>
<td>Maximum velocity</td>
<td>(-1:1) :: "any subluminal speed (negative is clockwise)"<em>OR</em></td>
</tr>
<tr>
<td>rotor_rhoin</td>
<td>10.d0</td>
<td>initial density inside rotor</td>
<td>(0:* :: "any positive number"<em>OR</em></td>
</tr>
<tr>
<td>rotor_pressin</td>
<td>1.d0</td>
<td>initial pressure inside rotor</td>
<td>(0:* :: "any positive number"<em>OR</em></td>
</tr>
<tr>
<td>rotor_rhoout</td>
<td>1.d0</td>
<td>initial density outside rotor</td>
<td>(0:* :: "any positive number"<em>OR</em></td>
</tr>
<tr>
<td>rotor_pressout</td>
<td>1.d0</td>
<td>initial pressure outside rotor</td>
<td>(0:* :: "any positive number"<em>OR</em></td>
</tr>
<tr>
<td>rotor_use_smoothing</td>
<td>yes</td>
<td>Smooth the edge?</td>
<td></td>
</tr>
<tr>
<td>rotor_rsmooth_rel</td>
<td>0.05</td>
<td>Define the radius in relative terms if so</td>
<td>(0:* :: "any positive number"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="grhydro">GRHydro</h3>
<p>GRHydro is the evolution code for a general-purpose 3D relativistic
hydrodynamics code. To work it requires Einstein, MoL (the method of
lines thorn), CactusEOS (the general equation of state interface).
In theory any (suitably written) spacetime evolution thorn should work,
but for the moment the MoL version of BSSN will be the tested version.</p>
<p>For more information see the documentation in the ThornGuide.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>metric_type</td>
<td>"never"</td>
<td></td>
<td>}<em>OR</em> <em>OR*EXTENDS KEYWORD shift_evolution_method ""*OR</em>{<em>OR</em>  "Comoving" :: "Set the shift so the matter is approximately comoving"<em>OR</em>}<em>OR**OR**OR</em>#########################################<em>OR</em>###  PARAMETRES SHARED FROM HydroBase ###<em>OR</em>#########################################<em>OR**OR*shares: HydroBase*OR**OR*USES CCTK_INT timelevels*OR*USES KEYWORD prolongation_type*OR*USES INT hydro_excision*OR*EXTENDS KEYWORD evolution_method ""*OR</em>{<em>OR</em>  "GRHydro" :: "Use GRHydro to evolve the hydro variables"<em>OR</em>}<em>OR*EXTENDS KEYWORD Bvec_evolution_method ""*OR</em>{<em>OR</em>  "GRHydro"      :: "Use GRHydro to evolve the MHD variables, evolving the Magnetic Field"<em>OR</em>  "GRHydro_Avec" :: "Use GRHydro to evolve the MHD variables, evolving the Vector Potential"<em>OR</em>}<em>OR*EXTENDS KEYWORD Y_e_evolution_method ""*OR</em>{<em>OR</em>  "GRHydro" :: "Use GRHydro to evolve Y_e"<em>OR</em>}<em>OR*EXTENDS KEYWORD temperature_evolution_method ""*OR</em>{<em>OR</em>  "GRHydro" :: "Use GRHydro to evolve temperature"<em>OR</em>}<em>OR*EXTENDS KEYWORD entropy_evolution_method ""*OR</em>{<em>OR</em>  "GRHydro" :: "Use GRHydro to evolve entropy"<em>OR</em>}<em>OR*EXTENDS KEYWORD initial_Bvec ""*OR</em>{<em>OR</em>  "Bvec_from_Avec" :: "Calculate B^i for an initially specified A_i"<em>OR</em>}<em>OR**OR</em>#########################################<em>OR</em>###  PARAMETRES SHARED FROM MoL       ###<em>OR</em>#########################################<em>OR**OR*shares: MethodOfLines*OR**OR*USES CCTK_INT MoL_Num_Evolved_Vars*OR*USES CCTK_INT MoL_Num_Evolved_Vars_Slow*OR*USES CCTK_INT MoL_Num_Constrained_Vars*OR*USES CCTK_INT MoL_Num_SaveAndRestore_Vars*OR*USES CCTK_INT MoL_Max_Evolved_Array_Size *OR*USES CCTK_INT MoL_Num_ArrayEvolved_Vars*OR**OR*shares:SpaceMask*OR**OR*USES boolean use_mask*OR**OR</em>#########################################<em>OR</em>###  PARAMETRES SHARED FROM EOS_Omni  ###<em>OR</em>#########################################<em>OR**OR*SHARES: EOS_Omni*OR**OR*USES REAL poly_k*OR**OR*restricted:*OR**OR*KEYWORD use_evolution_mask "Set this to 'always' to skip validity tests in regions where CarpetEvolutionMask::evolution_mask vanishes." STEERABLE=ALWAYS*OR</em>{<em>OR</em>  "always" :: "use the mask"<em>OR</em>  "auto"   :: "check if CarpetEvolutionMask is active, then use the mask"<em>OR</em>  "never"  :: "do not use the mask"<em>OR</em></td>
</tr>
<tr>
<td>GRHydro_enable_internal_excision</td>
<td>"true"</td>
<td>Set this to 'false' to disable the thorn-internal excision.</td>
<td></td>
</tr>
<tr>
<td>GRHydro_hydro_excision</td>
<td>1</td>
<td>Turns excision automatically on in HydroBase</td>
<td>1:1 :: "Only '1' allowed"<em>OR</em></td>
</tr>
<tr>
<td>sources_spatial_order</td>
<td>2</td>
<td>Order of spatial differencing of the source terms</td>
<td>2 :: "2<sup>nd</sup> order finite differencing"<em>OR*4 :: "4<sup>th</sup> order finite differencing"*OR</em></td>
</tr>
<tr>
<td>GRHydro_MaxNumEvolvedVars</td>
<td>5</td>
<td>The maximum number of evolved variables used by GRHydro</td>
<td>0             :: "when using multirate"<em>OR</em>  5:12     :: "dens scon[3] tau (B/A)vec[3] psidc ye entropy Aphi"<em>OR</em></td>
</tr>
<tr>
<td>GRHydro_MaxNumEvolvedVarsSlow</td>
<td>0</td>
<td>The maximum number of evolved variables used by GRHydro</td>
<td>0             :: "do not use multirate"<em>OR</em>  5:12     :: "dens scon[3] tau (B/A)vec[3] psidc ye entropy Aphi"<em>OR</em></td>
</tr>
<tr>
<td>GRHydro_MaxNumConstrainedVars</td>
<td>37</td>
<td>The maximum number of constrained variables used by GRHydro</td>
<td>7:48     :: "A small range, depending on testing or not"<em>OR</em></td>
</tr>
<tr>
<td>GRHydro_MaxNumSandRVars</td>
<td>16</td>
<td>The maximum number of save and restore variables used by GRHydro</td>
<td>0:16      :: "A small range, depending on testing or not"<em>OR</em></td>
</tr>
<tr>
<td>GRHydro_hot_atmo_temp</td>
<td>0.1e0</td>
<td>Temperature of the hot atmosphere in MeV</td>
<td>(0.0:*   :: "Larger than 0 MeV"<em>OR</em></td>
</tr>
<tr>
<td>GRHydro_max_temp</td>
<td>90.0e0</td>
<td>maximum temperature we allow</td>
<td>(0.0:*   :: "Larger than 0 MeV"<em>OR</em></td>
</tr>
<tr>
<td>GRHydro_hot_atmo_Y_e</td>
<td>0.5e0</td>
<td>Y_e of the hot atmosphere</td>
<td>0.0:*   :: "Larger than 0"<em>OR</em></td>
</tr>
<tr>
<td>GRHydro_Y_e_min</td>
<td>0.0</td>
<td>minimum allowed Y_e</td>
<td>0.0:*   :: "Larger than or equal to zero"<em>OR</em></td>
</tr>
<tr>
<td>GRHydro_Y_e_max</td>
<td>1.0</td>
<td>maximum allowed Y_e</td>
<td>0.0:*   :: "Larger than or equal to zero; 1 is default"<em>OR</em></td>
</tr>
<tr>
<td>sqrtdet_thr</td>
<td>-1.0</td>
<td>Threshold to apply cons rescalings deep inside the horizon</td>
<td>1.0:    :: "Larger values guarantees this sort of rescaling only deep inside the horizon"<em>OR</em> -1.0    :: "Do not apply limit"<em>OR</em></td>
</tr>
<tr>
<td>max_magnetic_to_gas_pressure_ratio</td>
<td>-1.0</td>
<td>consider pressure to be magnetically dominated if magnetic pressure to gas pressure ratio is higher than this</td>
<td>(0:*  :: "any positive value, eg. 100."<em>OR</em>  -1.0  :: "disable"<em>OR</em></td>
</tr>
<tr>
<td>GRHydro_rho_central</td>
<td>1.e-5</td>
<td>Central Density for Star</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>tau_rel_min</td>
<td>1.e-10</td>
<td>A minimum relative tau (taumin = maxtau(t=0) * tau_rel_min) below which tau is reschaled</td>
<td>0: :: ""<em>OR</em></td>
</tr>
<tr>
<td>rho_abs_min</td>
<td>-1.0</td>
<td>A minimum rho below which evolution is turned off (atmosphere). If negative, the relative minimum will be used instead.</td>
<td>-1.0: :: ""<em>OR</em></td>
</tr>
<tr>
<td>rho_rel_min</td>
<td>1.e-9</td>
<td>A minimum relative rho (rhomin = centden * rho_rel_min) below which evolution is turned off (atmosphere). Only used if rho_abs_min &lt; 0.0</td>
<td>0: :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_rho_abs_min</td>
<td>-1.0</td>
<td>An absolute value for rho in the atmosphere. To be used by initial data routines only. Unused if negative.</td>
<td>-1.0: :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_rho_rel_min</td>
<td>-1.0</td>
<td>A relative (to the central density) value for rho in the atmosphere. To be used by initial data routines only. Unused if negative.</td>
<td>-1.0: :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_atmosphere_factor</td>
<td>-1.0</td>
<td>A relative (to the initial atmosphere) value for rho in the atmosphere. This is used at initial time only. Unused if negative.</td>
<td>-1.0: :: ""<em>OR</em></td>
</tr>
<tr>
<td>rho_abs_min_after_recovery</td>
<td>-1.0</td>
<td>A new absolute value for rho in the atmosphere. To be used after recovering. Unused if negative.</td>
<td>-1.0: :: ""<em>OR</em></td>
</tr>
<tr>
<td>GRHydro_atmo_tolerance</td>
<td></td>
<td>A point is set to atmosphere in the Con2Prim's if its rho &lt; GRHydro_rho_min *(1+GRHydro_atmo_tolerance). This avoids occasional spurious oscillations in carpet buffer zones lying in the atmosphere (because prolongation happens on conserved variables)</td>
<td>0.0: :: "Zero or larger. A useful value could be 0.0001"<em>OR</em></td>
</tr>
<tr>
<td>atmo_falloff_radius</td>
<td>50.0</td>
<td>The radius for which the atmosphere starts to falloff as (atmo_falloff_radius/r)**atmo_falloff_power</td>
<td>0:* :: "Anything positive"<em>OR</em></td>
</tr>
<tr>
<td>atmo_falloff_power</td>
<td>0.0</td>
<td>The power at which the atmosphere level falls off as (atmo_falloof_radius/r)**atmo_falloff_power</td>
<td>0:* :: "Anything positive"<em>OR</em></td>
</tr>
<tr>
<td>atmo_tolerance_radius</td>
<td>50.0</td>
<td>The radius for which the atmosphere tolerance starts to increase as (r/atmo_tolerance_radius)**atmo_tolerance_power</td>
<td>0:* :: "Anything positive"<em>OR</em></td>
</tr>
<tr>
<td>atmo_tolerance_power</td>
<td>0.0</td>
<td>The power at which the atmosphere tolerance increases as (r/atmo_tolerance_radius)**atmo_tolerance_power</td>
<td>0:* :: "Anything positive"<em>OR</em></td>
</tr>
<tr>
<td>wk_atmosphere</td>
<td>"no"</td>
<td>Use some of Wolfgang Kastauns atmosphere tricks</td>
<td></td>
</tr>
<tr>
<td>Check_Rho_Minimum</td>
<td>"no"</td>
<td>Should a check on rho &lt; GRHydro_rho_min be performed and written as WARNING level 2?</td>
<td></td>
</tr>
<tr>
<td>use_weighted_fluxes</td>
<td>"no"</td>
<td>Weight the flux terms by the cell surface areas</td>
<td></td>
</tr>
<tr>
<td>particle_interpolator</td>
<td>"Lagrange</td>
<td>What interpolator should be used for the particles</td>
<td>".+"          :: "A valid interpolator name"<em>OR</em></td>
</tr>
<tr>
<td>particle_interpolation_order</td>
<td>2</td>
<td>What order should be used for the particle interpolation</td>
<td>1:*           :: "A valid positive interpolation order"<em>OR</em></td>
</tr>
<tr>
<td>GRHydro_NaN_verbose</td>
<td>2</td>
<td>The warning level for NaNs occuring within GRHydro</td>
<td>0:* :: "The warning level"<em>OR</em></td>
</tr>
<tr>
<td>GRHydro_lorentz_overshoot_cutoff</td>
<td>1.e100</td>
<td>Set the Lorentz factor to this value in case it overshoots (1/0)</td>
<td>0:* :: "Some big value"<em>OR</em></td>
</tr>
<tr>
<td>kap_dc</td>
<td>10.0</td>
<td>The kap parameter for divergence cleaning</td>
<td>0:* :: "Any non-negative value, but 1.0 to 10.0 seems preferred"<em>OR</em></td>
</tr>
<tr>
<td>psidcspeed</td>
<td>"light</td>
<td>Which speed to set for psidc</td>
<td>"char speed"  :: "Based on the characteristic speeds"<em>OR</em>  "light speed" :: "Set the characteristic speeds to speed of light"<em>OR</em>  "set speed"   :: "Manually set the characteristic speeds: [setcharmin,setcharmax]"<em>OR</em></td>
</tr>
<tr>
<td>setcharmax</td>
<td>1.0</td>
<td>Maximum characteristic speed for psidc if psidcspeed is set</td>
<td>0:1 :: "Any value smaller than speed of light"<em>OR</em></td>
</tr>
<tr>
<td>setcharmin</td>
<td>-1.0</td>
<td>Minimum characteristic speed for psidc if psidcspeed is set</td>
<td>-1:0 :: "Any value smaller than speed of light - sign should be negative"<em>OR</em></td>
</tr>
<tr>
<td>decouple_normal_Bfield</td>
<td>yes</td>
<td>when using divergence cleaning properly decouple Bx,psidc subsystem</td>
<td></td>
</tr>
<tr>
<td>Avec_gauge</td>
<td>"lorenz"</td>
<td>Which gauge condition to use when evolving the vector potential</td>
<td>"algebraic"  :: "Algebraic gauge"<em>OR</em>  "lorenz"     :: "Lorenz gauge"<em>OR</em></td>
</tr>
<tr>
<td>Tmunu_damping_radius_min</td>
<td>-1</td>
<td>damping radius at which we start to damp with a tanh function</td>
<td>-1  :: "damping switched off"<em>OR</em>   0:* :: "damping radius at which we start to damp"<em>OR</em></td>
</tr>
<tr>
<td>Tmunu_damping_radius_max</td>
<td>-1</td>
<td>damping radius at which Tmunu becomes 0</td>
<td>-1  :: "damping switched off"<em>OR</em>   0:* :: "greater than minimum radius above"<em>OR</em></td>
</tr>
<tr>
<td>sync_conserved_only</td>
<td>no</td>
<td>Only sync evolved conserved quantities during evolution.</td>
<td></td>
</tr>
<tr>
<td>use_MoL_slow_multirate_sector</td>
<td>no</td>
<td>Whether to make use of MoL's slow multirate sector</td>
<td></td>
</tr>
<tr>
<td>verbose</td>
<td>no</td>
<td>Some debug output</td>
<td></td>
</tr>
<tr>
<td>constrain_to_1D</td>
<td>no</td>
<td>Set fluid velocities to zero for non-radial motion</td>
<td></td>
</tr>
<tr>
<td>use_cxx_code</td>
<td>yes</td>
<td>Use experimental C++ code?</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="cactuspugh">CactusPUGH</h2>
<h3 id="pugh">PUGH</h3>
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides a unigrid parallel driver with MPI.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>periodic</td>
<td>"no"</td>
<td>Periodic boundary conditions</td>
<td></td>
</tr>
<tr>
<td>periodic_x</td>
<td>"yes"</td>
<td>Periodic boundary conditions in x-direction</td>
<td></td>
</tr>
<tr>
<td>periodic_y</td>
<td>"yes"</td>
<td>Periodic boundary conditions in y-direction</td>
<td></td>
</tr>
<tr>
<td>periodic_z</td>
<td>"yes"</td>
<td>Periodic boundary conditions in z-direction</td>
<td></td>
</tr>
<tr>
<td>global_nx</td>
<td>10</td>
<td>The size of the grid in the x direction</td>
<td>0:*     :: "Grid of this size distributed across all processors"<em>OR</em></td>
</tr>
<tr>
<td>global_ny</td>
<td>10</td>
<td>The size of the grid in the y direction</td>
<td>0:*     :: "Grid of this size distributed across all processors"<em>OR</em></td>
</tr>
<tr>
<td>global_nz</td>
<td>10</td>
<td>The size of the grid in the z direction</td>
<td>0:*     :: "Grid of this size distributed across all processors"<em>OR</em></td>
</tr>
<tr>
<td>global_nsize</td>
<td>-1</td>
<td>The size of the grid in each spatial direction</td>
<td>-1:*     :: "Grid of this size in each dir distributed across all processors"<em>OR</em></td>
</tr>
<tr>
<td>ghost_size_x</td>
<td>1</td>
<td>The width of the ghost zone in the x direction</td>
<td>0:*     :: "Must be a positive integer"<em>OR</em></td>
</tr>
<tr>
<td>ghost_size_y</td>
<td>1</td>
<td>The width of the ghost zone in the y direction</td>
<td>0:*     :: "Must be a positive integer"<em>OR</em></td>
</tr>
<tr>
<td>ghost_size_z</td>
<td>1</td>
<td>The width of the ghost zone in the z direction</td>
<td>0:*     :: "Must be a positive integer"<em>OR</em></td>
</tr>
<tr>
<td>ghost_size</td>
<td>-1</td>
<td>The width of the ghost zone in each direction</td>
<td>-1:*     :: "Any positive number to override the ghost_size_[xyz] parameters"<em>OR</em></td>
</tr>
<tr>
<td>info</td>
<td>"none"</td>
<td>Provide additional information about what PUGH is doing</td>
<td>"none" :: "No extra information"<em>OR</em>  "load" :: "Load on each processor"<em>OR</em></td>
</tr>
<tr>
<td>local_nx</td>
<td>-1</td>
<td>The size of the grid in the x direction</td>
<td>-1:*     :: "Grid of this size on each processor"<em>OR</em></td>
</tr>
<tr>
<td>local_ny</td>
<td>-1</td>
<td>The size of the grid in the y direction</td>
<td>-1:*     :: "Grid of this size on each processor"<em>OR</em></td>
</tr>
<tr>
<td>local_nz</td>
<td>-1</td>
<td>The size of the grid in the z direction</td>
<td>-1:*     :: "Grid of this size on each processor"<em>OR</em></td>
</tr>
<tr>
<td>local_nsize</td>
<td>-1</td>
<td>The size of the grid in each spatial direction</td>
<td>-1:*     :: "Grid of this size in each dir on each processor"<em>OR</em></td>
</tr>
<tr>
<td>local_size_includes_ghosts</td>
<td>"yes"</td>
<td>Does the local grid size include the ghost zones?</td>
<td></td>
</tr>
<tr>
<td>enable_all_storage</td>
<td>"no"</td>
<td>Enable storage for all GFs?</td>
<td></td>
</tr>
<tr>
<td>physical2logical</td>
<td>"direct"</td>
<td>Physical process to logical process mapping method to use</td>
<td>"direct"  :: "Maps MPI IDs directly to IJKs"<em>OR</em>  "example" :: "Maps MPI IDs directly to IJKs using a lookup table"<em>OR</em></td>
</tr>
<tr>
<td>processor_topology</td>
<td>"automatic"</td>
<td>How to determine the processor topology</td>
<td>"manual"        :: "Specified by proc_top_nx etc"<em>OR</em>  "automatic"     :: "Automatically generated"<em>OR</em>  "automatic_old" :: "Automatically generated (old method)"<em>OR</em></td>
</tr>
<tr>
<td>processor_topology_1d_x</td>
<td>0</td>
<td>Number of processors in X direction</td>
<td>0:*  :: "See proc_topology"<em>OR</em></td>
</tr>
<tr>
<td>processor_topology_2d_x</td>
<td>0</td>
<td>Number of processors in X direction</td>
<td>0:*  :: "See proc_topology"<em>OR</em></td>
</tr>
<tr>
<td>processor_topology_2d_y</td>
<td>0</td>
<td>Number of processors in Y direction</td>
<td>0:*  :: "See proc_topology"<em>OR</em></td>
</tr>
<tr>
<td>processor_topology_3d_x</td>
<td>0</td>
<td>Number of processors in X direction</td>
<td>0:*  :: "See proc_topology"<em>OR</em></td>
</tr>
<tr>
<td>processor_topology_3d_y</td>
<td>0</td>
<td>Number of processors in Y direction</td>
<td>0:*  :: "See proc_topology"<em>OR</em></td>
</tr>
<tr>
<td>processor_topology_3d_z</td>
<td>0</td>
<td>Number of processors in Z direction</td>
<td>0:*  :: "See proc_topology"<em>OR</em></td>
</tr>
<tr>
<td>initialize_memory</td>
<td>"none"</td>
<td>How to initialize memory for grid variables at allocation time</td>
<td>"none" :: "Do not initialize storage for allocated grid variables (default)"<em>OR</em>  "zero" :: "Zero out all elements of all allocated grid variables"<em>OR</em>  "NaN"  :: "Set all elements of allocated floating point grid variables to Not-a-Number values"<em>OR</em></td>
</tr>
<tr>
<td>partition</td>
<td>"automatic"</td>
<td>Is the partition manual</td>
<td>"automatic"    :: "even"<em>OR</em> "manual"       :: "specified by partition_XYZ .."<em>OR</em></td>
</tr>
<tr>
<td>partition_1d_x</td>
<td>""</td>
<td>Tells how to partition on direction X</td>
<td>.* :: "A regex which matches anything"<em>OR</em></td>
</tr>
<tr>
<td>partition_2d_x</td>
<td>""</td>
<td>Tells how to partition on direction X</td>
<td>.* :: "A regex which matches anything"<em>OR</em></td>
</tr>
<tr>
<td>partition_2d_y</td>
<td>""</td>
<td>Tells how to partition on direction y</td>
<td>.* :: "A regex which matches anything"<em>OR</em></td>
</tr>
<tr>
<td>partition_3d_x</td>
<td>""</td>
<td>Tells how to partition on direction X</td>
<td>.* :: "A regex which matches anything"<em>OR</em></td>
</tr>
<tr>
<td>partition_3d_y</td>
<td>""</td>
<td>Tells how to partition on direction y</td>
<td>.* :: "A regex which matches anything"<em>OR</em></td>
</tr>
<tr>
<td>partition_3d_z</td>
<td>""</td>
<td>Tells how to partition on direction z</td>
<td>.* :: "A regex which matches anything"<em>OR</em></td>
</tr>
<tr>
<td>storage_verbose</td>
<td>"no"</td>
<td>Report on memory assignment</td>
<td>"yes"    :: "Standard storage information"<em>OR</em>  "report" :: "Provide a report of storage every storage_report_every iterations and at termination"<em>OR</em>  "no"     :: "Provide no information"<em>OR</em></td>
</tr>
<tr>
<td>storage_report_every</td>
<td>0</td>
<td>How often to provide a report on storage information</td>
<td>0:0 :: "Never report"<em>OR</em>  1:* :: "Report at intervals"<em>OR</em></td>
</tr>
<tr>
<td>cacheline_mult</td>
<td>4001</td>
<td>Multiplier for cacheline number</td>
<td>0:*  ::  "Any positive number"<em>OR</em></td>
</tr>
<tr>
<td>overloadevolve</td>
<td>"yes"</td>
<td>Overload Evolve driver function</td>
<td></td>
</tr>
<tr>
<td>overloadsyncgroup</td>
<td>"no"</td>
<td>Overload SyncGroup driver function</td>
<td></td>
</tr>
<tr>
<td>overloadsyncgroupsbydiri</td>
<td>"yes"</td>
<td>Overload SyncGroupsByDirI driver function</td>
<td></td>
</tr>
<tr>
<td>overloadenablegroupstorage</td>
<td>"yes"</td>
<td>Overload EnableGroupStorage driver function</td>
<td></td>
</tr>
<tr>
<td>overloaddisablegroupstorage</td>
<td>"yes"</td>
<td>Overload DisableGroupStorage driver function</td>
<td></td>
</tr>
<tr>
<td>overloadenablegroupcomm</td>
<td>"yes"</td>
<td>Overload EnableGroupComm driver function</td>
<td></td>
</tr>
<tr>
<td>overloaddisablegroupcomm</td>
<td>"yes"</td>
<td>Overload DisableGroupComm driver function</td>
<td></td>
</tr>
<tr>
<td>overloadbarrier</td>
<td>"yes"</td>
<td>Overload Barrier driver function</td>
<td></td>
</tr>
<tr>
<td>overloadparallelinit</td>
<td>"yes"</td>
<td>Overload ParallelInit driver function</td>
<td></td>
</tr>
<tr>
<td>overloadexit</td>
<td>"yes"</td>
<td>Overload Exit driver function</td>
<td></td>
</tr>
<tr>
<td>overloadabort</td>
<td>"yes"</td>
<td>Overload Abort driver function</td>
<td></td>
</tr>
<tr>
<td>overloadmyproc</td>
<td>"yes"</td>
<td>Overload MyProc driver function</td>
<td></td>
</tr>
<tr>
<td>overloadnprocs</td>
<td>"yes"</td>
<td>Overload nProcs driver function</td>
<td></td>
</tr>
<tr>
<td>overloadarraygroupsizeb</td>
<td>"yes"</td>
<td>Overload ArrayGroupSizeB driver function</td>
<td></td>
</tr>
<tr>
<td>overloadquerygroupstorageb</td>
<td>"yes"</td>
<td>Overload QueryGroupStorageB driver function</td>
<td></td>
</tr>
<tr>
<td>overloadgroupdynamicdata</td>
<td>"yes"</td>
<td>Overload GroupDynamicData driver function</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="pughinterp">PUGHInterp</h3>
<ol>
<li>Purpose</li>
</ol>
<p>This thorn implements the Cactus flesh interpolation API routine
   CCTK_InterpGridArrays() which provides interpolation of CCTK grid
   arrays at arbitrary points.</p>
<ol>
<li>Additional Information</li>
</ol>
<p>More detailed information on thorn PUGHInterp is given in chapter
   about PUGHInterp in the Cactus ThornGuide (see doc/documentation.tex).</p>
<p>For information on how to invoke interpolation operators via the
   general flesh interpolation API please refer to the flesh documentation.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="pughreduce">PUGHReduce</h3>
<p>Cactus Code Thorn PUGHReduce
Author(s)    : Gabrielle Allen
               Tom Goodale
               Thomas Radke
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Standard reduction operators which use PUGH for communications</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="pughslab">PUGHSlab</h3>
<p>Cactus Code Thorn PUGHSlab
Author(s)    : Gabrielle Allen
               Tom Goodale
               Thomas Radke
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn implements the following parts of the CCTK hyperslab API:</p>
<ul>
<li>the definition of local and global hyperslab mappings based on grid indices</li>
<li>
<p>the extraction of local and global hyperslabs as specified by such
   mappings</p>
</li>
<li>
<p>Additional information</p>
</li>
</ul>
<p>The complete specification of the CCTK Hyperslab API and the description of
PUGHSlab's implementation of it are described in the corresponding ThornGuide
chapter for PUGHSlab (see file doc/documentation.tex).</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="numerical">Numerical</h2>
<h3 id="aeilocalinterp">AEILocalInterp</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<p>Cactus Code Thorn AEILocalInterp
Thorn Author(s)     : Jonathan Thornburg <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Thorn Maintainer(s) : Jonathan Thornburg <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<hr />
<h1 id="purpose-of-the-thorn">Purpose of the thorn</h1>
<p>This thorn does processor-local interpolation of N-dimensional data
arrays, using the CCTK_InterpLocalUniform() API.  The data arrays
(in general there may be many of them) must be defined on a uniformly
spaced grid.</p>
<p>This thorn provides the interpolation operators
   "Lagrange polynomial interpolation (tensor product)"
   "Lagrange polynomial interpolation (maximum degree)"
   "Hermite polynomial interpolation",
The interpolation operator
   "Lagrange polynomial interpolation"
is also accepted as a synonyms
   "Lagrange polynomial interpolation (tensor product)"
(So is "generalized polynomial interpolation", but that's deprecated
and will probably be removed at some point.)</p>
<h1 id="documentation">Documentation</h1>
<p>There are 3 main sources of user documentation for this thorn:
- The Cactus Users' Guide, chapter "Application Thorn Writing",
  section "Cactus Application Interfaces", subsection "Interpolation
  Operators" (at present this is section B8.3), describes the general
  Cactus system for interpolation operators.
- The Cactus Users' Guide, chapter "Function Reference", section
  "Cactus Functions", has an entry giving a detailed description of
  the CCTK_InterpLocalUniform() interpolation API which this thorn
  supports.  This is probably the place to start reading; it also
  has a simple example.
- This thorn's Thorn Guide gives a detailed description of the
  interpolation operators this thorn supports, and their mandatory
  and optional parameter-table entries.  The Thorn Guide also
  includes both simple and more complicated examples.</p>
<h1 id="history">History</h1>
<p>This interpolator was written by Jonathan Thornburg in winter 2001-2002.
Between then and July 2003 it lived in CactusBase/LocalInterp (in the
 src/GeneralizedPolynomial-Uniform/  subdirectory), but in July 2003 it
was moved to this (new) thorn so it could stay GPL (Cactus policies forbid
GPL code in the CactusBase arrangement).  See  CactusBase/LocalInterp/
for the older CVS history.</p>
<h1 id="copyright-licensing">Copyright &amp; Licensing</h1>
<p>This thorn is copyright (C) 2001-2003
by Jonathan Thornburg <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>.</p>
<p>This thorn is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.</p>
<p>This thorn is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this thorn (see the file COPYING in this directory);
if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA</p>
<p>See the README files in the individual interpolators' directories
for more information.</p>
<h1 id="other-interpolation-thorns">Other Interpolation Thorns</h1>
<p>As well as this thorn, there are some other Cactus thorns that also
provide interpolation APIs:</p>
<p>CactusBase/LocalInterp
    This contains an older processor-local interpolator, supporting
    the interpolation operator
       "uniform cartesian"</p>
<p>There are also driver-specific thorns providing global (grid array)
interpolation, eg. PUGHInterp, CarpetInterp, etc.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="cactustest">CactusTest</h2>
<h3 id="testtimers">TestTimers</h3>
<p>Cactus Code Thorn TestTimers
Author(s)    : Cactus team
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn demonstrates and tests the use of Timers in thorns.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="testtable">TestTable</h3>
<p>Cactus Code Thorn TestTable
Author(s)    : Jonathan Thornburg
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn contains a test driver for the Cactus key/value tables
API, Util_Table*().</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="testreduce">TestReduce</h3>
<p>Cactus Code Thorn TestReduce
Author(s)    : unknown
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>not documented</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="testfortrandependencies1">TestFortranDependencies1</h3>
<p>Cactus Code Thorn TestFortranDependencies1
Author(s)    : Erik Schnetter
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Test Fortran intra-thorn and inter-thorn make dependencies.  This
thorn contains the intra-thorn dependencies, and depends on the thorn
TestFortranDependencies2.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="testcoordinates">TestCoordinates</h3>
<p>Cactus Code Thorn TestCoordinates
Author(s)    : Gabrielle Allen
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Test the Cactus coordinate infrastructure.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>domain</td>
<td>"full"</td>
<td>Domain type</td>
<td>"octant"   :: "Use an octant about the origin"<em>OR</em>  "quadrant" :: "Use a quadrant in x-y plane"<em>OR</em>  "bitant"   :: "Use a bitant about the x-y plane"<em>OR</em>  "full"     :: "Use the full domain"<em>OR</em></td>
</tr>
<tr>
<td>bitant_plane</td>
<td>"xy"</td>
<td>Plane defining bitant domain</td>
<td>"xy"       :: "xy-plane"<em>OR</em>  "xz"       :: "xz-plane"<em>OR</em>  "yz"       :: "yz-plane"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="testloop">TestLoop</h3>
<p>Cactus Code Thorn TestLoop
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>not documented</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="testinclude2">TestInclude2</h3>
<p>Cactus Code Thorn TestInclude2
Author(s)    : unknown
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>not documented</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="testglobalreduce">TestGlobalReduce</h3>
<p>Cactus Code Thorn TestGlobalReduce
Author(s)    : Yaakoub Y El Khamra
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>not documented</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>array_nx</td>
<td>5</td>
<td>Size of arrays in x direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array_ny</td>
<td>4</td>
<td>Size of arrays in y direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>array_nz</td>
<td>10</td>
<td>Size of arrays in z direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>dest_proc</td>
<td>0</td>
<td>processor to which reduction is to be made</td>
<td><em>:</em> :: "number can be any valid integer"<em>OR</em></td>
</tr>
<tr>
<td>map_x</td>
<td>10</td>
<td>number of original points to map to in x-direction</td>
<td>0:* :: "has to be positive"<em>OR</em></td>
</tr>
<tr>
<td>map_y</td>
<td>10</td>
<td>number of original points to map to in y-direction</td>
<td>0:* :: "has to be positive"<em>OR</em></td>
</tr>
<tr>
<td>map_z</td>
<td>10</td>
<td>number of original points to map to in z-direction</td>
<td>0:* :: "has to be positive"<em>OR</em></td>
</tr>
<tr>
<td>radius</td>
<td>0.1</td>
<td>The radius of the gaussian wave</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>sigma</td>
<td>0.1</td>
<td>The sigma for the gaussian wave</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>amplitude</td>
<td>1.0</td>
<td>The amplitude of the waves</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>uniform_weight_value</td>
<td>0.5</td>
<td>The uniform value of the weight</td>
<td><em>:</em>  :: "Can be anything"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="testfortrandependencies2">TestFortranDependencies2</h3>
<p>Cactus Code Thorn TestFortranDependencies2
Author(s)    : Erik Schnetter
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Test Fortran intra-thorn and inter-thorn make dependencies.  Thorn
TestFortranDependencies1 depends on this thorn.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="teststrings">TestStrings</h3>
<p>Cactus Code Thorn TestStrings
Author(s)    : Cactus team
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Test use of strings in Cactus. At the moment:</p>
<p>1) Calling C routines from Fortran with 1, 2 and 3 strings in the
   argument list.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="testfortrancraypointers">TestFortranCrayPointers</h3>
<p>Cactus Code Thorn TestFortranCrayPointers
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;">&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;">&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;</a>
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Test Fortran Cray pointers.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="testfreef90">TestFreeF90</h3>
<p>Cactus Code Thorn TestFreeF90
Author(s)    : Erik Schnetter
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Test automatic line breaks in free-form Fortran 90 code.</p>
<p>This thorn contains no test parameter files, the test is whether or
not it compiles.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="testmath">TestMath</h3>
<p>Cactus Code Thorn TestMath
Author(s)    : unknown
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Test whether <cmath> functions compile in C++.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="testinclude1">TestInclude1</h3>
<p>Cactus Code Thorn TestInclude1
Author(s)    : unknown
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>not documented</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="testtypes">TestTypes</h3>
<p>Cactus Code Thorn TestTypes
Author(s)    : Erik Schnetter
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Test most of the variable types.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>pint</td>
<td>1</td>
<td>int parameter</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>preal</td>
<td>1.0</td>
<td>real parameter</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>pboolean</td>
<td>yes</td>
<td>boolean parameter</td>
<td></td>
</tr>
<tr>
<td>pstring</td>
<td>"a"</td>
<td>string parameter</td>
<td>.* :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="testfpointernull">TestFpointerNULL</h3>
<p>Cactus Code Thorn TestFpointerNULL
Author(s)    : Thomas Radke
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn tests whether a Fortran routine accepts a NULL pointer reference
as a function argument when called from a C function. The code should not crash
as long as the NULL pointer argument isn't dereferenced.</p>
<p>Currently this mechanism is used by the Cactus scheduler bindings C functions
which pass unallocated grid variables as NULL pointers to a scheduled Fortran
routine. Cactus makes the assumption here that those NULL pointers are legal
function arguments.</p>
<p>Once we find out that this basic assumption is no longer true we have a problem.
So always run this thorn's testsuite on a new platform / with a new fortran
compiler !</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="testcomplex">TestComplex</h3>
<p>Cactus Code Thorn TestComplex
Author(s)    : unknown
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>not documented</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>power_value</td>
<td>0.5</td>
<td>power of the complex number to take</td>
<td>0.0: :: "Some positive value"<em>OR</em></td>
</tr>
<tr>
<td>real_value</td>
<td>3</td>
<td>power of the complex number to take</td>
<td><em>:</em> :: "real part"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="testschedule">TestSchedule</h3>
<p>Cactus Code Thorn TestSchedule
Author(s)    : Rion Dooley
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn is used to test that all schedule bins are executed.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="testarrays">TestArrays</h3>
<p>Cactus Code Thorn TestArrays
Author(s)    : unknown
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>not documented</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>xghost4d</td>
<td>1</td>
<td>Ghostzone size in x direction for 4d arrays</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>yghost4d</td>
<td>1</td>
<td>Ghostzone size in y direction for 4d arrays</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>zghost4d</td>
<td>1</td>
<td>Ghostzone size in z direction for 4d arrays</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>tghost4d</td>
<td>1</td>
<td>Ghostzone size in t direction for 4d arrays</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>xsize4d</td>
<td>2</td>
<td>Size of 4d array in x direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>ysize4d</td>
<td>3</td>
<td>Size of 4d array in y direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>zsize4d</td>
<td>2</td>
<td>Size of 4d array in z direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>tsize4d</td>
<td>2</td>
<td>Size of 4d array in t direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>xghost3d</td>
<td>1</td>
<td>Ghostzone size in x direction for 3d arrays</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>yghost3d</td>
<td>1</td>
<td>Ghostzone size in y direction for 3d arrays</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>zghost3d</td>
<td>1</td>
<td>Ghostzone size in z direction for 3d arrays</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>xsize3d</td>
<td>2</td>
<td>Size of 3d array in x direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>ysize3d</td>
<td>3</td>
<td>Size of 3d array in y direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>zsize3d</td>
<td>2</td>
<td>Size of 3d array in z direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>xghost2d</td>
<td>1</td>
<td>Ghostzone size in x direction for 2d arrays</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>yghost2d</td>
<td>1</td>
<td>Ghostzone size in y direction for 2d arrays</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>xsize2d</td>
<td>2</td>
<td>Size of 2d array in x direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>ysize2d</td>
<td>3</td>
<td>Size of 2d array in y direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>xghost1d</td>
<td>1</td>
<td>Ghostzone size in x direction for 1d arrays</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>xsize1d</td>
<td>2</td>
<td>Size of 1d array in x direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="testpar">TestPar</h3>
<p>Cactus Code Thorn TestPar
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Test parameter file syntax.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>string1</td>
<td>""</td>
<td></td>
<td>".<em>" :: "Any string"*OR</em></td>
</tr>
<tr>
<td>string2</td>
<td>""</td>
<td></td>
<td>".<em>" :: "Any string"*OR</em></td>
</tr>
<tr>
<td>string3</td>
<td>""</td>
<td></td>
<td>".<em>" :: "Any string"*OR</em></td>
</tr>
<tr>
<td>string4</td>
<td>""</td>
<td></td>
<td>".<em>" :: "Any string"*OR</em></td>
</tr>
<tr>
<td>string5</td>
<td>""</td>
<td></td>
<td>".<em>" :: "Any string"*OR</em></td>
</tr>
<tr>
<td>string6</td>
<td>""</td>
<td></td>
<td>".<em>" :: "Any string"*OR</em></td>
</tr>
<tr>
<td>string7</td>
<td>""</td>
<td></td>
<td>".<em>" :: "Any string"*OR</em></td>
</tr>
<tr>
<td>string8</td>
<td>""</td>
<td></td>
<td>".<em>" :: "Any string"*OR</em></td>
</tr>
<tr>
<td>string9</td>
<td>""</td>
<td></td>
<td>".<em>" :: "Any string"*OR</em></td>
</tr>
<tr>
<td>out_dir</td>
<td>""</td>
<td>Where to write output</td>
<td>".<em>" :: "Any valid path"*OR</em></td>
</tr>
</tbody>
</table>
<h3 id="testalltypes">TestAllTypes</h3>
<p>Cactus Code Thorn TestAllTypes
Author(s)    : Erik Schnetter
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Test all the variable types.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>pint</td>
<td>1</td>
<td>int parameter</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>preal</td>
<td>1.0</td>
<td>real parameter</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>pboolean</td>
<td>yes</td>
<td>boolean parameter</td>
<td></td>
</tr>
<tr>
<td>pstring</td>
<td>"a"</td>
<td>string parameter</td>
<td>.* :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="testmol">TestMoL</h3>
<p>Cactus Code Thorn TestMoL
Author(s)    : Roland Haas <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#104;&#97;&#97;&#115;&#64;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#104;&#97;&#97;&#115;&#64;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Roland Haas <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#104;&#97;&#97;&#115;&#64;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#104;&#97;&#97;&#115;&#64;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Tests the ODE integration methods in MoL by providing a simple right-hand-side
and tests that exercise all integration methods.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>RHSexpression</td>
<td>"1"</td>
<td>expression to use for the right-hand-side of the ODE</td>
<td>"1" :: "unit rhs"<em>OR</em>  "t" :: "linear in time rhs"<em>OR</em>  "t**2" :: "quadratic in time rhs"<em>OR</em>  "t**3" :: "cubic in time rhs"<em>OR</em>  "t**4" :: "quartic in time rhs"<em>OR</em>  "t**5" :: "quintic in time rhs"<em>OR</em>  "t**6" :: "sixth order in time rhs"<em>OR</em>  "t**7" :: "seventh order in time rhs"<em>OR</em>  "t**8" :: "eight order in time rhs"<em>OR</em>  "t**9" :: "ninth order in time rhs"<em>OR</em>  "exp(t)" :: "exponential in time rhs"<em>OR</em></td>
</tr>
<tr>
<td>RHSSlowexpression</td>
<td>"1"</td>
<td>expression to use for the right-hand-side of the slow ODE</td>
<td>"1" :: "unit rhs"<em>OR</em>  "t" :: "linear in time rhs"<em>OR</em>  "t**2" :: "quadratic in time rhs"<em>OR</em>  "t**3" :: "cubic in time rhs"<em>OR</em>  "t**4" :: "quartic in time rhs"<em>OR</em>  "t**5" :: "quintic in time rhs"<em>OR</em>  "t**6" :: "sixth order in time rhs"<em>OR</em>  "t**7" :: "seventh order in time rhs"<em>OR</em>  "t**8" :: "eight order in time rhs"<em>OR</em>  "t**9" :: "ninth order in time rhs"<em>OR</em>  "exp(t)" :: "exponential in time rhs"<em>OR</em></td>
</tr>
<tr>
<td>evolve_grid_function</td>
<td>"yes"</td>
<td>register an evolved grid function with MoL</td>
<td></td>
</tr>
<tr>
<td>evolve_grid_array</td>
<td>"yes"</td>
<td>register an evolved grid array with MoL</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="cactusdoc">CactusDoc</h2>
<h3 id="coredoc">CoreDoc</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<p>Cactus Code Thorn CoreDoc
Thorn Author(s)     : Cactus Maintainers <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#97;&#99;&#116;&#117;&#115;&#109;&#97;&#105;&#110;&#116;&#64;&#99;&#97;&#99;&#116;&#117;&#115;&#99;&#111;&#100;&#101;&#46;&#111;&#114;&#103;">&#99;&#97;&#99;&#116;&#117;&#115;&#109;&#97;&#105;&#110;&#116;&#64;&#99;&#97;&#99;&#116;&#117;&#115;&#99;&#111;&#100;&#101;&#46;&#111;&#114;&#103;</a>
Thorn Maintainer(s) : Cactus Maintainers <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#97;&#99;&#116;&#117;&#115;&#109;&#97;&#105;&#110;&#116;&#64;&#99;&#97;&#99;&#116;&#117;&#115;&#99;&#111;&#100;&#101;&#46;&#111;&#114;&#103;">&#99;&#97;&#99;&#116;&#117;&#115;&#109;&#97;&#105;&#110;&#116;&#64;&#99;&#97;&#99;&#116;&#117;&#115;&#99;&#111;&#100;&#101;&#46;&#111;&#114;&#103;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>Documentation that spans multiple thorns.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="einsteineos">EinsteinEOS</h2>
<h3 id="eos_omni">EOS_Omni</h3>
<p>Cactus Code Thorn EOS_Omni
Author(s)    : Christian D. Ott <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#111;&#116;&#116;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#99;&#111;&#116;&#116;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Christian D. Ott <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#111;&#116;&#116;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#99;&#111;&#116;&#116;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Licence      : LGPL</p>
<hr />
<p>This Thorn provides a one-fits-all EOS handler.
All EOS are actually implemented right inside this single
thorn without crazy interfaces and lots of function calls.</p>
<p>eoskey controls the type of EOS being used:</p>
<p>eoskey:</p>
<p>1 --- polytropic EOS
2 --- gamma-law EOS
3 --- hybrid EOS
4 --- finite-T microphysical NSE EOS</p>
<p>keyerr settings:</p>
<p>-1 -- called EOS routine with keytemp=1, but
      routine does not allow such a call</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>poly_gamma</td>
<td>2.0</td>
<td>Adiabatic Index for poly EOS</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>poly_gamma_initial</td>
<td>-1</td>
<td>Initial Adiabatic Index for poly and hybrid EOS</td>
<td>-1   :: "use poly_gamma/hybrid_gamma, ie no change in gamma during ID"<em>OR</em> (0:* :: "assume that ID used this adiabiatic index, change K accordingly"<em>OR</em></td>
</tr>
<tr>
<td>poly_k</td>
<td>100.0</td>
<td>Polytropic constant in c=G=Msun=1</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>gl_gamma</td>
<td>2.0</td>
<td>Adiabatic Index for gamma-law EOS</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>gl_k</td>
<td>100.0</td>
<td>Polytropic constant in c=G=Msun=1 for gamma-law EOS</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>hybrid_gamma_th</td>
<td>1.5</td>
<td>Thermal gamma for hybrid EOS</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>n_pieces</td>
<td>2</td>
<td>Number of polytropic pieces</td>
<td>0:10 :: "Max 10 pieces"<em>OR</em></td>
</tr>
<tr>
<td>hybrid_k0</td>
<td>0.0</td>
<td>K coefficent of the first piece</td>
<td>0:* :: "Any positive"<em>OR</em></td>
</tr>
<tr>
<td>hybrid_gamma1</td>
<td>1.325</td>
<td>subnuclear adiabatic Index for hybrid EOS</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>hybrid_gamma2</td>
<td>2.5</td>
<td>subnuclear adiabatic Index for hybrid EOS</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>hybrid_k1</td>
<td>0.4640517</td>
<td>Polytropic constant in c=G=Msun=1 for hybrid EOS</td>
<td>0:* :: "Any positive"<em>OR</em></td>
</tr>
<tr>
<td>hybrid_rho_nuc</td>
<td>3.238607e-4</td>
<td>Density at which to switch between gammas; c=G=Msun=1</td>
<td>0:* :: "Any positive"<em>OR</em></td>
</tr>
<tr>
<td>coldeos_table_name</td>
<td>"blah.asc"</td>
<td>table name for cold EOS (ASCII)</td>
<td>.* :: "Can be anything"<em>OR</em></td>
</tr>
<tr>
<td>coldeos_read_table</td>
<td>"No"</td>
<td>Read in cold EOS table?</td>
<td></td>
</tr>
<tr>
<td>coldeos_use_thermal_gamma_law</td>
<td>"Yes"</td>
<td>use an additional thermal gamma?</td>
<td></td>
</tr>
<tr>
<td>barotropiceos_table_name</td>
<td>"blah.asc"</td>
<td>table name for barotropic EOS (ASCII)</td>
<td>.* :: "Can be anything"<em>OR</em></td>
</tr>
<tr>
<td>barotropiceos_read_table</td>
<td>"No"</td>
<td>Read in barotropic EOS table?</td>
<td></td>
</tr>
<tr>
<td>barotropiceos_use_thermal_gamma_law</td>
<td>"Yes"</td>
<td>use an additional thermal gamma?</td>
<td></td>
</tr>
<tr>
<td>barotropiceos_gammath</td>
<td>2.0</td>
<td>thermal gamma for barotropic EOS</td>
<td>1.0:* :: "something"<em>OR</em></td>
</tr>
<tr>
<td>nuceos_read_table</td>
<td>"No"</td>
<td>Read in EOS table?</td>
<td></td>
</tr>
<tr>
<td>do_energy_shift</td>
<td>"yes"</td>
<td>shift energies around?</td>
<td></td>
</tr>
<tr>
<td>dump_nuceos_table</td>
<td>"No"</td>
<td>Dump table in ASCII at beginning</td>
<td></td>
</tr>
<tr>
<td>dump_nuceos_table_name</td>
<td>"blah.asc"</td>
<td>nuceos dump table name (ASCII)</td>
<td>.* :: "Can be anything"<em>OR</em></td>
</tr>
<tr>
<td>nuceos_table_name</td>
<td>"blah.h5"</td>
<td>nuceos table name (hdf5)</td>
<td>.* :: "Can be anything"<em>OR</em></td>
</tr>
<tr>
<td>read_table_on_single_process</td>
<td>"no"</td>
<td>read table on one process only and bcast data</td>
<td></td>
</tr>
<tr>
<td>reader_process</td>
<td>0</td>
<td>read table on this process and bcast data</td>
<td>0:* :: "read on process N"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="eos_hybrid">EOS_Hybrid</h3>
<p>Cactus Code Thorn EOS_Hybrid
Author(s)    : Harry Dimmelmeier
               Ian Hawke
               Christian Ott
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn implements the EOS used by Dimmelmeier Novak Font Ibanez Mueller PRD71 064023 (2005) in
core collapse simulations. Requires the CactusEOS infrastructure.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>eos_gamma_th</td>
<td>1.5</td>
<td>Gamma_th for EOS</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>eos_gamma_supernuclear</td>
<td>1.66666666666666</td>
<td>Gamma_2 for EOS</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>rho_nuc</td>
<td>1.e-10</td>
<td>Nuclear matter density</td>
<td>: :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="eos_polytrope">EOS_Polytrope</h3>
<p>Cactus Code Thorn EOS_Polytrope
Author(s)    : Ian Hawke
               Frank Löffler
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This is a "faked" polytropic equation of state. It is designed to work
through the CactusEOS interface.
The EoS reads Pressure = eos_k * rho ** (eos_gamma). The specific internal
energy is given by the assumption of a perfect fluid.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>eos_gamma</td>
<td>2.0</td>
<td>Adiabatic Index for Ideal Fluid</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>eos_k</td>
<td>80.0</td>
<td>Polytropic constant</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>use_cgs</td>
<td>"no"</td>
<td>Use the CGS units</td>
<td></td>
</tr>
<tr>
<td>gamma_ini</td>
<td>2.0</td>
<td>Polytropic Gamma used for the initial model (e.g., by RNSID)</td>
<td>: :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="eos_idealfluid">EOS_IdealFluid</h3>
<p>Cactus Code Thorn EOS_Ideal_Fluid
Author(s)    : ...
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>...</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>eos_ideal_fluid_gamma</td>
<td>2.0</td>
<td>Adiabatic Index for Ideal Fluid</td>
<td>: :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h2 id="einsteinutils">EinsteinUtils</h2>
<h3 id="tgrtensor">TGRtensor</h3>
<p>Cactus Code Thorn TGRtensor
Authors    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#117;&#110;&#105;&#45;&#116;&#117;&#101;&#98;&#105;&#110;&#103;&#101;&#110;&#46;&#100;&#101;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#117;&#110;&#105;&#45;&#116;&#117;&#101;&#98;&#105;&#110;&#103;&#101;&#110;&#46;&#100;&#101;</a>
CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<hr />
<p>Purpose of the thorn:</p>
<p>It contains generic tensor operations and other generic stuff.</p>
<p>TODO: Move lapack routines to thorn LAPACK</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="setmask_sphericalsurface">SetMask_SphericalSurface</h3>
<p>Cactus Code Thorn SetMask_SphericalSurface
Author(s)    : Frank Löffler
Maintainer(s): Frank Löffler
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Sets a given mask according to given spherical surfaces and parameters.
One example usage is to set the excision mask based on information from
an apparent horizon finder which is stored as a spherical surface.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>SetMask_MaskName</td>
<td>"HydroBase::hydro_excision_mask"</td>
<td>Full variable name of the mask to be set</td>
<td>".+" :: "Any full Cactus variable name, GF of type CCTK_BYTE"<em>OR</em></td>
</tr>
<tr>
<td>SetMask_ResetAll</td>
<td>"yes"</td>
<td>'yes' (default): Overwrite complete mask, 'no': Only set excision points</td>
<td>#</td>
</tr>
</tbody>
</table>
<h2 id="cactuselliptic">CactusElliptic</h2>
<h3 id="ellsor">EllSOR</h3>
<p>Cactus Code Thorn EllSOR
Author(s)    : Cactus team
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides basic elliptic solvers for different equation types 
using SOR iterative methods. The thorn is written to be robust and 
pedagogical rather that a viable fast solver.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="ellpetsc">EllPETSc</h3>
<p>Cactus Code Thorn EllPETSc
Author(s)    : Cactus team
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn shows how PETSc can be used with the EllBase Elliptic 
solver interface. </p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>petsc_verbose</td>
<td>"yes"</td>
<td>PETSc verbose output</td>
<td>"no"   :: "No output"<em>OR</em>"yes"  :: "Some output"<em>OR</em>"debug":: "Tons of output"<em>OR</em></td>
</tr>
<tr>
<td>petsc_reuse</td>
<td>"no"</td>
<td>Reuse parts of the PETSc structure</td>
<td></td>
</tr>
<tr>
<td>petsc_coeff_to_one</td>
<td>"no"</td>
<td>Divide each line of the matrix by the central value?</td>
<td></td>
</tr>
<tr>
<td>petsc_KSP_type</td>
<td>"PCJACOBI"</td>
<td>Which Krylov subspace method to use</td>
<td>"KSPCR"         :: "pcr"<em>OR</em> "KSPCG"         :: "cg"<em>OR</em> "KSPCGS"        :: "cgs"<em>OR</em> "KSPBCGS"       :: "bcgs"<em>OR</em> "KSPLSQR"       :: "lsqr"<em>OR</em> "KSPGMRES"      :: "gmres"<em>OR</em> "KSPTCQMR"      :: "tcqmr"<em>OR</em> "KSPTFQMR"      :: "tfqmr"<em>OR</em> "KSPCHEBYCHEV"  :: "chebyshev"<em>OR</em> "KSPCHEBYSHEV"  :: "chebyshev"<em>OR</em> "KSPRICHARDSON" :: "richardson"<em>OR</em>}"KSPBCGS" <em>OR**OR*KEYWORD petsc_PC_type "Which preconditioner method to use"*OR</em>{<em>OR</em> "PCNONE"    :: "none"<em>OR</em> "PCJACOBI"  :: "jacobi"<em>OR</em> "PCBJACOBI" :: "bjacobi"<em>OR</em> "PCICC"     :: "icc"<em>OR</em> "PCILU"     :: "ilu"<em>OR</em> "PCASM"     :: "asm"<em>OR</em> "PCLU"      :: "lu"<em>OR</em></td>
</tr>
<tr>
<td>petsc_nablaform</td>
<td>"down"</td>
<td>PETSC nabla form</td>
<td>"up"      :: ""<em>OR</em>  "down"    :: ""<em>OR</em></td>
</tr>
<tr>
<td>PetscTolStyle</td>
<td>0</td>
<td>PETSc Tolerance flavors FIXME</td>
<td># 0: :: ""<em>OR</em>#</td>
</tr>
</tbody>
</table>
<h3 id="tatelliptic">TATelliptic</h3>
<p>Cactus Code Thorn TATelliptic
Authors    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#117;&#110;&#105;&#45;&#116;&#117;&#101;&#98;&#105;&#110;&#103;&#101;&#110;&#46;&#100;&#101;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#117;&#110;&#105;&#45;&#116;&#117;&#101;&#98;&#105;&#110;&#103;&#101;&#110;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>This is a generic interface to nonlinear elliptic solvers.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="tatpetsc">TATPETSc</h3>
<p>Cactus Code Thorn TGRPETSc
Authors    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#117;&#110;&#105;&#45;&#116;&#117;&#101;&#98;&#105;&#110;&#103;&#101;&#110;&#46;&#100;&#101;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#117;&#110;&#105;&#45;&#116;&#117;&#101;&#98;&#105;&#110;&#103;&#101;&#110;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>It is an interface to PETSc, which is used here to solve elliptic
equations.  An interface to SNESsolve, the solver for nonlinear
elliptic equations, is exported.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Produce log output while running</td>
<td></td>
</tr>
<tr>
<td>veryverbose</td>
<td>"no"</td>
<td>Produce much log output while running</td>
<td></td>
</tr>
<tr>
<td>options</td>
<td>""</td>
<td>Command line options for PETSc</td>
<td>.* :: "no restriction"<em>OR</em></td>
</tr>
<tr>
<td>mglevels</td>
<td>2</td>
<td>Number of multigrid levels</td>
<td>#  2:* :: "Anything"<em>OR</em>#</td>
</tr>
</tbody>
</table>
<h3 id="ellbase">EllBase</h3>
<p>Cactus Code Thorn EllBase
Author(s)    : unknown
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn does ...</p>
<ol>
<li>Dependencies of the thorn</li>
</ol>
<p>This thorn additionally requires implementations and thorns ...</p>
<ol>
<li>Thorn distribution</li>
</ol>
<p>This thorn is available to ...</p>
<ol>
<li>Additional information</li>
</ol>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>elliptic_verbose</td>
<td>"no"</td>
<td>elliptic verbosity</td>
<td>"yes"  :: "be verbose in elliptic"<em>OR</em>  "no"   :: "silence in elliptic"<em>OR</em>  "debug":: "even more verbose in elliptic"<em>OR</em></td>
</tr>
</tbody>
</table>
<h2 id="carpet">Carpet</h2>
<h3 id="carpetiobasic">CarpetIOBasic</h3>
<p>Cactus Code Thorn CarpetIOBasic
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides info output for Carpet.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>outInfo_vars</td>
<td>""</td>
<td>Variables to output in scalar form</td>
<td>"" :: "A regex which matches everything"<em>OR</em></td>
</tr>
<tr>
<td>outInfo_reductions</td>
<td>"minimum</td>
<td>List of reductions to output in scalar form</td>
<td>"" :: "A regex which matches everything"<em>OR</em></td>
</tr>
<tr>
<td>outInfo_criterion</td>
<td>"iteration"</td>
<td>Criterion to select scalar output intervals, overrides out_every</td>
<td>"never"     :: "Never output"<em>OR</em>  "iteration" :: "Output every so many iterations"<em>OR</em>  "divisor"   :: "Output if iteration mod divisor == 0."<em>OR</em>  "time"      :: "Output every that much coordinate time"<em>OR</em></td>
</tr>
<tr>
<td>outInfo_every</td>
<td>-2</td>
<td>How often to do scalar output, overrides IO::out_every</td>
<td>1:* :: "Output every so many time steps"<em>OR</em>  -1:0 :: "No output"<em>OR</em>  -2   :: "Default to IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>outInfo_dt</td>
<td>-2</td>
<td>How often to do scalar output, overrides out_dt</td>
<td>(0:* :: "In intervals of that much coordinate time"<em>OR</em>   0   :: "As often as possible"<em>OR</em>  -1   :: "Disable output"<em>OR</em>  -2   :: "Default to IO::out_dt"<em>OR</em></td>
</tr>
<tr>
<td>outHeader_every</td>
<td>20</td>
<td>How often to print the header</td>
<td>1:* :: "Output every so many time steps" <em>OR</em> -1   :: "No header output"<em>OR</em></td>
</tr>
<tr>
<td>iter_width</td>
<td>9</td>
<td>Field width for the current iteration</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>time_width</td>
<td>9</td>
<td>Field width for the simulation time</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>time_prec</td>
<td>3</td>
<td>Precision for the simulation time</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>int_width</td>
<td>9</td>
<td>Field width for integer values</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>real_width</td>
<td>12</td>
<td>Field width for real values</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>real_prec</td>
<td>7</td>
<td>Precision for real values</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>real_prec_sci</td>
<td>6</td>
<td>Precision for real values in scientific notation</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>real_min</td>
<td>1.0e-8</td>
<td>Lower bound for numbers that are displayed in fixed notation</td>
<td>(0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>real_max</td>
<td>1.0e+3</td>
<td>Upper bound for numbers that are displayed in fixed notation</td>
<td>(0.0:* :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="loopcontrol">LoopControl</h3>
<p>Cactus Code Thorn LoopControl
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Iterate over multi-dimensional arrays in an efficient manner, using
OpenMP (if available) and cache-aware loop tiling.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Output some loop information at run time</td>
<td></td>
</tr>
<tr>
<td>veryverbose</td>
<td>"no"</td>
<td>Output detailed debug information at run time</td>
<td></td>
</tr>
<tr>
<td>selftest</td>
<td>"no"</td>
<td>Run a self test with every loop (expensive)</td>
<td></td>
</tr>
<tr>
<td>statistics_filename</td>
<td>"LoopControl-statistics"</td>
<td>File name for LoopControl statistics</td>
<td>""   :: "disable statistics output"<em>OR</em>  ".+" :: "file name"<em>OR</em></td>
</tr>
<tr>
<td>statistics_every_seconds</td>
<td>-1.0</td>
<td>Output statistics every so many seconds</td>
<td>-1.0  :: "don't output"<em>OR</em>  0.0:* :: "output every so many seconds"<em>OR</em></td>
</tr>
<tr>
<td>initial_setup</td>
<td>"tiled"</td>
<td>Initial configuration</td>
<td>"legacy" :: "Like a non-LoopControl loop"<em>OR</em>  "tiled"  :: "Basic LoopControl setup"<em>OR</em></td>
</tr>
<tr>
<td>explore_eagerly_before_iteration</td>
<td>0</td>
<td>Try to explore the parameter space as much as possible before this iteration</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>settle_after_iteration</td>
<td>0</td>
<td>Do not explore the parameter space any more at or after this iteration</td>
<td>-1  :: "always continue exploring"<em>OR</em>  0:* :: ""<em>OR</em># Setting settle_after_iteration=0 apparently avoids an inefficiency,<em>OR</em># so make it the default for the time being.<em>OR</em></td>
</tr>
<tr>
<td>use_smt_threads</td>
<td>"yes"</td>
<td>Place SMT threads close together</td>
<td></td>
</tr>
<tr>
<td>align_with_cachelines</td>
<td>"yes"</td>
<td>Align innermost loops with cache line size</td>
<td></td>
</tr>
<tr>
<td>tilesize_i</td>
<td>4</td>
<td>Tile size in i direction (in grid points) for loop tiling</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>tilesize_j</td>
<td>4</td>
<td>Tile size in j direction (in grid points) for loop tiling</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>tilesize_k</td>
<td>4</td>
<td>Tile size in k direction (in grid points) for loop tiling</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>loopsize_i</td>
<td>8</td>
<td>Size of each thread's loop in i direction (in grid points) for multithreading</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>loopsize_j</td>
<td>8</td>
<td>Size of each thread's loop in j direction (in grid points) for multithreading</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>loopsize_k</td>
<td>8</td>
<td>Size of each thread's loop in k direction (in grid points) for multithreading</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>max_size_factor</td>
<td>4</td>
<td>Maximum size for modifying loop sizes</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>very_expensive_factor</td>
<td>1.5</td>
<td>Params worse than the current-best by more than this factor are ignored more quickly</td>
<td>1.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>tryout_iterations</td>
<td>1</td>
<td>Try out new params for this many iterations before judging them</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>random_jump_probability</td>
<td>0.1</td>
<td>Probability of a random jump to begin exploring a very different param</td>
<td>0.0:1.0 :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="carpetregrid">CarpetRegrid</h3>
<p>Cactus Code Thorn CarpetRegrid
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn handles regridding for Carpet.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Print screen output while running</td>
<td></td>
</tr>
<tr>
<td>veryverbose</td>
<td>"no"</td>
<td>Print much screen output while running</td>
<td></td>
</tr>
<tr>
<td>refinement_levels</td>
<td>1</td>
<td>Number of refinement levels (including the base level)</td>
<td>1:* :: "must be positive, and must not be larger than Carpet::max_refinement_levels"<em>OR</em></td>
</tr>
<tr>
<td>regrid_every</td>
<td>0</td>
<td>Regrid every n time steps</td>
<td>-1   :: "regrid never"<em>OR</em>   0   :: "regrid during initial data calculation only"<em>OR</em>   1:* :: "regrid every n time steps"<em>OR</em></td>
</tr>
<tr>
<td>activate_levels_on_regrid</td>
<td>"none"</td>
<td>Whether to activate or deactivate new levels on regridding</td>
<td>"none"     :: "Do not activate or deactivate any levels"<em>OR</em>  "fixed"    :: "Activate or deactivate a fixed number of levels"<em>OR</em>  "function" :: "Activate or deactivate a variable number of levels, determined by a user-specified function.  When this option is used, the parameters num_new_levels and activate_next have no effect and should not be set."<em>OR</em></td>
</tr>
<tr>
<td>num_new_levels</td>
<td>0</td>
<td>When regridding, activate this many new levels (if possible).  Note that this will steer the parameter refinement_levels.</td>
<td>: :: "Number of new levels to activate (negative numbers deactivate)"<em>OR</em></td>
</tr>
<tr>
<td>activate_next</td>
<td>1</td>
<td>The next iteration at which new levels should be activated</td>
<td>0: :: "Note that this parameter is steered when new levels are activated"<em>OR</em></td>
</tr>
<tr>
<td>keep_same_grid_structure</td>
<td>"no"</td>
<td>Do not allow the grid structure to change; only allow levels to be switched on or off</td>
<td></td>
</tr>
<tr>
<td>refined_regions</td>
<td>"centre"</td>
<td>Regions where the grid is refined</td>
<td>"none"                   :: "Don't refine"<em>OR</em>  "centre"                 :: "Refine around the centre of the grid only"<em>OR</em>  "manual-gridpoints"      :: "Refine the regions specified by integer grid points l[123]i[xyz]{min,max}"<em>OR</em>  "manual-coordinates"     :: "Refine the regions specified by coordinates l[123][xyz]{min,max}"<em>OR</em>  "manual-gridpoint-list"  :: "Refine the regions specified by integer grid points in the parameter 'gridpoints'"<em>OR</em>  "manual-coordinate-list" :: "Refine the regions specified by coordinates in the parameter 'coordinates'"<em>OR</em>  "moving"                 :: "Refine a moving region"<em>OR</em>  "automatic"              :: "Refine automatically"<em>OR</em></td>
</tr>
<tr>
<td>smart_outer_boundaries</td>
<td>no</td>
<td>Use the CoordBase interface for outer boundaries</td>
<td></td>
</tr>
<tr>
<td>merge_overlapping_components</td>
<td>no</td>
<td>Merge overlapping components</td>
<td></td>
</tr>
<tr>
<td>tracking</td>
<td>no</td>
<td>Enable tracking</td>
<td></td>
</tr>
<tr>
<td>symmetry_x</td>
<td>"no"</td>
<td>Refine the lower half in x-direction</td>
<td></td>
</tr>
<tr>
<td>symmetry_y</td>
<td>"no"</td>
<td>Refine the lower half in y-direction</td>
<td></td>
</tr>
<tr>
<td>symmetry_z</td>
<td>"no"</td>
<td>Refine the lower half in z-direction</td>
<td></td>
</tr>
<tr>
<td>moving_trajectory</td>
<td>"point"</td>
<td>Type of trajectory</td>
<td>"point"  :: "Do not move"<em>OR</em>  "circle" :: "Move in a circle"<em>OR</em></td>
</tr>
<tr>
<td>moving_region_radius</td>
<td>1.0</td>
<td>Radius of the moving region (on the first refined level)</td>
<td>(0: :: ""<em>OR</em></td>
</tr>
<tr>
<td>moving_centre_x</td>
<td>0.0</td>
<td>x-coordinate of the centre</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>moving_centre_y</td>
<td>0.0</td>
<td>y-coordinate of the centre</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>moving_centre_z</td>
<td>0.0</td>
<td>z-coordinate of the centre</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>moving_circle_radius</td>
<td>1.0</td>
<td>Radius of the circle</td>
<td>0: :: ""<em>OR</em></td>
</tr>
<tr>
<td>moving_circle_frequency</td>
<td>1.0</td>
<td>Angular frequency on the circle</td>
<td>0: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l1ixmin</td>
<td>0</td>
<td>Lower boundary of level 1 box in x-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l1iymin</td>
<td>0</td>
<td>Lower boundary of level 1 box in y-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l1izmin</td>
<td>0</td>
<td>Lower boundary of level 1 box in z-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l1ixmax</td>
<td>-1</td>
<td>Upper boundary of level 1 box in x-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l1iymax</td>
<td>-1</td>
<td>Upper boundary of level 1 box in y-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l1izmax</td>
<td>-1</td>
<td>Upper boundary of level 1 box in z-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l2ixmin</td>
<td>0</td>
<td>Lower boundary of level 2 box in x-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l2iymin</td>
<td>0</td>
<td>Lower boundary of level 2 box in y-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l2izmin</td>
<td>0</td>
<td>Lower boundary of level 2 box in z-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l2ixmax</td>
<td>-1</td>
<td>Upper boundary of level 2 box in x-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l2iymax</td>
<td>-1</td>
<td>Upper boundary of level 2 box in y-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l2izmax</td>
<td>-1</td>
<td>Upper boundary of level 2 box in z-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l3ixmin</td>
<td>0</td>
<td>Lower boundary of level 3 box in x-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l3iymin</td>
<td>0</td>
<td>Lower boundary of level 3 box in y-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l3izmin</td>
<td>0</td>
<td>Lower boundary of level 3 box in z-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l3ixmax</td>
<td>-1</td>
<td>Upper boundary of level 3 box in x-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l3iymax</td>
<td>-1</td>
<td>Upper boundary of level 3 box in y-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l3izmax</td>
<td>-1</td>
<td>Upper boundary of level 3 box in z-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l1xmin</td>
<td>0</td>
<td>Lower boundary of level 1 box in x-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l1ymin</td>
<td>0</td>
<td>Lower boundary of level 1 box in y-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l1zmin</td>
<td>0</td>
<td>Lower boundary of level 1 box in z-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l1xmax</td>
<td>-1</td>
<td>Upper boundary of level 1 box in x-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l1ymax</td>
<td>-1</td>
<td>Upper boundary of level 1 box in y-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l1zmax</td>
<td>-1</td>
<td>Upper boundary of level 1 box in z-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l2xmin</td>
<td>0</td>
<td>Lower boundary of level 2 box in x-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l2ymin</td>
<td>0</td>
<td>Lower boundary of level 2 box in y-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l2zmin</td>
<td>0</td>
<td>Lower boundary of level 2 box in z-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l2xmax</td>
<td>-1</td>
<td>Upper boundary of level 2 box in x-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l2ymax</td>
<td>-1</td>
<td>Upper boundary of level 2 box in y-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l2zmax</td>
<td>-1</td>
<td>Upper boundary of level 2 box in z-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l3xmin</td>
<td>0</td>
<td>Lower boundary of level 3 box in x-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l3ymin</td>
<td>0</td>
<td>Lower boundary of level 3 box in y-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l3zmin</td>
<td>0</td>
<td>Lower boundary of level 3 box in z-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l3xmax</td>
<td>-1</td>
<td>Upper boundary of level 3 box in x-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l3ymax</td>
<td>-1</td>
<td>Upper boundary of level 3 box in y-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>l3zmax</td>
<td>-1</td>
<td>Upper boundary of level 3 box in z-direction</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>gridpoints</td>
<td>""</td>
<td>List of bounding box gridpoints</td>
<td># We want the string to contain a list of bboxes.  Each bbox contains*OR*# three vectors specifying the lower bound, upper bound, and stride.<em>OR</em># (The upper bound is inclusive.  All values are nonnegative integers.)<em>OR</em># The syntax for vectors, bboxes, and lists is described below.<em>OR</em># All spaces are optional.<em>OR**OR</em># Almost human readable explanation follows.<em>OR</em># The specification is hierarchical.<em>OR**OR</em># The following definitions are generic:<em>OR</em># VECT2(x) := "[ x, x ]"<em>OR</em>#    two x, separated by commas, enclosed in square brackets*OR*# VECT3(x) := "[ x, x, x ]"<em>OR</em>#    three x, separated by commas, enclosed in square brackets*OR*# LIST(x) := "[ {{ x, }* x}? ]"<em>OR</em>#    zero or more x, separated by commas, enclosed in square brackets*OR**OR*# A domain is built up as follows:<em>OR</em># REGION   := VECT3(VECT2(double))<em>OR</em># REFLEVEL := LIST(REGION)<em>OR</em># DOMAIN   := LIST(REFLEVEL)<em>OR**OR</em>  "^$" :: "leave empty for no refinement"<em>OR</em>  ".<em>" :: "[ [ ([<imin>,<jmin>,<kmin>]:[<imax>,<jmax>,<kmax>]:[<istride>,<jstride>,<kstride>]), ... ], ... ]"*OR</em></td>
</tr>
<tr>
<td>coordinates</td>
<td>""</td>
<td>List of bounding box coordinates</td>
<td># We want the string to contain a list of bboxes.  Each bbox contains*OR*# three vectors specifying the lower bound, upper bound, and stride.<em>OR</em># (The upper bound is inclusive.  All values are nonnegative integers.)<em>OR</em># The syntax for vectors, bboxes, and lists is described below.<em>OR</em># All spaces are optional.<em>OR**OR</em># Almost human readable explanation follows.<em>OR</em># The specification is hierarchical.<em>OR**OR</em># The following definitions are generic:<em>OR</em># VECT2(x) := "[ x, x ]"<em>OR</em>#    two x, separated by commas, enclosed in square brackets*OR*# VECT3(x) := "[ x, x, x ]"<em>OR</em>#    three x, separated by commas, enclosed in square brackets*OR*# LIST(x) := "[ {{ x, }* x}? ]"<em>OR</em>#    zero or more x, separated by commas, enclosed in square brackets*OR**OR*# A domain is built up as follows:<em>OR</em># REGION   := VECT3(VECT2(double))<em>OR</em># REFLEVEL := LIST(REGION)<em>OR</em># DOMAIN   := LIST(REFLEVEL)<em>OR**OR</em>  "^$" :: "leave empty for no refinement"<em>OR</em>  ".<em>" :: "[ [ ([<xmin>,<ymin>,<zmin>]:[<xmax>,<ymax>,<zmax>]:[<xstride>,<ystride>,<zstride>]), ... ], ... ]"*OR</em></td>
</tr>
<tr>
<td>num_offsets</td>
<td>0</td>
<td>Number of given offsets</td>
<td>0:10 :: ""<em>OR</em></td>
</tr>
<tr>
<td>offset_firstlevel</td>
<td>1</td>
<td>First (lowest) refinement level that should have an offset applied</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>outerbounds</td>
<td>""</td>
<td>Outer boundaries</td>
<td>"^$" :: "leave empty for no outer boundaries"<em>OR**OR</em># Each vector element is 0 or 1,<em>OR</em># where 0 is handled by synchronisation or prolongation,<em>OR</em># and 1 stands for a user-supplied ("outer") boundary condition.<em>OR**OR</em># BND := " [ 0 , 0 ]"<em>OR</em># VECT := " [ BND , BND , BND ]"<em>OR</em># LIST := " [{{VECT ,}<em>VECT}? ]"*OR**OR</em># Almost human readable explanation follows.<em>OR</em># The specification is hierarchical.<em>OR**OR</em># The following definitions are generic:<em>OR</em># VECT2(x) := "[ x, x ]"<em>OR</em>#    two x, separated by commas, enclosed in square brackets*OR*# VECT3(x) := "[ x, x, x ]"<em>OR</em>#    three x, separated by commas, enclosed in square brackets*OR*# LIST(x) := "[ {{ x, }* x}? ]"<em>OR</em>#    zero or more x, separated by commas, enclosed in square brackets*OR**OR*# A domain is built up as follows:<em>OR</em># REGION   := VECT3(VECT2(double))<em>OR</em># REFLEVEL := LIST(REGION)<em>OR</em># DOMAIN   := LIST(REFLEVEL)<em>OR**OR</em>  ".<em>" :: "[ [ [[?,?],[?,?],[?,?]], ... ], ...]"*OR</em></td>
</tr>
<tr>
<td>minwidth</td>
<td>8</td>
<td>Minimum width of refined region</td>
<td>1:* :: "must be positive"<em>OR</em></td>
</tr>
<tr>
<td>minfraction</td>
<td>0.75</td>
<td>Minimum fraction of points in need of refinement in a refined region</td>
<td>0:1 :: "must be positive and less than one"<em>OR</em></td>
</tr>
<tr>
<td>maxerror</td>
<td>1.0</td>
<td>Maximum allowed error for non-refined grid points</td>
<td><em>:</em> :: "everything goes"<em>OR</em></td>
</tr>
<tr>
<td>errorvar</td>
<td>""</td>
<td>Name of grid function that contains the error</td>
<td>".<em>" :: "must be the name of a grid function"*OR</em></td>
</tr>
</tbody>
</table>
<h3 id="testloopcontrol">TestLoopControl</h3>
<p>Cactus Code Thorn TestLoopControl
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>not documented</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="carpetinterp2">CarpetInterp2</h3>
<p>Cactus Code Thorn CarpetInterp2
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides a parallel interpolator for Carpet.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Produce info output</td>
<td></td>
</tr>
<tr>
<td>veryverbose</td>
<td>"no"</td>
<td>Produce debugging output</td>
<td></td>
</tr>
<tr>
<td>interp_barrier</td>
<td>"no"</td>
<td>Wait for all processes before and after interpolating</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="timers">Timers</h3>
<p>Cactus Code Thorn Timers
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
Licence      : n/a</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Provide various kinds of timers:</p>
<p>CactusTimer:    C++ wrapper around standard Cactus timers
CactusTimerSet: knows about all CactusTimers that were ever created
Timer:          hierarchical set of CactusTimers
TimerTree:      helper class for Timer</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Output (debug) messages when a timer is started or stopped</td>
<td></td>
</tr>
<tr>
<td>disable_cactus_timer_set</td>
<td>"no"</td>
<td>Disable Cactus timer set</td>
<td></td>
</tr>
<tr>
<td>disable_timer_trees</td>
<td>"no"</td>
<td>Disable timer trees</td>
<td></td>
</tr>
<tr>
<td>xml_clock</td>
<td>"gettimeofday"</td>
<td>Which clock to use in the XML timer output file</td>
<td>".<em>" :: "must be a legal clock name"*OR</em></td>
</tr>
<tr>
<td>threshold_percentage</td>
<td>1.0</td>
<td>The percentage of the root timer below which timers are omitted</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>output_precision</td>
<td>1</td>
<td>Number of decimal places to use in standard output for timer tree</td>
<td>1:* :: "number of decimal places"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="carpettracker">CarpetTracker</h3>
<p>Cactus Code Thorn CarpetTracker
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Track black holes and update the location of the refinement regions.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>no</td>
<td>Tell what is going on</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="reductiontest3">ReductionTest3</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header:</span><script type="math/tex">Header:</script></span></p>
<p>Cactus Code Thorn ReductionTest
Thorn Author(s)     : Christian D. Ott <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Thorn Maintainer(s) : Christian D. Ott <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="reductiontest2">ReductionTest2</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header:</span><script type="math/tex">Header:</script></span></p>
<p>Cactus Code Thorn ReductionTest
Thorn Author(s)     : Christian D. Ott <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Thorn Maintainer(s) : Christian D. Ott <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="carpet_1">Carpet</h3>
<p>This thorn provides a parallel AMR (adaptive mesh refinement) driver
with MPI.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>domain_from_coordbase</td>
<td>"no"</td>
<td>Use the domain description from CoordBase</td>
<td></td>
</tr>
<tr>
<td>domain_from_multipatch</td>
<td>"no"</td>
<td>Use the domain description from MultiPatch</td>
<td></td>
</tr>
<tr>
<td>global_nx</td>
<td>10</td>
<td>Grid size in x direction</td>
<td>0:* :: "must be nonnegative"<em>OR</em></td>
</tr>
<tr>
<td>global_ny</td>
<td>10</td>
<td>Grid size in y direction</td>
<td>0:* :: "must be nonnegative"<em>OR</em></td>
</tr>
<tr>
<td>global_nz</td>
<td>10</td>
<td>Grid size in z direction</td>
<td>0:* :: "must be nonnegative"<em>OR</em></td>
</tr>
<tr>
<td>global_nsize</td>
<td>-1</td>
<td>Grid size in each spatial direction</td>
<td>0:* :: "must be nonnegative"<em>OR</em>  -1  :: "use the per-dimension parameters"<em>OR</em></td>
</tr>
<tr>
<td>ghost_size_x</td>
<td>1</td>
<td>Ghost zones in x direction</td>
<td>0:* :: "must be nonnegative"<em>OR</em></td>
</tr>
<tr>
<td>ghost_size_y</td>
<td>1</td>
<td>Ghost zones in y direction</td>
<td>0:* :: "must be nonnegative"<em>OR</em></td>
</tr>
<tr>
<td>ghost_size_z</td>
<td>1</td>
<td>Ghost zones in z direction</td>
<td>0:* :: "must be nonnegative"<em>OR</em></td>
</tr>
<tr>
<td>ghost_size</td>
<td>-1</td>
<td>Ghost zones in each spatial direction</td>
<td>0:* :: "must be nonnegative"<em>OR</em>  -1  :: "use the per-dimension parameters"<em>OR</em></td>
</tr>
<tr>
<td>ghost_sizes</td>
<td>""</td>
<td>Number of ghost zones for each refinement level</td>
<td>"^<span><span class="MathJax_Preview">" :: "Use the value of ghost_size or ghost_size_[xyz]"*OR*  "^[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*(,[[:space:]]*[[:digit:]]+[[:space:]]*)*\][[:space:]]*</span><script type="math/tex">" :: "Use the value of ghost_size or ghost_size_[xyz]"*OR*  "^[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*(,[[:space:]]*[[:digit:]]+[[:space:]]*)*\][[:space:]]*</script></span>" :: "[ <ghost_size>, ... ]"<em>OR</em></td>
</tr>
<tr>
<td>periodic</td>
<td>"no"</td>
<td>do not use this parameter</td>
<td></td>
</tr>
<tr>
<td>periodic_x</td>
<td>"yes"</td>
<td>do not use this parameter</td>
<td></td>
</tr>
<tr>
<td>periodic_y</td>
<td>"yes"</td>
<td>do not use this parameter</td>
<td></td>
</tr>
<tr>
<td>periodic_z</td>
<td>"yes"</td>
<td>do not use this parameter</td>
<td></td>
</tr>
<tr>
<td>refinement_centering</td>
<td>"vertex"</td>
<td>Centering</td>
<td>"vertex" :: "use a vertex centred grid structure"<em>OR</em>  "cell"   :: "use a cell centred grid structure"<em>OR</em></td>
</tr>
<tr>
<td>eno_interpolation_type</td>
<td>"samples"</td>
<td>What is represented by values in cells DEPRECATED</td>
<td>"samples"  :: "grid values a sample values of the solution"<em>OR</em></td>
</tr>
<tr>
<td>max_refinement_levels</td>
<td>1</td>
<td>Maximum number of refinement levels (including the base level)</td>
<td>1:* :: "must be positive"<em>OR</em></td>
</tr>
<tr>
<td>max_timelevels</td>
<td>-1</td>
<td>Maximum number of time levels (including the current time level)</td>
<td>-1 :: "Set automatically to prolonation_order_time+1"<em>OR</em>  1:* :: "Set this explicitly"<em>OR</em></td>
</tr>
<tr>
<td>refinement_factor</td>
<td>2</td>
<td>Refinement factor</td>
<td>1:* :: "must be positive"<em>OR</em></td>
</tr>
<tr>
<td>space_refinement_factors</td>
<td>""</td>
<td>Spatial refinement factors over the coarsest level</td>
<td>"^<span><span class="MathJax_Preview">" :: "Use the value of refinement_factor"*OR*  # V = [SDS(,SDS)*]*OR*  # L = [SVS(,SVS)*]*OR*  #   = [S[SDS(,SDS)*]S(,S[SDS(,SDS)*]S)*]*OR*  "^[[:space:]]*\[[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*(,[[:space:]]*[[:digit:]]+[[:space:]]*)*\][[:space:]]*(,[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*(,[[:space:]]*[[:digit:]]+[[:space:]]*)*\][[:space:]]*)*\][[:space:]]*</span><script type="math/tex">" :: "Use the value of refinement_factor"*OR*  # V = [SDS(,SDS)*]*OR*  # L = [SVS(,SVS)*]*OR*  #   = [S[SDS(,SDS)*]S(,S[SDS(,SDS)*]S)*]*OR*  "^[[:space:]]*\[[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*(,[[:space:]]*[[:digit:]]+[[:space:]]*)*\][[:space:]]*(,[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*(,[[:space:]]*[[:digit:]]+[[:space:]]*)*\][[:space:]]*)*\][[:space:]]*</script></span>" :: "[ [<ifact>,<jfact>,<kfact>], ... ]"<em>OR</em></td>
</tr>
<tr>
<td>time_refinement_factors</td>
<td>""</td>
<td>Temporal refinement factors over the coarsest level</td>
<td>"^<span><span class="MathJax_Preview">" :: "Use the value of refinement_factor"*OR*  # L = [SDS(,SDS)*]*OR*  "^[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*(,[[:space:]]*[[:digit:]]+[[:space:]]*)*\][[:space:]]*</span><script type="math/tex">" :: "Use the value of refinement_factor"*OR*  # L = [SDS(,SDS)*]*OR*  "^[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*(,[[:space:]]*[[:digit:]]+[[:space:]]*)*\][[:space:]]*</script></span>" :: "[ <tfact>, ... ]"<em>OR</em></td>
</tr>
<tr>
<td>refine_timestep</td>
<td>"no"</td>
<td>Correct Time::dtfac for spacings on finer grids</td>
<td></td>
</tr>
<tr>
<td>convergence_level</td>
<td>0</td>
<td>Convergence level</td>
<td><em>:</em> :: "negative for finer, positive for coarser resolutions"<em>OR</em></td>
</tr>
<tr>
<td>num_convergence_levels</td>
<td>1</td>
<td>Number of convergence levels (including the base level)</td>
<td>1:* :: "must be positive"<em>OR</em></td>
</tr>
<tr>
<td>convergence_factor</td>
<td>2</td>
<td>Multigrid factor</td>
<td>1:* :: "must be positive"<em>OR</em></td>
</tr>
<tr>
<td>num_maps</td>
<td>1</td>
<td>Number of maps</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>model</td>
<td>"world"</td>
<td>Model name for multi-model simulations -- the model name is used to distribute the processors onto the models</td>
<td>".+" :: ""<em>OR</em></td>
</tr>
<tr>
<td>prolongation_order_space</td>
<td>1</td>
<td>Order of prolongation operator in space</td>
<td>0:* :: "vertex centred orders must be odd"<em>OR</em></td>
</tr>
<tr>
<td>prolongation_orders_space</td>
<td>""</td>
<td>Order of prolongation operator in space for each refinement level</td>
<td>"^<span><span class="MathJax_Preview">" :: "Use the value of prolongation_order_space"*OR*  "^[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*(,[[:space:]]*[[:digit:]]+[[:space:]]*)*\][[:space:]]*</span><script type="math/tex">" :: "Use the value of prolongation_order_space"*OR*  "^[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*(,[[:space:]]*[[:digit:]]+[[:space:]]*)*\][[:space:]]*</script></span>" :: "[ <order>, ... ]"<em>OR</em></td>
</tr>
<tr>
<td>prolongation_order_time</td>
<td>1</td>
<td>Order of prolongation operator in time</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>use_buffer_zones</td>
<td>"no"</td>
<td>Use buffer zones</td>
<td></td>
</tr>
<tr>
<td>additional_buffer_zones</td>
<td>0</td>
<td>Additional buffer zones</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>use_overlap_zones</td>
<td>"no"</td>
<td>Use overlap zones</td>
<td></td>
</tr>
<tr>
<td>additional_overlap_zones</td>
<td>0</td>
<td>Additional overlap zones</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>use_tapered_grids</td>
<td>"no"</td>
<td>Use tapered grids, avoiding time interpolation during evolution</td>
<td></td>
</tr>
<tr>
<td>num_integrator_substeps</td>
<td>-1</td>
<td>Number of substeps of the time integrator</td>
<td>-1: :: "Call MoLNumIntegratorSubsteps"<em>OR</em>  0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>sync_during_time_integration</td>
<td>"yes"</td>
<td>Synchronise during time integration, even when prolongation is switched off</td>
<td></td>
</tr>
<tr>
<td>base_extents</td>
<td>braces</td>
<td>Extents of base grid components, in grid point units of the finest level</td>
<td>"^$" :: "leave empty for one grid component covering the whole region (default)"<em>OR**OR</em># We want the string to contain a list of bboxes.  Each bbox contains*OR*# three vectors specifying the lower bound, upper bound, and stride.<em>OR</em># (The upper bound is inclusive.  All values are nonnegative integers.)<em>OR</em># The syntax for vectors, bboxes, and lists is described below.<em>OR</em># All spaces are optional.<em>OR**OR</em># The () parentheses and [] brackets are literals.<em>OR</em># The {</td>
</tr>
<tr>
<td>base_outerbounds</td>
<td>""</td>
<td>Outer boundaries of base grid components</td>
<td>"^<span><span class="MathJax_Preview">" :: "leave empty for using the default, which depends on cctk_gsh"*OR**OR*# See above for an explanation of this syntax, and of the tapeworm below.*OR*# Each vector element is 0 or 1,*OR*# where 0 is handled by synchronisation or prolongation,*OR*# and 1 stands for a user-supplied ("outer") boundary condition.*OR**OR*# BND := " [ 0 , 0 ]"*OR*# VECT := " [ BND , BND , BND ]"*OR*# LIST := " [{{VECT ,}*VECT}? ]"*OR**OR*# Almost human readable explanation follows.*OR*# The specification is hierarchical.*OR**OR*# The following definitions are generic:*OR*# VECT2(x) := "[ x, x ]"*OR*#    two x, separated by commas, enclosed in square brackets*OR*# VECT3(x) := "[ x, x, x ]"*OR*#    three x, separated by commas, enclosed in square brackets*OR*# LIST(x) := "[ {{ x, }* x}? ]"*OR*#    zero or more x, separated by commas, enclosed in square brackets*OR**OR*# A domain is built up as follows:*OR*# REGION   := VECT3(VECT2(double))*OR*# DOMAIN   := LIST(REGION)*OR**OR*  "^[[:space:]]*\[(([[:space:]]*\[[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*,[[:space:]]*[[:digit:]]+[[:space:]]*\][[:space:]]*,[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*,[[:space:]]*[[:digit:]]+[[:space:]]*\][[:space:]]*,[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*,[[:space:]]*[[:digit:]]+[[:space:]]*\][[:space:]]*\][[:space:]]*,)*[[:space:]]*\[[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*,[[:space:]]*[[:digit:]]+[[:space:]]*\][[:space:]]*,[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*,[[:space:]]*[[:digit:]]+[[:space:]]*\][[:space:]]*,[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*,[[:space:]]*[[:digit:]]+[[:space:]]*\][[:space:]]*\])?[[:space:]]*\][[:space:]]*</span><script type="math/tex">" :: "leave empty for using the default, which depends on cctk_gsh"*OR**OR*# See above for an explanation of this syntax, and of the tapeworm below.*OR*# Each vector element is 0 or 1,*OR*# where 0 is handled by synchronisation or prolongation,*OR*# and 1 stands for a user-supplied ("outer") boundary condition.*OR**OR*# BND := " [ 0 , 0 ]"*OR*# VECT := " [ BND , BND , BND ]"*OR*# LIST := " [{{VECT ,}*VECT}? ]"*OR**OR*# Almost human readable explanation follows.*OR*# The specification is hierarchical.*OR**OR*# The following definitions are generic:*OR*# VECT2(x) := "[ x, x ]"*OR*#    two x, separated by commas, enclosed in square brackets*OR*# VECT3(x) := "[ x, x, x ]"*OR*#    three x, separated by commas, enclosed in square brackets*OR*# LIST(x) := "[ {{ x, }* x}? ]"*OR*#    zero or more x, separated by commas, enclosed in square brackets*OR**OR*# A domain is built up as follows:*OR*# REGION   := VECT3(VECT2(double))*OR*# DOMAIN   := LIST(REGION)*OR**OR*  "^[[:space:]]*\[(([[:space:]]*\[[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*,[[:space:]]*[[:digit:]]+[[:space:]]*\][[:space:]]*,[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*,[[:space:]]*[[:digit:]]+[[:space:]]*\][[:space:]]*,[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*,[[:space:]]*[[:digit:]]+[[:space:]]*\][[:space:]]*\][[:space:]]*,)*[[:space:]]*\[[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*,[[:space:]]*[[:digit:]]+[[:space:]]*\][[:space:]]*,[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*,[[:space:]]*[[:digit:]]+[[:space:]]*\][[:space:]]*,[[:space:]]*\[[[:space:]]*[[:digit:]]+[[:space:]]*,[[:space:]]*[[:digit:]]+[[:space:]]*\][[:space:]]*\])?[[:space:]]*\][[:space:]]*</script></span>" :: "[ [ [<ilower>,<iupper>], [<jlower>,<jupper>], [<klower>,<kupper>] ], ... ]"<em>OR</em></td>
</tr>
<tr>
<td>enable_all_storage</td>
<td>"no"</td>
<td>Enable storage for all grid functions</td>
<td></td>
</tr>
<tr>
<td>enable_no_storage</td>
<td>"no"</td>
<td>Exit before beginning to enable storage for grid functions</td>
<td></td>
</tr>
<tr>
<td>poison_new_timelevels</td>
<td>"yes"</td>
<td>Try to catch uninitialised grid elements by setting new timelevels to values that will catch your attention</td>
<td></td>
</tr>
<tr>
<td>check_for_poison</td>
<td>"no"</td>
<td>Explicitely check for the poison value after every time step</td>
<td></td>
</tr>
<tr>
<td>poison_value</td>
<td>0</td>
<td>UNUSED; use CarpetLib::poison_value instead</td>
<td>* :: ""<em>OR</em></td>
</tr>
<tr>
<td>max_poison_locations</td>
<td>10</td>
<td>Maximum number of poison locations that are printed to the screen</td>
<td>-1  :: "print all locations"<em>OR</em>  0:* :: "print only that many locations"<em>OR</em></td>
</tr>
<tr>
<td>checksum_timelevels</td>
<td>"no"</td>
<td>Try to catch unintentionally changed timelevels by taking checksums and comparing against these</td>
<td></td>
</tr>
<tr>
<td>suppress_restriction</td>
<td>"no"</td>
<td>Suppress the restriction operations.  This makes the coarser refinement levels independent of the finer ones.</td>
<td></td>
</tr>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Display more info on the screen</td>
<td></td>
</tr>
<tr>
<td>veryverbose</td>
<td>"no"</td>
<td>Display a lot of info on the screen</td>
<td></td>
</tr>
<tr>
<td>storage_verbose</td>
<td>"no"</td>
<td>Display verbose storage information if veryverbose</td>
<td></td>
</tr>
<tr>
<td>barriers</td>
<td>"no"</td>
<td>Insert barriers at strategic places for debugging purposes (slows down execution)</td>
<td></td>
</tr>
<tr>
<td>schedule_barriers</td>
<td>"no"</td>
<td>Insert barriers between scheduled items, so that timer statistics become more reliable (slows down execution)</td>
<td></td>
</tr>
<tr>
<td>sync_barriers</td>
<td>"no"</td>
<td>Insert barriers before and after syncs, so that the sync timer is more reliable (slows down execution)</td>
<td></td>
</tr>
<tr>
<td>output_internal_data</td>
<td>"no"</td>
<td>Periodically print internal data to the screen for debugging purposes</td>
<td></td>
</tr>
<tr>
<td>timing_average_window_minutes</td>
<td>10.0</td>
<td>Time interval (in wall time minutes) for calculating the current physics time per hour</td>
<td>(0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>print_timestats_every</td>
<td>0</td>
<td>Print interesting timing statistics periodically</td>
<td>-1  :: "don't report"<em>OR</em>  0   :: "don't report"<em>OR</em>  1:* :: "report every so many iterations"<em>OR</em></td>
</tr>
<tr>
<td>print_grid_info</td>
<td>yes</td>
<td>Print information about the grids on regridding</td>
<td></td>
</tr>
<tr>
<td>output_timers_every</td>
<td>0</td>
<td>Print detailed statistics periodically</td>
<td>-1  :: "don't report"<em>OR</em>  0   :: "don't report"<em>OR</em>  1:* :: "report every so many iterations"<em>OR</em></td>
</tr>
<tr>
<td>timer_file</td>
<td>"carpet-timing-statistics"</td>
<td>File name in which detailed timing statistics are collected</td>
<td>"^<span><span class="MathJax_Preview">"   :: "empty filename: no file output"*OR*  "^.+</span><script type="math/tex">"   :: "empty filename: no file output"*OR*  "^.+</script></span>" :: "file name"<em>OR</em></td>
</tr>
<tr>
<td>output_initialise_timer_tree</td>
<td>"no"</td>
<td>Output timing information in tree form to standard output for Initialise</td>
<td></td>
</tr>
<tr>
<td>output_timer_tree_every</td>
<td>0</td>
<td>Output timing information in tree form to standard output for Evolve every so many iterations</td>
<td>0   :: "don't report"<em>OR</em>  1:* :: "report every so many iterations"<em>OR</em></td>
</tr>
<tr>
<td>output_xml_timer_tree</td>
<td>"no"</td>
<td>Output timing information in tree form as XML</td>
<td></td>
</tr>
<tr>
<td>recompose_verbose</td>
<td>"no"</td>
<td>Output debug information during recomposing</td>
<td></td>
</tr>
<tr>
<td>processor_topology</td>
<td>"automatic"</td>
<td>How to determine the processor topology</td>
<td>"manual"    :: "Specified by processor_topology_<em>"*OR</em>  "along-z"   :: "Split the region along the z direction only"<em>OR</em>  "along-dir" :: "Split the region along one direction only"<em>OR</em>  "automatic" :: "Choose the topology automatically"<em>OR</em>  "recursive" :: "Choose the topology automatically, using a different algorithm that may lead to better load balancing"<em>OR</em>  "balanced"  :: "Choose the topology automatically, ensuring a maximum load balance"<em>OR</em></td>
</tr>
<tr>
<td>processor_topology_3d_x</td>
<td>1</td>
<td>Number of processors in x-direction</td>
<td>1:* :: "must be positive"<em>OR</em></td>
</tr>
<tr>
<td>processor_topology_3d_y</td>
<td>1</td>
<td>Number of processors in y-direction</td>
<td>1:* :: "must be positive"<em>OR</em></td>
</tr>
<tr>
<td>processor_topology_3d_z</td>
<td>1</td>
<td>Number of processors in z-direction</td>
<td>1:* :: "must be positive"<em>OR</em></td>
</tr>
<tr>
<td>split_direction</td>
<td>2</td>
<td>Direction in which the domain should be split (for processor_topology=along-dir)</td>
<td>0:* :: "0 for x, 1 for y, 2 for z, etc."<em>OR</em></td>
</tr>
<tr>
<td>no_split_direction</td>
<td>-1</td>
<td>Direction in which the domain must not be split (for processor_topology=automatic)</td>
<td>-1  :: "split in all directions"<em>OR</em>  0:* :: "0 for x, 1 for y, 2 for z, etc."<em>OR</em></td>
</tr>
<tr>
<td>constant_load_per_processor</td>
<td>"no"</td>
<td>Keep the load per processor constant -- this is meant for benchmarks</td>
<td></td>
</tr>
<tr>
<td>aspect_ratio_x</td>
<td>1.0</td>
<td>Desired aspect ratio for each processor's domain</td>
<td>(0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>aspect_ratio_y</td>
<td>1.0</td>
<td>Desired aspect ratio for each processor's domain</td>
<td>(0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>aspect_ratio_z</td>
<td>1.0</td>
<td>Desired aspect ratio for each processor's domain</td>
<td>(0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>min_points_per_proc</td>
<td>0</td>
<td>Minimum number of grid points per processor</td>
<td>0:* :: "that many"<em>OR</em></td>
</tr>
<tr>
<td>split_components</td>
<td>"yes"</td>
<td>Split components onto processes; without this, one needs many components and few processes</td>
<td></td>
</tr>
<tr>
<td>granularity</td>
<td>1</td>
<td>When splitting components, create sizes that are multiples of this granularity</td>
<td>1:* :: "TODO: query CoordBase or related thorns for this information"<em>OR</em></td>
</tr>
<tr>
<td>granularity_boundary</td>
<td>0</td>
<td>When splitting components, assume this many boundary points that don't count towards the granularity</td>
<td>0:* :: "TODO: use CoordBase's number of boundary points for this"<em>OR</em></td>
</tr>
<tr>
<td>ghost_zone_cost</td>
<td>0.025</td>
<td>Relative cost of ghost zones for 'recursive' load balancing</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>maximum_imbalance</td>
<td>0.1</td>
<td>Maximum load imbalance</td>
<td>(0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>same_number_of_components_on_each_process</td>
<td>"yes"</td>
<td>Ensure that each process has the same number of components, adding empty dummy components if necessary</td>
<td></td>
</tr>
<tr>
<td>num_threads</td>
<td>-1</td>
<td>Number of threads per process</td>
<td>-1  :: "use system default, probably influenced by OMP_NUM_THREADS"<em>OR</em>  1:* :: "use this many threads"<em>OR</em></td>
</tr>
<tr>
<td>set_cpu_affinity</td>
<td>"no"</td>
<td>Set the process CPU affinity, overwriting the respective system setting</td>
<td></td>
</tr>
<tr>
<td>grid_structure_filename</td>
<td>""</td>
<td>File name to output grid structure to (empty = no output)</td>
<td>".<em>" :: "must be a legal file name"*OR</em></td>
</tr>
<tr>
<td>grid_coordinates_filename</td>
<td>""</td>
<td>File name to output grid coordinates to (empty = no output)</td>
<td>".<em>" :: "must be a legal file name"*OR</em></td>
</tr>
<tr>
<td>init_each_timelevel</td>
<td>"no"</td>
<td>Call initial data routines once for each timelevel</td>
<td></td>
</tr>
<tr>
<td>init_fill_timelevels</td>
<td>"no"</td>
<td>Fill past time levels from current time level after calling initial data routines</td>
<td></td>
</tr>
<tr>
<td>prolongate_initial_data</td>
<td>"no"</td>
<td>Prolongate the refined regions during initial data generation</td>
<td></td>
</tr>
<tr>
<td>regrid_during_initialisation</td>
<td>"no"</td>
<td>Regrid while initialising</td>
<td></td>
</tr>
<tr>
<td>regrid_during_recovery</td>
<td>"no"</td>
<td>Regrid while recovering</td>
<td></td>
</tr>
<tr>
<td>regrid_in_level_mode</td>
<td>"yes"</td>
<td>Regrid in level mode (instead of singlemap mode), enabling more efficient processor distributions when there are multiple maps</td>
<td></td>
</tr>
<tr>
<td>time_interpolation_during_regridding</td>
<td>"yes"</td>
<td>Interpolate finer levels in time during regridding</td>
<td></td>
</tr>
<tr>
<td>output_after_regridding</td>
<td>"no"</td>
<td>Call OutputGH after regridding</td>
<td></td>
</tr>
<tr>
<td>init_3_timelevels</td>
<td>"no"</td>
<td>Set up 3 timelevels of initial data</td>
<td></td>
</tr>
<tr>
<td>adaptive_stepsize</td>
<td>"no"</td>
<td>Allow adaptive timestep sizes</td>
<td></td>
</tr>
<tr>
<td>use_unusedpoints_mask</td>
<td>"no"</td>
<td>Turn on storage and usage of 'unusedpoints_mask'</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="carpetslab">CarpetSlab</h3>
<p>Cactus Code Thorn CarpetSlab
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides hyperslabbing for Carpet.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="cycleclock">CycleClock</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>register_clock</td>
<td>"yes"</td>
<td>Register cycle counter as Cactus clock</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="carpetioascii">CarpetIOASCII</h3>
<p>Cactus Code Thorn CarpetIOASCII
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides ASCII output for Carpet.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>one_file_per_group</td>
<td>"no"</td>
<td>Write one file per group instead of per variable</td>
<td></td>
</tr>
<tr>
<td>output_all_timelevels</td>
<td>"no"</td>
<td>Output all timelevels instead of only the current</td>
<td></td>
</tr>
<tr>
<td>separate_grids</td>
<td>"yes"</td>
<td>Separate grid levels in the output file by additional empty lines</td>
<td></td>
</tr>
<tr>
<td>separate_components</td>
<td>"no"</td>
<td>Separate grid components in the output file by additional empty lines</td>
<td></td>
</tr>
<tr>
<td>compact_format</td>
<td>"no"</td>
<td>Use a more compact output format with fewer columns and lines</td>
<td></td>
</tr>
<tr>
<td>use_grid_coordinates</td>
<td>"no"</td>
<td>Use grid coordinate grid functions to obtain coordinate locations</td>
<td></td>
</tr>
<tr>
<td>out_precision</td>
<td>15</td>
<td>How many digits to output floating-point numbers with</td>
<td>0:* :: "Number of precision digits"<em>OR</em></td>
</tr>
<tr>
<td>out0D_dir</td>
<td>""</td>
<td>Name of 0D ASCII output directory, overrides IO::out_dir</td>
<td>"^$" :: "Empty: use IO::out_dir"<em>OR</em>  ".+" :: "Not empty: directory name"<em>OR</em></td>
</tr>
<tr>
<td>out1D_dir</td>
<td>""</td>
<td>Name of 1D ASCII output directory, overrides IO::out_dir</td>
<td>"^$" :: "Empty: use IO::out_dir"<em>OR</em>  ".+" :: "Not empty: directory name"<em>OR</em></td>
</tr>
<tr>
<td>out2D_dir</td>
<td>""</td>
<td>Name of 2D ASCII output directory, overrides IO::out_dir</td>
<td>"^$" :: "Empty: use IO::out_dir"<em>OR</em>  ".+" :: "Not empty: directory name"<em>OR</em></td>
</tr>
<tr>
<td>out3D_dir</td>
<td>""</td>
<td>Name of 3D ASCII output directory, overrides IO::out_dir</td>
<td>"^$" :: "Empty: use IO::out_dir"<em>OR</em>  ".+" :: "Not empty: directory name"<em>OR</em></td>
</tr>
<tr>
<td>out0D_vars</td>
<td>""</td>
<td>Variables to output in 0D ASCII file format</td>
<td>"" :: "List of group or variable names"<em>OR</em></td>
</tr>
<tr>
<td>out1D_vars</td>
<td>""</td>
<td>Variables to output in 1D ASCII file format</td>
<td>"" :: "List of group or variable names"<em>OR</em></td>
</tr>
<tr>
<td>out2D_vars</td>
<td>""</td>
<td>Variables to output in 2D ASCII file format</td>
<td>"" :: "List of group or variable names"<em>OR</em></td>
</tr>
<tr>
<td>out3D_vars</td>
<td>""</td>
<td>Variables to output in 3D ASCII file format</td>
<td>"" :: "List of group or variable names"<em>OR</em></td>
</tr>
<tr>
<td>out0D_criterion</td>
<td>"default"</td>
<td>Criterion to select 0D ASCII output intervals, overrides out_every</td>
<td>"default"   :: "Use IO::out_criterion"<em>OR</em>  "never"     :: "Never output"<em>OR</em>  "iteration" :: "Output every so many iterations"<em>OR</em>  "divisor"   :: "Output if iteration mod divisor == 0."<em>OR</em>  "time"      :: "Output every that much coordinate time"<em>OR</em></td>
</tr>
<tr>
<td>out1D_criterion</td>
<td>"default"</td>
<td>Criterion to select 1D ASCII output intervals, overrides out_every</td>
<td>"default"   :: "Use IO::out_criterion"<em>OR</em>  "never"     :: "Never output"<em>OR</em>  "iteration" :: "Output every so many iterations"<em>OR</em>  "divisor"   :: "Output if (iteration % out_every) == 0."<em>OR</em>  "time"      :: "Output every that much coordinate time"<em>OR</em></td>
</tr>
<tr>
<td>out2D_criterion</td>
<td>"default"</td>
<td>Criterion to select 2D ASCII output intervals, overrides out_every</td>
<td>"default"   :: "Use IO::out_criterion"<em>OR</em>  "never"     :: "Never output"<em>OR</em>  "iteration" :: "Output every so many iterations"<em>OR</em>  "divisor"   :: "Output if (iteration % out_every) == 0."<em>OR</em>  "time"      :: "Output every that much coordinate time"<em>OR</em></td>
</tr>
<tr>
<td>out3D_criterion</td>
<td>"default"</td>
<td>Criterion to select 3D ASCII output intervals, overrides out_every</td>
<td>"default"   :: "Use IO::out_criterion"<em>OR</em>  "never"     :: "Never output"<em>OR</em>  "iteration" :: "Output every so many iterations"<em>OR</em>  "divisor"   :: "Output if (iteration % out_every) == 0."<em>OR</em>  "time"      :: "Output every that much coordinate time"<em>OR</em></td>
</tr>
<tr>
<td>out0D_every</td>
<td>-2</td>
<td>How often to do 0D ASCII output, overrides out_every</td>
<td>1:*  :: "Output every so many time steps"<em>OR</em>  -1:0 :: "No output"<em>OR</em>  -2   :: "Use IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>out1D_every</td>
<td>-2</td>
<td>How often to do 1D ASCII output, overrides out_every</td>
<td>1:*  :: "Output every so many time steps"<em>OR</em>  -1:0 :: "No output"<em>OR</em>  -2   :: "Use IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>out2D_every</td>
<td>-2</td>
<td>How often to do 2D ASCII output, overrides out_every</td>
<td>1:*  :: "Output every so many time steps"<em>OR</em>  -1:0 :: "No output"<em>OR</em>  -2   :: "Use IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>out3D_every</td>
<td>-2</td>
<td>How often to do 3D ASCII output, overrides out_every</td>
<td>1:*  :: "Output every so many time steps"<em>OR</em>  -1:0 :: "No output"<em>OR</em>  -2   :: "Use IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>out0D_dt</td>
<td>-2</td>
<td>How often to do 0D ASCII output, overrides IO::out_dt</td>
<td>(0:* :: "In intervals of that much coordinate time"<em>OR</em>   0   :: "As often as possible"<em>OR</em>  -1   :: "Disable output"<em>OR</em>  -2   :: "Default to IO::out_dt"<em>OR</em></td>
</tr>
<tr>
<td>out1D_dt</td>
<td>-2</td>
<td>How often to do 1D ASCII output, overrides IO::out_dt</td>
<td>(0:* :: "In intervals of that much coordinate time"<em>OR</em>   0   :: "As often as possible"<em>OR</em>  -1   :: "Disable output"<em>OR</em>  -2   :: "Default to IO::out_dt"<em>OR</em></td>
</tr>
<tr>
<td>out2D_dt</td>
<td>-2</td>
<td>How often to do 2D ASCII output, overrides IO::out_dt</td>
<td>(0:* :: "In intervals of that much coordinate time"<em>OR</em>   0   :: "As often as possible"<em>OR</em>  -1   :: "Disable output"<em>OR</em>  -2   :: "Default to IO::out_dt"<em>OR</em></td>
</tr>
<tr>
<td>out3D_dt</td>
<td>-2</td>
<td>How often to do 3D ASCII output, overrides IO::out_dt</td>
<td>(0:* :: "In intervals of that much coordinate time"<em>OR</em>   0   :: "As often as possible"<em>OR</em>  -1   :: "Disable output"<em>OR</em>  -2   :: "Default to IO::out_dt"<em>OR</em></td>
</tr>
<tr>
<td>out0D_point_xi</td>
<td>0</td>
<td>x-index (counting from 0) for 0D points</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out0D_point_yi</td>
<td>0</td>
<td>y-index (counting from 0) for 0D points</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out0D_point_zi</td>
<td>0</td>
<td>z-index (counting from 0) for 0D points</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out0D_point_x</td>
<td>0</td>
<td>x coordinate for 0D points</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out0D_point_y</td>
<td>0</td>
<td>y coordinate for 0D points</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out0D_point_z</td>
<td>0</td>
<td>z coordinate for 0D points</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_x</td>
<td>"yes"</td>
<td>Do 1D IOASCII output in the x-direction</td>
<td></td>
</tr>
<tr>
<td>out1D_y</td>
<td>"yes"</td>
<td>Do 1D IOASCII output in the y-direction</td>
<td></td>
</tr>
<tr>
<td>out1D_z</td>
<td>"yes"</td>
<td>Do 1D IOASCII output in the z-direction</td>
<td></td>
</tr>
<tr>
<td>out1D_xline_yi</td>
<td>0</td>
<td>y-index (counting from 0) for 1D lines in x-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_xline_zi</td>
<td>0</td>
<td>z-index (counting from 0) for 1D lines in x-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_yline_xi</td>
<td>0</td>
<td>x-index (counting from 0) for 1D lines in y-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_yline_zi</td>
<td>0</td>
<td>z-index (counting from 0) for 1D lines in y-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_zline_xi</td>
<td>0</td>
<td>x-index (counting from 0) for 1D lines in z-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_zline_yi</td>
<td>0</td>
<td>y-index (counting from 0) for 1D lines in z-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_xline_y</td>
<td>0</td>
<td>y coordinate for 1D lines in x-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_xline_z</td>
<td>0</td>
<td>z coordinate for 1D lines in x-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_yline_x</td>
<td>0</td>
<td>x coordinate for 1D lines in y-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_yline_z</td>
<td>0</td>
<td>z coordinate for 1D lines in y-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_zline_x</td>
<td>0</td>
<td>x coordinate for 1D lines in z-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_zline_y</td>
<td>0</td>
<td>y coordinate for 1D lines in z-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out2D_xy</td>
<td>"yes"</td>
<td>Do 2D IOASCII output in the xy-direction</td>
<td></td>
</tr>
<tr>
<td>out2D_xz</td>
<td>"yes"</td>
<td>Do 2D IOASCII output in the xz-direction</td>
<td></td>
</tr>
<tr>
<td>out2D_yz</td>
<td>"yes"</td>
<td>Do 2D IOASCII output in the yz-direction</td>
<td></td>
</tr>
<tr>
<td>out2D_xyplane_zi</td>
<td>0</td>
<td>z-index (counting from 0) for 2D planes in xy-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out2D_xzplane_yi</td>
<td>0</td>
<td>y-index (counting from 0) for 2D planes in xz-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out2D_yzplane_xi</td>
<td>0</td>
<td>x-index (counting from 0) for 2D planes in yz-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out2D_xyplane_z</td>
<td>0</td>
<td>z coordinate for 2D planes in xy-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out2D_xzplane_y</td>
<td>0</td>
<td>y coordinate for 2D planes in xz-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out2D_yzplane_x</td>
<td>0</td>
<td>x coordinate for 2D planes in yz-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>output_symmetry_points</td>
<td>"yes"</td>
<td>Output symmetry points (assuming that there are nghostzones symmetry points)</td>
<td></td>
</tr>
<tr>
<td>output_ghost_points</td>
<td>"yes"</td>
<td>Output ghost points</td>
<td></td>
</tr>
<tr>
<td>output_boundary_points</td>
<td>"yes"</td>
<td>Output outer boundary points (assuming that there are nghostzones boundary points)</td>
<td></td>
</tr>
<tr>
<td>out3D_ghosts</td>
<td>"yes"</td>
<td>Output ghost zones (DEPRECATED)</td>
<td></td>
</tr>
<tr>
<td>out3D_outer_ghosts</td>
<td>"yes"</td>
<td>Output outer boundary zones (assuming that there are nghostzones boundary points) (DEPRECATED)</td>
<td></td>
</tr>
<tr>
<td>out1D_d</td>
<td>"yes"</td>
<td>Do output along the diagonal</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="carpetreduce">CarpetReduce</h3>
<p>Cactus Code Thorn CarpetReduce
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides parallel reduction operators for Carpet.</p>
<p>This thorn now uses a weight function.  This makes it possible to
perform physically meaningful spatial reduction operations.  The
weight is 1 for all "normal" grid points.</p>
<p>The weight is set to 0 on symmetry and possible the outer boundary,
and it might be set to &frac12; on the edge of the boundary.  Setting this
depends on the coordinate thorn, and currently works only when the
coordinates are defined via CoordBase.</p>
<p>The weight is also reduced or set to 0 on coarser grids that are
overlaid by finer grid.</p>
<p>The weight should also be reduced or set to 0 near and in excised
regions.  This should happen in conjunction with an excision boundary
thorn.</p>
<p>This weigth function should probably be extracted into its own thorn
MaskBase, so that many thorns can easily operate on it.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Produce screen output while running</td>
<td></td>
</tr>
<tr>
<td>debug_iweight</td>
<td>"no"</td>
<td>Allow debugging iweight grid function by keeping it allocated</td>
<td></td>
</tr>
<tr>
<td>min_max_time_interpolation</td>
<td>"yes"</td>
<td>Interpolate in time for min/max reductions</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="carpetevolutionmask">CarpetEvolutionMask</h3>
<p>Cactus Code Thorn CarpetEvolutionMask
Author(s)    : Christian D. Ott <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
               Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Christian D. Ott <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
               Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Provide a grid function "evolution_mask" which is zero for all grid
points that do not need to be evolved because they are going to be
restricted from a finer grid.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Do verbose debugging output</td>
<td></td>
</tr>
<tr>
<td>enforce_mask</td>
<td>"no"</td>
<td>Set RHS to zero where mask value is 0?</td>
<td></td>
</tr>
<tr>
<td>writeNaNs</td>
<td>"no"</td>
<td>Write NaNs into masked regions</td>
<td></td>
</tr>
<tr>
<td>enforce_vars</td>
<td>""</td>
<td>Enforce mask in MoL automatically on the following variables</td>
<td>"" :: "a list of variables or groups"<em>OR</em></td>
</tr>
<tr>
<td>enlarge_evolved_region_by</td>
<td>0</td>
<td>enlarge or shrink evolved region</td>
<td>0:*  :: "positive values enlarge the evolved region"<em>OR</em> <em>:0) :: "negative values shrink the evolved region. Up to buffer_width + nghostzones points can be removed"*OR</em></td>
</tr>
<tr>
<td>provide_buffer_mask</td>
<td>"no"</td>
<td>Compute mask indicating which points need only be computed for some MoL substeps</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="carpetregridtest">CarpetRegridTest</h3>
<p>Cactus Code Thorn CarpetRegridTest
Thorn Author(s)     : Christian D. Ott <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Thorn Maintainer(s) : Christian D. Ott <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn: This thorn tries to test Carpet Progressive Meshrefinement</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>radius</td>
<td>0.0</td>
<td>The radius of the gaussian wave</td>
<td><em>:</em>  :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>sigma</td>
<td>0.1</td>
<td>The sigma for the gaussian wave</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>amplitude</td>
<td>1.0</td>
<td>The amplitude of the wave</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="carpetinterp">CarpetInterp</h3>
<p>Cactus Code Thorn CarpetInterp
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides a parallel interpolator for Carpet.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>barriers</td>
<td>"no"</td>
<td>Insert barriers at strategic places for debugging purposes (slows down execution)</td>
<td></td>
</tr>
<tr>
<td>poison</td>
<td>-4.20042e+30</td>
<td>Poison value</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ipoison</td>
<td>-420042</td>
<td>Integer poison value</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>tree_search</td>
<td>"yes"</td>
<td>Use a tree search to find the source processor</td>
<td></td>
</tr>
<tr>
<td>check_tree_search</td>
<td>"no"</td>
<td>Cross-check the result of the tree search</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="carpetintegratetest">CarpetIntegrateTest</h3>
<p>Cactus Code Thorn CarpetIntegrateTest
Thorn Author(s)     : Burkhard Zink <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#122;&#105;&#110;&#107;&#64;&#109;&#112;&#97;&#45;&#103;&#97;&#114;&#99;&#104;&#105;&#110;&#103;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#98;&#122;&#105;&#110;&#107;&#64;&#109;&#112;&#97;&#45;&#103;&#97;&#114;&#99;&#104;&#105;&#110;&#103;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Thorn Maintainer(s) : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>Test integration in Carpet.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>constant</td>
<td>1.0</td>
<td>Integrand constant</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>timefact</td>
<td>0.0</td>
<td>Time dependence of integrand</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="doc">doc</h3>
<h3 id="carpetprolongatetest">CarpetProlongateTest</h3>
<p>Cactus Code Thorn CarpetProlongateTest
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Test prolongation in Carpet.</p>
<p>The basic idea is to set up a grid function containing a polynomial of
a certain order of the coordinates. Prolongation (interpolation) with
sufficiently high order must preserve these polynomials exactly (up to
floating-point round-off).</p>
<p>We test restriction as well, but the restriction operators are not
high-order accurate. Since restriction is first order accurate, and we
disable the restriction tests for the higher orders.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>power_x</td>
<td>0</td>
<td>Polynomial power of x coordinate</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>power_y</td>
<td>0</td>
<td>Polynomial power of y coordinate</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>power_z</td>
<td>0</td>
<td>Polynomial power of z coordinate</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>power_t</td>
<td>0</td>
<td>Polynomial power of t coordinate</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>prolongation</td>
<td>"Lagrange"</td>
<td>The prolongation operator to use</td>
<td>"Lagrange"          :: ""<em>OR</em>  "ENO"               :: ""<em>OR</em>  "WENO"              :: ""<em>OR</em>  "TVD"               :: ""<em>OR</em>  "Lagrange_monotone" :: ""<em>OR</em></td>
</tr>
<tr>
<td>interpolator</td>
<td>"Lagrange</td>
<td>The interpolator to use</td>
<td>"" :: "must be a registered interpolator"<em>OR</em></td>
</tr>
<tr>
<td>interpolator_options</td>
<td>"order=2"</td>
<td>Options for the interpolator</td>
<td>"" :: "must be a valid options specification"<em>OR</em></td>
</tr>
<tr>
<td>interp_nx</td>
<td>4</td>
<td>number of points for interpolated region</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>interp_ny</td>
<td>4</td>
<td>number of points for interpolated region</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>interp_nz</td>
<td>4</td>
<td>number of points for interpolated region</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>interp_xmin</td>
<td>-0.5</td>
<td>xmin for interpolated region</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>interp_ymin</td>
<td>-0.5</td>
<td>ymin for interpolated region</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>interp_zmin</td>
<td>-0.5</td>
<td>zmin for interpolated region</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>interp_xmax</td>
<td>+0.5</td>
<td>xmax for interpolated region</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>interp_ymax</td>
<td>+0.5</td>
<td>ymax for interpolated region</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>interp_zmax</td>
<td>+0.5</td>
<td>zmax for interpolated region</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="carpetlib">CarpetLib</h3>
<p>Cactus Code Thorn CarpetLib
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn contains the backend library that provides mesh refinement.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Print info to the screen</td>
<td></td>
</tr>
<tr>
<td>barriers</td>
<td>"no"</td>
<td>Insert barriers at strategic places for debugging purposes (slows down execution)</td>
<td></td>
</tr>
<tr>
<td>commstate_verbose</td>
<td>"no"</td>
<td>Print debug info from the commstate class</td>
<td></td>
</tr>
<tr>
<td>omit_prolongation_points_when_restricting</td>
<td>"no"</td>
<td>Do not restrict to points which are used to prolongate the boundary</td>
<td>#</td>
</tr>
<tr>
<td>proper_nesting_distance</td>
<td>4</td>
<td>Minimum distance (in grid points) between two level interfaces</td>
<td>#  0:* :: "any non-negative value is fine; the default value is just a guess"<em>OR</em>#</td>
</tr>
<tr>
<td>use_dgfe</td>
<td>"no"</td>
<td>Use DGFE operators instead of Lagrange operators</td>
<td></td>
</tr>
<tr>
<td>interpolate_from_buffer_zones</td>
<td>"no"</td>
<td>Use buffer points for interpolation</td>
<td></td>
</tr>
<tr>
<td>use_loopcontrol_in_operators</td>
<td>"no"</td>
<td>Use LoopControl to parallelize AMR operators</td>
<td></td>
</tr>
<tr>
<td>use_openmp</td>
<td>"yes"</td>
<td>Use OpenMP to parallelize AMR operators</td>
<td></td>
</tr>
<tr>
<td>use_higher_order_restriction</td>
<td>"no"</td>
<td>Use third order cell centered restriction operators instead of first order</td>
<td></td>
</tr>
<tr>
<td>restriction_order_space</td>
<td>3</td>
<td>Order of restriction operator to use with use_higher_order_restriction</td>
<td>1 :: "linear interpolation, this is Carpet's original implementation"<em>OR</em>  3 :: "third order accurate restriction for grid functions where prolongation is not (W)ENO"<em>OR</em>  5 :: "fifth order accurate restriction for grid functions where prolongation is not (W)ENO"<em>OR</em></td>
</tr>
<tr>
<td>support_staggered_operators</td>
<td>"no"</td>
<td>Provide one extra ghost point during restriction for staggered operators - EXPERIMENTAL</td>
<td></td>
</tr>
<tr>
<td>output_bboxes</td>
<td>"no"</td>
<td>Output bounding box information to the screen</td>
<td></td>
</tr>
<tr>
<td>check_bboxes</td>
<td>"yes"</td>
<td>Check bounding box information for self-consistency</td>
<td></td>
</tr>
<tr>
<td>poison_new_memory</td>
<td>"no"</td>
<td>Try to catch uninitialised data by setting newly allocated memory to values that will catch your attention</td>
<td></td>
</tr>
<tr>
<td>electric_fence</td>
<td>"no"</td>
<td>Surround each allocated memory block by canaries to check for out-of-bounds accesses</td>
<td></td>
</tr>
<tr>
<td>fence_width</td>
<td>1</td>
<td>number of guard cells to use</td>
<td>1:* :: "any number of cells"<em>OR</em></td>
</tr>
<tr>
<td>poison_value</td>
<td>255</td>
<td>Integer value (0..255) used to poison new timelevels (with memset)</td>
<td>0:255 :: "Must fit into a byte.  Use 0 for zero, 255 for nan, and e.g. 113 for a large value."<em>OR</em></td>
</tr>
<tr>
<td>deadbeef</td>
<td>666</td>
<td>A strange integer value that indicates that something has gone wrong; the integer equivalent of a nan</td>
<td><em>:</em> :: "should be large and positive"<em>OR</em></td>
</tr>
<tr>
<td>max_core_size_MB</td>
<td>-2</td>
<td>Maximum size of a core file, set via setrlimit</td>
<td>-2  :: "unchanged"<em>OR</em>  -1  :: "unlimited"<em>OR</em>  0:* :: "limited"<em>OR</em></td>
</tr>
<tr>
<td>max_memory_size_MB</td>
<td>-2</td>
<td>Maximum amount of memory per MPI process, set via setrlimit</td>
<td>-2  :: "unchanged"<em>OR</em>  -1  :: "unlimited"<em>OR</em>  0:* :: "limited"<em>OR</em></td>
</tr>
<tr>
<td>test_backtrace</td>
<td>"no"</td>
<td>Kill yourself to test the backtrace mechanism</td>
<td></td>
</tr>
<tr>
<td>print_timestats_every</td>
<td>-1</td>
<td>Print timing statistics periodically</td>
<td>-1  :: "don't report"<em>OR</em>  0   :: "report after initialisation"<em>OR</em>  1:* :: "report every so many iterations"<em>OR</em></td>
</tr>
<tr>
<td>timestat_file</td>
<td>"carpetlib-timing-statistics"</td>
<td>File name in which timestat output is collected (because stdout from the root node may not be enough)</td>
<td>"^<span><span class="MathJax_Preview">"   :: "empty filename: no file output"*OR*  "^.+</span><script type="math/tex">"   :: "empty filename: no file output"*OR*  "^.+</script></span>" :: "file name"<em>OR</em></td>
</tr>
<tr>
<td>use_ipm_timing_regions</td>
<td>no</td>
<td>Call IPM (via MPI_Pcontrol) to define regions</td>
<td></td>
</tr>
<tr>
<td>print_memstats_every</td>
<td>-1</td>
<td>Report periodically how much memory is used per process</td>
<td>-1  :: "don't report"<em>OR</em>  0   :: "report after setting up initial data"<em>OR</em>  1:* :: "report every so many iterations"<em>OR</em></td>
</tr>
<tr>
<td>max_allowed_memory_MB</td>
<td>0</td>
<td>Maximum allowed amount of memory per process that can be allocated for grid variables (in Megabytes)</td>
<td>-1  :: "no maximum"<em>OR</em>  0   :: "no maximum"<em>OR</em>  1:* :: "abort if more memory is used"<em>OR</em></td>
</tr>
<tr>
<td>memstat_file</td>
<td>"carpetlib-memory-statistics"</td>
<td>File name in which memstat output is collected (because stdout from the root node may not be enough)</td>
<td>"^<span><span class="MathJax_Preview">"   :: "empty filename: no file output"*OR*  "^.+</span><script type="math/tex">"   :: "empty filename: no file output"*OR*  "^.+</script></span>" :: "file name"<em>OR</em></td>
</tr>
<tr>
<td>combine_recompose</td>
<td>"yes"</td>
<td>Recompose all grid functions of one refinement levels at once</td>
<td></td>
</tr>
<tr>
<td>avoid_arraysize_bytes</td>
<td>0</td>
<td>Avoid array sizes that are multiples of this</td>
<td>#   0   :: "don't avoid anything"<em>OR</em>#   2:* :: ""<em>OR</em>#</td>
</tr>
<tr>
<td>message_size_multiplier</td>
<td>1</td>
<td>Enlarge size of transmitted messages by this factor</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>message_count_multiplier</td>
<td>1</td>
<td>Transmit messages this many times</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>interleave_communications</td>
<td>"no"</td>
<td>Try to interleave communications with each other; each processor begins to communicate with its 'right neighbour' in rank, instead of with the root processor</td>
<td></td>
</tr>
<tr>
<td>barrier_between_stages</td>
<td>"no"</td>
<td>Add a barrier between the communication stages (slows down, but may make timing numbers easier to interpret)</td>
<td></td>
</tr>
<tr>
<td>check_communication_schedule</td>
<td>"no"</td>
<td>Check the communication schedule at run time (expensive)</td>
<td></td>
</tr>
<tr>
<td>combine_sends</td>
<td>"no"</td>
<td>Send data together and in order of processor ranks</td>
<td></td>
</tr>
<tr>
<td>use_mpi_send</td>
<td>"no"</td>
<td>Use MPI_Send instead of MPI_Isend</td>
<td></td>
</tr>
<tr>
<td>use_mpi_ssend</td>
<td>"no"</td>
<td>Use MPI_Ssend instead of MPI_Isend</td>
<td></td>
</tr>
<tr>
<td>pad_to_cachelines</td>
<td>"yes"</td>
<td>Pad arrays to the cache line size (only when VECTORISE_ALIGNED_ARRAYS is set)</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="periodiccarpet">PeriodicCarpet</h3>
<p>Cactus Code Thorn PeriodicCarpet
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;">&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;">&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;</a>
Licence      : GPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Periodic boundary conditions using Carpet's communication routines.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Produce screen output while applying boundary conditions</td>
<td></td>
</tr>
<tr>
<td>periodic</td>
<td>"no"</td>
<td>Periodic boundary conditions in all directions</td>
<td></td>
</tr>
<tr>
<td>periodic_x</td>
<td>"no"</td>
<td>Periodic boundary conditions in x-direction</td>
<td></td>
</tr>
<tr>
<td>periodic_y</td>
<td>"no"</td>
<td>Periodic boundary conditions in y-direction</td>
<td></td>
</tr>
<tr>
<td>periodic_z</td>
<td>"no"</td>
<td>Periodic boundary conditions in z-direction</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="carpetregrid2">CarpetRegrid2</h3>
<p>Set up refined regions by specifying a set of centres and radii about
them.  The refined regions are then the conjunction of these regions.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Display regridding information on the terminal</td>
<td></td>
</tr>
<tr>
<td>veryverbose</td>
<td>"no"</td>
<td>Display much regridding information on the terminal</td>
<td></td>
</tr>
<tr>
<td>min_distance</td>
<td>4</td>
<td>Minimum distance (in grid points) between coarse and fine grid boundaries</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>ensure_proper_nesting</td>
<td>"yes"</td>
<td>Ensure proper nesting automatically</td>
<td></td>
</tr>
<tr>
<td>freeze_unaligned_levels</td>
<td>"no"</td>
<td>Do not change refinement levels that do not exist at this time</td>
<td></td>
</tr>
<tr>
<td>freeze_unaligned_parent_levels</td>
<td>"no"</td>
<td>Do not change refinement levels where the parent does not exist at this time</td>
<td></td>
</tr>
<tr>
<td>min_fraction</td>
<td>0.9</td>
<td>Minimum fraction of required refined points that need to be present in a refined region</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>snap_to_coarse</td>
<td>"no"</td>
<td>Ensure that the fine grid extent coincides with coarse grid points</td>
<td></td>
</tr>
<tr>
<td>granularity</td>
<td>1</td>
<td>Granularity of size of refined regions</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>boundary_shiftout</td>
<td>0</td>
<td>Number of grid points added to the refinement boundary radius</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>regrid_every</td>
<td>0</td>
<td>Regrid every n time steps</td>
<td>-1   :: "regrid never"<em>OR</em>   0   :: "regrid during initial data calculation only"<em>OR</em>   1:* :: "regrid every n time steps"<em>OR</em></td>
</tr>
<tr>
<td>symmetry_rotating90</td>
<td>no</td>
<td>Ensure a 90 degree rotating symmetry about the z axis</td>
<td></td>
</tr>
<tr>
<td>symmetry_rotating180</td>
<td>no</td>
<td>Ensure a 180 degree rotating symmetry about the z axis</td>
<td></td>
</tr>
<tr>
<td>symmetry_parity</td>
<td>no</td>
<td>parity</td>
<td></td>
</tr>
<tr>
<td>symmetry_periodic_x</td>
<td>no</td>
<td>Ensure a periodicity symmetry in the x direction</td>
<td></td>
</tr>
<tr>
<td>symmetry_periodic_y</td>
<td>no</td>
<td>Ensure a periodicity symmetry in the y direction</td>
<td></td>
</tr>
<tr>
<td>symmetry_periodic_z</td>
<td>no</td>
<td>Ensure a periodicity symmetry in the z direction</td>
<td></td>
</tr>
<tr>
<td>expect_symmetric_grids</td>
<td>"no"</td>
<td>Expect a grid structure that is symmetric about the origin, and abort if it is not</td>
<td></td>
</tr>
<tr>
<td>adaptive_refinement</td>
<td>"no"</td>
<td>Use level_mask for adaptive refinement</td>
<td></td>
</tr>
<tr>
<td>adaptive_block_size</td>
<td>8</td>
<td>Block size for adaptive refinement</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>adaptive_block_size_x</td>
<td>-1</td>
<td>Block size in x direction for adaptive refinement</td>
<td>-1 :: "use adaptive_block_size"<em>OR</em>  1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>adaptive_block_size_y</td>
<td>-1</td>
<td>Block size in y direction for adaptive refinement</td>
<td>-1 :: "use adaptive_block_size"<em>OR</em>  1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>adaptive_block_size_z</td>
<td>-1</td>
<td>Block size in z direction for adaptive refinement</td>
<td>-1 :: "use adaptive_block_size"<em>OR</em>  1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>num_centres</td>
<td>0</td>
<td>Number of refinement centres</td>
<td>0:10 :: ""<em>OR</em></td>
</tr>
<tr>
<td>add_levels_automatically</td>
<td>"no"</td>
<td>Automatically add a new refinement level at each regrid</td>
<td></td>
</tr>
<tr>
<td>num_levels_1</td>
<td>1</td>
<td>Number of refinement levels for this centre</td>
<td>1:30 :: ""<em>OR</em></td>
</tr>
<tr>
<td>active_1</td>
<td>"yes"</td>
<td>Is this region active?</td>
<td></td>
</tr>
<tr>
<td>position_x_1</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_y_1</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_z_1</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>movement_threshold_1</td>
<td>0.0</td>
<td>Minimum movement to trigger a regridding</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>radius_rel_change_threshold_1</td>
<td>0.0</td>
<td>Minimum RELATIVE change in radius to trigger a regridding</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>num_levels_2</td>
<td>1</td>
<td>Number of refinement levels for this centre</td>
<td>1:30 :: ""<em>OR</em></td>
</tr>
<tr>
<td>active_2</td>
<td>"yes"</td>
<td>Is this region active?</td>
<td></td>
</tr>
<tr>
<td>position_x_2</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_y_2</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_z_2</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>movement_threshold_2</td>
<td>0.0</td>
<td>Minimum movement to trigger a regridding</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>radius_rel_change_threshold_2</td>
<td>0.0</td>
<td>Minimum change in radius to trigger a regridding</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>num_levels_3</td>
<td>1</td>
<td>Number of refinement levels for this centre</td>
<td>1:30 :: ""<em>OR</em></td>
</tr>
<tr>
<td>active_3</td>
<td>"yes"</td>
<td>Is this region active?</td>
<td></td>
</tr>
<tr>
<td>position_x_3</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_y_3</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_z_3</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>movement_threshold_3</td>
<td>0.0</td>
<td>Minimum movement to trigger a regridding</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>radius_rel_change_threshold_3</td>
<td>0.0</td>
<td>Minimum change in radius to trigger a regridding</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>num_levels_4</td>
<td>1</td>
<td>Number of refinement levels for this centre</td>
<td>1:30 :: ""<em>OR</em></td>
</tr>
<tr>
<td>active_4</td>
<td>"yes"</td>
<td>Is this region active?</td>
<td></td>
</tr>
<tr>
<td>position_x_4</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_y_4</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_z_4</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>movement_threshold_4</td>
<td>0.0</td>
<td>Minimum movement to trigger a regridding</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>radius_rel_change_threshold_4</td>
<td>0.0</td>
<td>Minimum change in radius to trigger a regridding</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>num_levels_5</td>
<td>1</td>
<td>Number of refinement levels for this centre</td>
<td>1:30 :: ""<em>OR</em></td>
</tr>
<tr>
<td>active_5</td>
<td>"yes"</td>
<td>Is this region active?</td>
<td></td>
</tr>
<tr>
<td>position_x_5</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_y_5</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_z_5</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>movement_threshold_5</td>
<td>0.0</td>
<td>Minimum movement to trigger a regridding</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>radius_rel_change_threshold_5</td>
<td>0.0</td>
<td>Minimum change in radius to trigger a regridding</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>num_levels_6</td>
<td>1</td>
<td>Number of refinement levels for this centre</td>
<td>1:30 :: ""<em>OR</em></td>
</tr>
<tr>
<td>active_6</td>
<td>"yes"</td>
<td>Is this region active?</td>
<td></td>
</tr>
<tr>
<td>position_x_6</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_y_6</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_z_6</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>movement_threshold_6</td>
<td>0.0</td>
<td>Minimum movement to trigger a regridding</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>radius_rel_change_threshold_6</td>
<td>0.0</td>
<td>Minimum change in radius to trigger a regridding</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>num_levels_7</td>
<td>1</td>
<td>Number of refinement levels for this centre</td>
<td>1:30 :: ""<em>OR</em></td>
</tr>
<tr>
<td>active_7</td>
<td>"yes"</td>
<td>Is this region active?</td>
<td></td>
</tr>
<tr>
<td>position_x_7</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_y_7</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_z_7</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>movement_threshold_7</td>
<td>0.0</td>
<td>Minimum movement to trigger a regridding</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>radius_rel_change_threshold_7</td>
<td>0.0</td>
<td>Minimum change in radius to trigger a regridding</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>num_levels_8</td>
<td>1</td>
<td>Number of refinement levels for this centre</td>
<td>1:30 :: ""<em>OR</em></td>
</tr>
<tr>
<td>active_8</td>
<td>"yes"</td>
<td>Is this region active?</td>
<td></td>
</tr>
<tr>
<td>position_x_8</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_y_8</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_z_8</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>movement_threshold_8</td>
<td>0.0</td>
<td>Minimum movement to trigger a regridding</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>radius_rel_change_threshold_8</td>
<td>0.0</td>
<td>Minimum change in radius to trigger a regridding</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>num_levels_9</td>
<td>1</td>
<td>Number of refinement levels for this centre</td>
<td>1:30 :: ""<em>OR</em></td>
</tr>
<tr>
<td>active_9</td>
<td>"yes"</td>
<td>Is this region active?</td>
<td></td>
</tr>
<tr>
<td>position_x_9</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_y_9</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_z_9</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>movement_threshold_9</td>
<td>0.0</td>
<td>Minimum movement to trigger a regridding</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>radius_rel_change_threshold_9</td>
<td>0.0</td>
<td>Minimum change in radius to trigger a regridding</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>num_levels_10</td>
<td>1</td>
<td>Number of refinement levels for this centre</td>
<td>1:30 :: ""<em>OR</em></td>
</tr>
<tr>
<td>active_10</td>
<td>"yes"</td>
<td>Is this region active?</td>
<td></td>
</tr>
<tr>
<td>position_x_10</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_y_10</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>position_z_10</td>
<td>0.0</td>
<td>Position of this centre</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>movement_threshold_10</td>
<td>0.0</td>
<td>Minimum movement to trigger a regridding</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>radius_rel_change_threshold_10</td>
<td>0.0</td>
<td>Minimum change in radius to trigger a regridding</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="testcarpetgridinfo">TestCarpetGridInfo</h3>
<p>CVS info   : $Header: /numrelcvs/ThornburgCVS/TestCarpetGridInfo/README,v 1.1 2006/07/03 14:41:50 jthorn Exp $</p>
<p>Cactus Code Thorn TestCarpetGridInfo
Thorn Author(s)     : Jonathan Thornburg <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Thorn Maintainer(s) : Jonathan Thornburg <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="carpetmask">CarpetMask</h3>
<p>Cactus Code Thorn CarpetMask
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Remove unwanted regions from Carpet's reduction operations.  This can
be used e.g. to excise the interior of horizons.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Produce screen output</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="carpetioscalar">CarpetIOScalar</h3>
<p>Cactus Code Thorn CarpetIOScalar
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides scalar output for Carpet.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>one_file_per_group</td>
<td>"no"</td>
<td>Write one file per group instead of per variable</td>
<td></td>
</tr>
<tr>
<td>all_reductions_in_one_file</td>
<td>"no"</td>
<td>Write all requested reductions in one file instead of per reduction</td>
<td></td>
</tr>
<tr>
<td>out_precision</td>
<td>15</td>
<td>How many digits to output floating-point numbers with</td>
<td>0:* :: "Number of precision digits"<em>OR</em></td>
</tr>
<tr>
<td>outScalar_dir</td>
<td>""</td>
<td>Name of scalar output directory, overrides out_dir</td>
<td>"^$" :: "Empty: use IO::out_dir"<em>OR</em>  ".+" :: "Not empty: directory name"<em>OR</em></td>
</tr>
<tr>
<td>outScalar_vars</td>
<td>""</td>
<td>Variables to output in scalar form</td>
<td>"" :: "A regex which matches everything"<em>OR</em></td>
</tr>
<tr>
<td>outScalar_reductions</td>
<td>"count</td>
<td>List of reductions to output in scalar form</td>
<td>"" :: "A regex which matches everything"<em>OR</em></td>
</tr>
<tr>
<td>outScalar_criterion</td>
<td>"iteration"</td>
<td>Criterion to select scalar output intervals, overrides out_every</td>
<td>"never"     :: "Never output"<em>OR</em>  "iteration" :: "Output every so many iterations"<em>OR</em>  "divisor"   :: "Output if iteration mod divisor == 0."<em>OR</em>  "time"      :: "Output every that much coordinate time"<em>OR</em></td>
</tr>
<tr>
<td>outScalar_every</td>
<td>-2</td>
<td>How often to do scalar output, overrides IO::out_every</td>
<td>1:* :: "Output every so many time steps"<em>OR</em>  -1:0 :: "No output"<em>OR</em>  -2   :: "Default to IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>outScalar_dt</td>
<td>-2</td>
<td>How often to do scalar output, overrides out_dt</td>
<td>(0:* :: "In intervals of that much coordinate time"<em>OR</em>   0   :: "As often as possible"<em>OR</em>  -1   :: "Disable output"<em>OR</em>  -2   :: "Default to IO::out_dt"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="carpetiohdf5">CarpetIOHDF5</h3>
<p>Cactus Code Thorn CarpetIOHDF5
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides HDF5 based file I/O for Carpet.  See
<a href="http://www.hdfgroup.org/HDF5/">http://www.hdfgroup.org/HDF5/</a> for information about HDF5.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>out_dir</td>
<td>""</td>
<td>Name of CarpetIOHDF5 output directory, overrides 'IO::out_dir'</td>
<td>"^$" :: "Empty: use IO::out_dir"<em>OR</em>  ".+" :: "Not empty: directory name"<em>OR</em></td>
</tr>
<tr>
<td>out0D_dir</td>
<td>""</td>
<td>Name of 0D HDF5 slice output directory, overrides IO::out_dir</td>
<td>"^$" :: "Empty: use IO::out_dir"<em>OR</em>  ".+" :: "Not empty: directory name"<em>OR</em></td>
</tr>
<tr>
<td>out1D_dir</td>
<td>""</td>
<td>Name of 1D HDF5 slice output directory, overrides IO::out_dir</td>
<td>"^$" :: "Empty: use IO::out_dir"<em>OR</em>  ".+" :: "Not empty: directory name"<em>OR</em></td>
</tr>
<tr>
<td>out2D_dir</td>
<td>""</td>
<td>Name of 2D HDF5 slice output directory, overrides IO::out_dir</td>
<td>"^$" :: "Empty: use IO::out_dir"<em>OR</em>  ".+" :: "Not empty: directory name"<em>OR</em></td>
</tr>
<tr>
<td>out3D_dir</td>
<td>""</td>
<td>Name of 3D HDF5 slice output directory, overrides IO::out_dir</td>
<td>"^$" :: "Empty: use IO::out_dir"<em>OR</em>  ".+" :: "Not empty: directory name"<em>OR</em></td>
</tr>
<tr>
<td>out_vars</td>
<td>""</td>
<td>Variables to output in CarpetIOHDF5 file format</td>
<td>"" :: "List of group or variable names"<em>OR</em></td>
</tr>
<tr>
<td>out0D_vars</td>
<td>""</td>
<td>Variables to output in 0D HDF5 file format</td>
<td>"" :: "List of group or variable names"<em>OR</em></td>
</tr>
<tr>
<td>out1D_vars</td>
<td>""</td>
<td>Variables to output in 1D HDF5 file format</td>
<td>"" :: "List of group or variable names"<em>OR</em></td>
</tr>
<tr>
<td>out2D_vars</td>
<td>""</td>
<td>Variables to output in 2D HDF5 file format</td>
<td>"" :: "List of group or variable names"<em>OR</em></td>
</tr>
<tr>
<td>out3D_vars</td>
<td>""</td>
<td>Variables to output in 3D HDF5 file format</td>
<td>"" :: "List of group or variable names"<em>OR</em></td>
</tr>
<tr>
<td>out_extension</td>
<td>".h5"</td>
<td>File extension to use for CarpetIOHDF5 output</td>
<td>"" :: "File extension (including a leading dot, if desired)"<em>OR</em></td>
</tr>
<tr>
<td>out_criterion</td>
<td>"default"</td>
<td>Criterion to select CarpetIOHDF5 output intervals, overrides out_every</td>
<td>"default"   :: "Use 'IO::out_criterion'"<em>OR</em>  "never"     :: "Never output"<em>OR</em>  "iteration" :: "Output every so many iterations"<em>OR</em>  "divisor"   :: "Output if (iteration % out_every) == 0."<em>OR</em>  "time"      :: "Output every that much coordinate time"<em>OR</em></td>
</tr>
<tr>
<td>out0D_criterion</td>
<td>"default"</td>
<td>Criterion to select 0D HDF5 slice output intervals, overrides out_every</td>
<td>"default"   :: "Use IO::out_criterion"<em>OR</em>  "never"     :: "Never output"<em>OR</em>  "iteration" :: "Output every so many iterations"<em>OR</em>  "divisor"   :: "Output if iteration mod divisor == 0."<em>OR</em>  "time"      :: "Output every that much coordinate time"<em>OR</em></td>
</tr>
<tr>
<td>out1D_criterion</td>
<td>"default"</td>
<td>Criterion to select 1D HDF5 slice output intervals, overrides out_every</td>
<td>"default"   :: "Use IO::out_criterion"<em>OR</em>  "never"     :: "Never output"<em>OR</em>  "iteration" :: "Output every so many iterations"<em>OR</em>  "divisor"   :: "Output if (iteration % out_every) == 0."<em>OR</em>  "time"      :: "Output every that much coordinate time"<em>OR</em></td>
</tr>
<tr>
<td>out2D_criterion</td>
<td>"default"</td>
<td>Criterion to select 2D HDF5 slice output intervals, overrides out_every</td>
<td>"default"   :: "Use IO::out_criterion"<em>OR</em>  "never"     :: "Never output"<em>OR</em>  "iteration" :: "Output every so many iterations"<em>OR</em>  "divisor"   :: "Output if (iteration % out_every) == 0."<em>OR</em>  "time"      :: "Output every that much coordinate time"<em>OR</em></td>
</tr>
<tr>
<td>out3D_criterion</td>
<td>"default"</td>
<td>Criterion to select 3D HDF5 slice output intervals, overrides out_every</td>
<td>"default"   :: "Use IO::out_criterion"<em>OR</em>  "never"     :: "Never output"<em>OR</em>  "iteration" :: "Output every so many iterations"<em>OR</em>  "divisor"   :: "Output if (iteration % out_every) == 0."<em>OR</em>  "time"      :: "Output every that much coordinate time"<em>OR</em></td>
</tr>
<tr>
<td>out_every</td>
<td>-2</td>
<td>How often to do CarpetIOHDF5 output, overrides out_every</td>
<td>1:*  :: "Output every so many time steps"<em>OR</em>  -1:0 :: "No output"<em>OR</em>  -2   :: "Use 'IO::out_every'"<em>OR</em></td>
</tr>
<tr>
<td>out0D_every</td>
<td>-2</td>
<td>How often to do 0D HDF5 slice output, overrides out_every</td>
<td>1:*  :: "Output every so many time steps"<em>OR</em>  -1:0 :: "No output"<em>OR</em>  -2   :: "Use IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>out1D_every</td>
<td>-2</td>
<td>How often to do 1D HDF5 slice output, overrides out_every</td>
<td>1:*  :: "Output every so many time steps"<em>OR</em>  -1:0 :: "No output"<em>OR</em>  -2   :: "Use IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>out2D_every</td>
<td>-2</td>
<td>How often to do 2D HDF5 slice output, overrides out_every</td>
<td>1:*  :: "Output every so many time steps"<em>OR</em>  -1:0 :: "No output"<em>OR</em>  -2   :: "Use IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>out3D_every</td>
<td>-2</td>
<td>How often to do 3D HDF5 slice output, overrides out_every</td>
<td>1:*  :: "Output every so many time steps"<em>OR</em>  -1:0 :: "No output"<em>OR</em>  -2   :: "Use IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>out_dt</td>
<td>-2</td>
<td>How often to do CarpetIOHDF5 output, overrides 'IO::out_dt'</td>
<td>(0:* :: "In intervals of that much coordinate time"<em>OR</em>   0   :: "As often as possible"<em>OR</em>  -1   :: "Disable output"<em>OR</em>  -2   :: "Default to 'IO::out_dt'"<em>OR</em></td>
</tr>
<tr>
<td>out0D_dt</td>
<td>-2</td>
<td>How often to do 0D HDF5 slice output, overrides IO::out_dt</td>
<td>(0:* :: "In intervals of that much coordinate time"<em>OR</em>   0   :: "As often as possible"<em>OR</em>  -1   :: "Disable output"<em>OR</em>  -2   :: "Default to IO::out_dt"<em>OR</em></td>
</tr>
<tr>
<td>out1D_dt</td>
<td>-2</td>
<td>How often to do 1D HDF5 slice output, overrides IO::out_dt</td>
<td>(0:* :: "In intervals of that much coordinate time"<em>OR</em>   0   :: "As often as possible"<em>OR</em>  -1   :: "Disable output"<em>OR</em>  -2   :: "Default to IO::out_dt"<em>OR</em></td>
</tr>
<tr>
<td>out2D_dt</td>
<td>-2</td>
<td>How often to do 2D HDF5 slice output, overrides IO::out_dt</td>
<td>(0:* :: "In intervals of that much coordinate time"<em>OR</em>   0   :: "As often as possible"<em>OR</em>  -1   :: "Disable output"<em>OR</em>  -2   :: "Default to IO::out_dt"<em>OR</em></td>
</tr>
<tr>
<td>out3D_dt</td>
<td>-2</td>
<td>How often to do 3D HDF5 slice output, overrides IO::out_dt</td>
<td>(0:* :: "In intervals of that much coordinate time"<em>OR</em>   0   :: "As often as possible"<em>OR</em>  -1   :: "Disable output"<em>OR</em>  -2   :: "Default to IO::out_dt"<em>OR</em></td>
</tr>
<tr>
<td>out0D_point_xi</td>
<td>0</td>
<td>x-index (counting from 0) for 0D points</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out0D_point_yi</td>
<td>0</td>
<td>y-index (counting from 0) for 0D points</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out0D_point_zi</td>
<td>0</td>
<td>z-index (counting from 0) for 0D points</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out0D_point_x</td>
<td>0</td>
<td>x coordinate for 0D points</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out0D_point_y</td>
<td>0</td>
<td>y coordinate for 0D points</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out0D_point_z</td>
<td>0</td>
<td>z coordinate for 0D points</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_x</td>
<td>"yes"</td>
<td>Do 1D HDF5 slice output in the x-direction</td>
<td></td>
</tr>
<tr>
<td>out1D_y</td>
<td>"yes"</td>
<td>Do 1D HDF5 slice output in the y-direction</td>
<td></td>
</tr>
<tr>
<td>out1D_z</td>
<td>"yes"</td>
<td>Do 1D HDF5 slice output in the z-direction</td>
<td></td>
</tr>
<tr>
<td>out1D_xline_yi</td>
<td>0</td>
<td>y-index (counting from 0) for 1D lines in x-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_xline_zi</td>
<td>0</td>
<td>z-index (counting from 0) for 1D lines in x-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_yline_xi</td>
<td>0</td>
<td>x-index (counting from 0) for 1D lines in y-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_yline_zi</td>
<td>0</td>
<td>z-index (counting from 0) for 1D lines in y-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_zline_xi</td>
<td>0</td>
<td>x-index (counting from 0) for 1D lines in z-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_zline_yi</td>
<td>0</td>
<td>y-index (counting from 0) for 1D lines in z-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_xline_y</td>
<td>0</td>
<td>y coordinate for 1D lines in x-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_xline_z</td>
<td>0</td>
<td>z coordinate for 1D lines in x-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_yline_x</td>
<td>0</td>
<td>x coordinate for 1D lines in y-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_yline_z</td>
<td>0</td>
<td>z coordinate for 1D lines in y-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_zline_x</td>
<td>0</td>
<td>x coordinate for 1D lines in z-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out1D_zline_y</td>
<td>0</td>
<td>y coordinate for 1D lines in z-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out2D_xy</td>
<td>"yes"</td>
<td>Do 2D HDF5 slice output in the xy-direction</td>
<td></td>
</tr>
<tr>
<td>out2D_xz</td>
<td>"yes"</td>
<td>Do 2D HDF5 slice output in the xz-direction</td>
<td></td>
</tr>
<tr>
<td>out2D_yz</td>
<td>"yes"</td>
<td>Do 2D HDF5 slice output in the yz-direction</td>
<td></td>
</tr>
<tr>
<td>out2D_xyplane_zi</td>
<td>0</td>
<td>z-index (counting from 0) for 2D planes in xy-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out2D_xzplane_yi</td>
<td>0</td>
<td>y-index (counting from 0) for 2D planes in xz-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out2D_yzplane_xi</td>
<td>0</td>
<td>x-index (counting from 0) for 2D planes in yz-direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>out2D_xyplane_z</td>
<td>0</td>
<td>z coordinate for 2D planes in xy-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out2D_xzplane_y</td>
<td>0</td>
<td>y coordinate for 2D planes in xz-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>out2D_yzplane_x</td>
<td>0</td>
<td>x coordinate for 2D planes in yz-direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>output_all_timelevels</td>
<td>"no"</td>
<td>Output all timelevels instead of only the current</td>
<td></td>
</tr>
<tr>
<td>output_symmetry_points</td>
<td>"yes"</td>
<td>Output symmetry points (assuming that there are nghostzones symmetry points)</td>
<td></td>
</tr>
<tr>
<td>output_ghost_points</td>
<td>"yes"</td>
<td>Output ghost points</td>
<td></td>
</tr>
<tr>
<td>output_boundary_points</td>
<td>"yes"</td>
<td>Output outer boundary points (assuming that there are nghostzones boundary points)</td>
<td></td>
</tr>
<tr>
<td>output_buffer_points</td>
<td>"yes"</td>
<td>Output refinement buffer points</td>
<td></td>
</tr>
<tr>
<td>out3D_ghosts</td>
<td>"yes"</td>
<td>Output ghost zones (DEPRECATED)</td>
<td></td>
</tr>
<tr>
<td>out3D_outer_ghosts</td>
<td>"yes"</td>
<td>Output outer boundary zones (assuming that there are nghostzones boundary points) (DEPRECATED)</td>
<td></td>
</tr>
<tr>
<td>out1D_d</td>
<td>"yes"</td>
<td>Do output along the diagonal</td>
<td></td>
</tr>
<tr>
<td>checkpoint</td>
<td>"no"</td>
<td>Do checkpointing with CarpetIOHDF5 ?</td>
<td></td>
</tr>
<tr>
<td>checkpoint_next</td>
<td>"no"</td>
<td>Checkpoint at next iteration ?</td>
<td></td>
</tr>
<tr>
<td>checkpoint_every_divisor</td>
<td>-1</td>
<td>Checkpoint if (iteration % out_every) == 0</td>
<td>1:* :: "Every so many iterations"<em>OR</em>  -1:0 :: "Disable periodic checkpointing"<em>OR</em></td>
</tr>
<tr>
<td>use_reflevels_from_checkpoint</td>
<td>"no"</td>
<td>Use 'CarpetRegrid::refinement_levels' from the checkpoint file rather than from the parameter file ?</td>
<td></td>
</tr>
<tr>
<td>use_grid_structure_from_checkpoint</td>
<td>"yes"</td>
<td>Use the grid structure stored in the checkpoint file</td>
<td></td>
</tr>
<tr>
<td>one_file_per_proc</td>
<td>"no"</td>
<td>Write one file per process instead of per variable</td>
<td></td>
</tr>
<tr>
<td>one_file_per_group</td>
<td>"no"</td>
<td>Write one file per group instead of per variable</td>
<td></td>
</tr>
<tr>
<td>open_one_input_file_at_a_time</td>
<td>"no"</td>
<td>Open only one HDF5 file at a time when reading data from multiple chunked checkpoint/data files</td>
<td>"no"  :: "Open all input files first, then import data (most efficient)"<em>OR</em>  "yes" :: "Process input files one after another (reduces memory requirements)"<em>OR</em></td>
</tr>
<tr>
<td>skip_recover_variables</td>
<td>""</td>
<td>Skip these variables while recovering</td>
<td>"" :: ""<em>OR</em></td>
</tr>
<tr>
<td>compression_level</td>
<td>0</td>
<td>Compression level to use for writing HDF5 data</td>
<td>0:9 :: "Higher numbers compress better, a value of zero disables compression"<em>OR</em></td>
</tr>
<tr>
<td>minimum_size_for_compression</td>
<td>32768</td>
<td>Only compress datasets larger than this many bytes</td>
<td>0:* :: "This should to be large enough so that compression gains outweigh the overhead"<em>OR</em></td>
</tr>
<tr>
<td>use_checksums</td>
<td>"no"</td>
<td>Use checksums for the HDF5 data</td>
<td></td>
</tr>
<tr>
<td>output_index</td>
<td>"no"</td>
<td>Output an index file for each output file</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="reductiontest">ReductionTest</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header:</span><script type="math/tex">Header:</script></span></p>
<p>Cactus Code Thorn ReductionTest
Thorn Author(s)     : Christian D. Ott <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Thorn Maintainer(s) : Christian D. Ott <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="regridsynctest">RegridSyncTest</h3>
<p>Cactus Code Thorn RegridSyncTest
Thorn Author(s)     : Christian D. Ott <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Thorn Maintainer(s) : Christian D. Ott <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#99;&#111;&#116;&#116;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>Test regridding.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="highorderwavetest">HighOrderWaveTest</h3>
<p>Cactus Code Thorn HighOrderWaveTest
Author(s)    : Roland Haas <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#104;&#97;&#97;&#115;&#64;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#104;&#97;&#97;&#115;&#64;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Roland Haas <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#104;&#97;&#97;&#115;&#64;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#104;&#97;&#97;&#115;&#64;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Licence      : GPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Test Carpet's restriction with cell-centring and with higher-order
restriction operators.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="einsteininitialdata">EinsteinInitialData</h2>
<h3 id="idconstraintviolate">IDConstraintViolate</h3>
<p>Cactus Code Thorn IDConstraintViolate
Authors    : Ed Seidel, Gabrielle Allen
CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<hr />
<p>Purpose of the thorn:</p>
<p>To set up initial data for the metric and extrinsic curvature which 
violates the constraint equations.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>radius</td>
<td>0.0</td>
<td>The radial position of the Gaussian wave</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>sigma</td>
<td>0.1</td>
<td>The sigma for the Gaussian wave</td>
<td>(0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>amplitude</td>
<td>0.001</td>
<td>The amplitude of the waves</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="twopunctures">TwoPunctures</h3>
<p>Cactus Code Thorn TwoPunctures
Author(s)    : Marcus Ansorg
               Erik Schnetter
               Frank Löffler
Maintainer(s): Marcus Ansorg
               Erik Schnetter
Licence      : LGPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Create initial for two puncture black holes using a single domain
spectral method.  This method is described in
Marcus Ansorg, Bernd Brügmann, Wolfgang Tichy,
"A single-domain spectral method for black hole puncture data",
PRD 70, 064011 (2004),
arXiv:gr-qc/0404056.</p>
<p>This thorn was extended to include source terms to be able
to handle matter with the same restrictions as the BHs before plus
zero momentum/ang. momentum (K_{ij} = 0).</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Print screen output while solving</td>
<td></td>
</tr>
<tr>
<td>keep_u_around</td>
<td>"no"</td>
<td>Keep the variable u around after solving</td>
<td></td>
</tr>
<tr>
<td>give_bare_mass</td>
<td>"yes"</td>
<td>User provides bare masses rather than target ADM masses</td>
<td></td>
</tr>
<tr>
<td>adm_tol</td>
<td>1.0e-10</td>
<td>Tolerance of ADM masses when give_bare_mass=no</td>
<td>(0:<em>) :: ""*OR</em></td>
</tr>
<tr>
<td>grid_setup_method</td>
<td>"Taylor</td>
<td>How to fill the 3D grid from the spectral grid</td>
<td>"Taylor expansion" :: "use a Taylor expansion about the nearest collocation point (fast, but might be inaccurate)"<em>OR</em>  "evaluation"       :: "evaluate using all spectral coefficients (slow)"<em>OR</em></td>
</tr>
<tr>
<td>npoints_A</td>
<td>30</td>
<td>Number of coefficients in the compactified radial direction</td>
<td>4:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>npoints_B</td>
<td>30</td>
<td>Number of coefficients in the angular direction</td>
<td>4:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>npoints_phi</td>
<td>16</td>
<td>Number of coefficients in the phi direction</td>
<td>4:<em>:2 :: ""*OR</em></td>
</tr>
<tr>
<td>Newton_tol</td>
<td>1.0e-10</td>
<td>Tolerance for Newton solver</td>
<td>(0:<em>) :: ""*OR</em></td>
</tr>
<tr>
<td>Newton_maxit</td>
<td>5</td>
<td>Maximum number of Newton iterations</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>TP_epsilon</td>
<td>0.0</td>
<td>A small number to smooth out singularities at the puncture locations</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>TP_Tiny</td>
<td>0.0</td>
<td>Tiny number to avoid nans near or at the pucture locations</td>
<td>0:* :: "anything positive, usually very small"<em>OR</em></td>
</tr>
<tr>
<td>TP_Extend_Radius</td>
<td>0.0</td>
<td>Radius of an extended spacetime instead of the puncture</td>
<td>0:* :: "anything positive, should be smaller than the horizon"<em>OR</em></td>
</tr>
<tr>
<td>par_b</td>
<td>1.0</td>
<td>x coordinate of the m+ puncture</td>
<td>(0.0:<em>) :: ""*OR</em></td>
</tr>
<tr>
<td>par_m_plus</td>
<td>1.0</td>
<td>mass of the m+ puncture</td>
<td>0.0:<em>) :: ""*OR</em></td>
</tr>
<tr>
<td>par_m_minus</td>
<td>1.0</td>
<td>mass of the m- puncture</td>
<td>0.0:<em>) :: ""*OR</em></td>
</tr>
<tr>
<td>target_M_plus</td>
<td>0.5</td>
<td>target ADM mass for m+</td>
<td>0.0:<em>) :: ""*OR</em></td>
</tr>
<tr>
<td>target_M_minus</td>
<td>0.5</td>
<td>target ADM mass for m-</td>
<td>0.0:<em>) :: ""*OR</em></td>
</tr>
<tr>
<td>initial_lapse_psi_exponent</td>
<td>-2.0</td>
<td>Exponent n for psi^-n initial lapse profile</td>
<td>(<em>:</em>) :: "Should be negative"<em>OR</em></td>
</tr>
<tr>
<td>swap_xz</td>
<td>"no"</td>
<td>Swap x and z coordinates when interpolating, so that the black holes are separated in the z direction</td>
<td></td>
</tr>
<tr>
<td>use_sources</td>
<td>"no"</td>
<td>Use sources?</td>
<td></td>
</tr>
<tr>
<td>rescale_sources</td>
<td>"yes"</td>
<td>If sources are used - rescale them after solving?</td>
<td></td>
</tr>
<tr>
<td>use_external_initial_guess</td>
<td>"no"</td>
<td>Set initial guess by external function?</td>
<td></td>
</tr>
<tr>
<td>do_residuum_debug_output</td>
<td>"no"</td>
<td>Output debug information about the residuum</td>
<td></td>
</tr>
<tr>
<td>do_initial_debug_output</td>
<td>"no"</td>
<td>Output debug information about initial guess</td>
<td></td>
</tr>
<tr>
<td>multiply_old_lapse</td>
<td>"no"</td>
<td>Multiply the old lapse with the new one</td>
<td></td>
</tr>
<tr>
<td>schedule_in_ADMBase_InitialData</td>
<td>"yes"</td>
<td>Schedule in (instead of after) ADMBase_InitialData</td>
<td></td>
</tr>
<tr>
<td>solve_momentum_constraint</td>
<td>"no"</td>
<td>Solve for momentum constraint?</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="tovsolver">TOVSolver</h3>
<p>Cactus Code Thorn TOVSolver
Author(s)    : Ian Hawke
               Frank Löffler
               Luca Baiotti
               Christian David Ott
               Erik Schnetter
               Bruno Giacomazzo
Maintainer(s): Einstein Toolkit
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides initial data for TOV star(s) in isotropic coordinates.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>TOV_Num_TOVs</td>
<td>1</td>
<td>The number of TOVs</td>
<td>1:* :: "Greater than 0"<em>OR</em></td>
</tr>
<tr>
<td>TOV_Solve_for_TOVs</td>
<td>3</td>
<td>Solve for TOVs even if no TOV initial data was requested?</td>
<td>0:3 :: "depreciated in favour of TOVSolver::TOV_Enforce_Interpolation"<em>OR</em></td>
</tr>
<tr>
<td>TOV_Enforce_Interpolation</td>
<td>"no"</td>
<td>Enforce the interpolation of the data onto the Hydro GFs even without tov as specified initial data</td>
<td></td>
</tr>
<tr>
<td>TOV_Num_Radial</td>
<td>100000</td>
<td>The number of radial points for the ODE integration</td>
<td>1:* :: "Greater than 0"<em>OR</em></td>
</tr>
<tr>
<td>TOV_Gamma</td>
<td>2.0</td>
<td>The polytropic constant in P = K rho^Gamma</td>
<td>1.0: :: "The physical range at high Lorentz factors is [1,2], but otherwise higher values of gamma can also be used"<em>OR</em></td>
</tr>
<tr>
<td>TOV_K</td>
<td>100.0</td>
<td>The polytropic constant in P = K rho^Gamma</td>
<td>(0.0:* :: "Greater than 0"<em>OR</em></td>
</tr>
<tr>
<td>TOV_ProperPosition</td>
<td>"no"</td>
<td>For use only with two NSs, atm only handles equal mass</td>
<td></td>
</tr>
<tr>
<td>TOV_Fast_Interpolation</td>
<td>"yes"</td>
<td>Use faster interpolation algorithm? Default is yes.</td>
<td></td>
</tr>
<tr>
<td>TOV_Clear_Initial_Data</td>
<td>"yes"</td>
<td>Clear initial data (spacetime)? Default is yes.</td>
<td></td>
</tr>
<tr>
<td>TOV_Use_Old_Initial_Data</td>
<td>"no"</td>
<td>Take old initial data into account (spacetime)? Default is no.</td>
<td></td>
</tr>
<tr>
<td>TOV_Use_Old_Matter_Initial_Data</td>
<td>"no"</td>
<td>Use also old matter initial data? Default is no.</td>
<td></td>
</tr>
<tr>
<td>TOV_Conformal_Flat_Three_Metric</td>
<td>"no"</td>
<td>Use conformal factor to get the 3-metric flat. default is no</td>
<td></td>
</tr>
<tr>
<td>TOV_Populate_Timelevels</td>
<td>1</td>
<td>Populate that amount of timelevels</td>
<td>1:3 :: "1 (default) to 3"<em>OR</em></td>
</tr>
<tr>
<td>TOV_Momentum_Psi_Power</td>
<td>0</td>
<td>Power of Psi to be multiplied with J^i for Mom</td>
<td><em>:</em> :: "anything, 0 as default"<em>OR</em></td>
</tr>
<tr>
<td>TOV_fake_evolution</td>
<td>0</td>
<td>Fake evolution by setting ID at every step</td>
<td><em>:</em> :: "anything, 0 as off (default), everything else as on"<em>OR</em></td>
</tr>
<tr>
<td>TOV_save_to_datafile</td>
<td>""</td>
<td>Only save data to file and exit</td>
<td>".<em>" :: "Any filename, not used if empty"*OR</em></td>
</tr>
</tbody>
</table>
<h3 id="idaxibrillbh">IDAxiBrillBH</h3>
<p>Cactus Code Thorn IDAxiBrillBH
Author(s)    : Steve Brandt
               Paul Walker
               Ryoji Takahashi
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn calculates initial data for a black hole distorted by an
even parity perturbation.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>debug_ii</td>
<td>14</td>
<td>i coordinate for per-2D-grid-point debug printing</td>
<td><em>:</em> :: "any integer"<em>OR</em></td>
</tr>
<tr>
<td>debug_jj</td>
<td>15</td>
<td>j coordinate for per-2D-grid-point debug printing</td>
<td><em>:</em> :: "any integer"<em>OR</em></td>
</tr>
<tr>
<td>debug_i</td>
<td>14</td>
<td>i coordinate for per-grid-point debug printing</td>
<td><em>:</em> :: "any integer"<em>OR</em></td>
</tr>
<tr>
<td>debug_j</td>
<td>15</td>
<td>j coordinate for per-grid-point debug printing</td>
<td><em>:</em> :: "any integer"<em>OR</em></td>
</tr>
<tr>
<td>debug_k</td>
<td>10</td>
<td>k coordinate for per-grid-point debug printing</td>
<td><em>:</em> :: "any integer"<em>OR</em></td>
</tr>
<tr>
<td>amp</td>
<td>0.1</td>
<td>Brill wave amplitude</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>eta0</td>
<td>0.0</td>
<td>Brill wave center (in eta coords)</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>sigma</td>
<td>1.0</td>
<td>Brill wave width (in eta)</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>etamax</td>
<td>5.0</td>
<td>eta value for outer edge of grid</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>n</td>
<td>2</td>
<td>sin^n theta in Brill wave</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>ne</td>
<td>300</td>
<td>eta resolution for solve</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>nq</td>
<td>50</td>
<td>theta resolution for solve</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>error_tolerance</td>
<td>1.0e-12</td>
<td>tolerance parameter for elliptic solver</td>
<td>(0:* :: "any positive real number"<em>OR</em></td>
</tr>
<tr>
<td>interpolator_pars</td>
<td>""</td>
<td>parameters for the interpolation operator</td>
<td>".<em>" :: *OR</em>  "any nonempty string acceptable to Util_TableSetFromString()      *OR*   and to the interpolator, or the empty string to use 'order=n',  *OR*   where  n  is specified by the  interpolation_order  parameter"<em>OR</em></td>
</tr>
<tr>
<td>interpolation_order</td>
<td>1</td>
<td>Order for interpolation</td>
<td>0:9 :: "any integer accepted by the interpolator"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="idlinearwaves">IDLinearWaves</h3>
<p>Cactus Code Thorn IDLinearWaves
Author(s)    : Malcolm Tobias
               Joan Masso
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Provides analytic data for linear gravitational waves.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>amplitude</td>
<td>0.001</td>
<td>Amplitude of the wave: both for teuk and plane</td>
<td>0: :: "positive amplitude"<em>OR</em></td>
</tr>
<tr>
<td>mvalue</td>
<td>0</td>
<td>m value for teukwaves waves: integer from -2 to 2</td>
<td>-2:2 :: "implemented : m = -2..2"<em>OR</em></td>
</tr>
<tr>
<td>wavecenter</td>
<td>0.0</td>
<td>linears waves thingie</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>wavelength</td>
<td>2.0</td>
<td>linearwaves wave length</td>
<td>0: :: "positive wavelength"<em>OR</em></td>
</tr>
<tr>
<td>wavepulse</td>
<td>1.0</td>
<td>planewaves thingy for the gaussian pulse</td>
<td>0: :: "positive pulse"<em>OR</em></td>
</tr>
<tr>
<td>wavetheta</td>
<td>0.0</td>
<td>Theta angle for planewaves</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>wavephi</td>
<td>0.0</td>
<td>Phi angle for planewaves</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>parity</td>
<td>"even"</td>
<td>Parity for teukwaves: even or odd</td>
<td>"even" :: "even parity"<em>OR</em>  "odd"  :: "odd parity"<em>OR</em></td>
</tr>
<tr>
<td>packet</td>
<td>"eppley"</td>
<td>Packet for teukwaves: eppley,evans,square</td>
<td>"eppley" :: "Eppley type"<em>OR</em>  "evans"  :: "Evans type"<em>OR</em>  "square" :: "Square type"<em>OR</em></td>
</tr>
<tr>
<td>wavesgoing</td>
<td>"both"</td>
<td>in and outgoing waves...</td>
<td>"in"   :: "Ingoing wave"<em>OR</em>  "out"  :: "Outgoing wave"    <em>OR</em>  "both" :: "In and outgoing wave"<em>OR</em></td>
</tr>
<tr>
<td>teuk_no_vee</td>
<td>"no"</td>
<td>Initialize Teuk. waves with V=0?</td>
<td>"no" :: "Bona Masso setting"<em>OR</em>  "yes":: "Bona Masso setting"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="meudon_bin_ns">Meudon_Bin_NS</h3>
<p>Cactus Code Thorn Meudon_Bin_NS
Author(s)    : Erik Schnetter
               Frank Löffler
               Roberto De Pietri
Maintainer(s): Einstein Toolkit Maintainers
Licence      : GPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Import LORENE Bin_NS binary neutron star initial data.</p>
<p>This thorn is one of three closely related thorns Meudon_Bin_BH,
Meudon_Bin_NS, and Meudon_Mag_NS which all import LORENE initial data.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>""</td>
<td>Input file name containing LORENE data</td>
<td>"" :: "Any filename, potentially including path"<em>OR</em></td>
</tr>
<tr>
<td>eos_table</td>
<td>"2D_Polytrope"</td>
<td>Initial data EOS identifyer</td>
<td>"" :: "Any valid EOS name in EOSOmni"<em>OR</em></td>
</tr>
<tr>
<td>eos_table_filepath</td>
<td>""</td>
<td>Directory containing the EOS file used to generate the initial data</td>
<td>"" :: "Directory name, default (empty string) is 'do not tell Lorene to overwrite info found in Lorene data'"<em>OR</em></td>
</tr>
<tr>
<td>recalculate_eps</td>
<td>"yes"</td>
<td>Should eps be recalculated (default), or taken from Lorene data?</td>
<td></td>
</tr>
<tr>
<td>eos_precision</td>
<td>1.e-8</td>
<td>precision of EOS calculations in EOSOmni</td>
<td>0:* :: "any positive number"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="noexcision">NoExcision</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<p>Cactus Code Thorn NoExcision
Thorn Author(s)     : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Thorn Maintainer(s) : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>Overwrite the regions near a singularity with "something else",
possibly flat space, ignoring the constraints.  This is instead of
excision.</p>
<p>This method is modelled after an idea by Denis Pollney, following an
serendipitous bug by Ian Hawke.  The word "serendipity" was coined by
Horace Walpole in the 18<sup>th</sup> century, from the Persian fairy tale "The
Three Princes of Serendip" (<a href="http://www.wikipedia.org">www.wikipedia.org</a>).</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Produce some screen output</td>
<td></td>
</tr>
<tr>
<td>method</td>
<td>"old"</td>
<td>Method to use</td>
<td>"old" :: "Use old method"<em>OR</em>  "new" :: "Use new method"<em>OR</em></td>
</tr>
<tr>
<td>num_regions</td>
<td>0</td>
<td>Number of no-excision regions</td>
<td>0:10 :: ""<em>OR</em></td>
</tr>
<tr>
<td>smoothing_iterations</td>
<td>10</td>
<td>Smoothing iterations</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>smoothing_factor</td>
<td>1.2</td>
<td>Initial moothing factor</td>
<td>(0:2) :: ""<em>OR</em></td>
</tr>
<tr>
<td>smooth_regions</td>
<td>"no"</td>
<td>Smooth overwritten regions?</td>
<td></td>
</tr>
<tr>
<td>smoothing_order</td>
<td>6</td>
<td>Order of the derivatives used for CG smoothing</td>
<td>2:6:2 :: ""<em>OR</em></td>
</tr>
<tr>
<td>smoothing_eps</td>
<td>1e-6</td>
<td>CG smoothing stop criteria</td>
<td>(0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>use_user_regions</td>
<td>"no"</td>
<td>Use user defined regions for the smoothing regions</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="distortedbhivp">DistortedBHIVP</h3>
<p>Cactus Code Thorn DistortedBHIVP
Authors    : Ryoji Takahashi 
CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<hr />
<p>This thorn does calculates initial data for a black hole distorted
by a non-axisymmetric even parity perturbation </p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>amp</td>
<td>0.1</td>
<td>Brill wave amplitude</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>eta0</td>
<td>0.0</td>
<td>Brill wave center (in eta coords)</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>c</td>
<td>0.0</td>
<td>Azimuthal dependence of Brill wave</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>sigma</td>
<td>1.0</td>
<td>Brill wave width (in eta)</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>etamax</td>
<td>5.0</td>
<td>Eta value for outer edge of grid</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>n</td>
<td>2</td>
<td>sin^n theta in brill wave</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>neta</td>
<td>202</td>
<td>Eta resolution for solve</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>ntheta</td>
<td>54</td>
<td>Theta resolution for solve</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>nphi</td>
<td>5</td>
<td>Eta resolution for solve</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>interpolation_order</td>
<td>1</td>
<td>Order for interpolation</td>
<td>1:3 :: "Choose between first, second, and third-order"<em>OR</em></td>
</tr>
<tr>
<td>tolerance</td>
<td>1.e-9</td>
<td>Tolerance</td>
<td>0:* :: "Tolerance"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="hydro_rnsid">Hydro_RNSID</h3>
<p>Cactus Code Thorn RNSID
Author(s)    : Nik Stergioulas
               Tom Goodale
               Roberto De Pietri
               Frank Löffler
Maintainer(s): Roberto De Pietri
               Nik Stergioulas
Licence      : GPLv2+</p>
<hr />
<p>Purpose of the thorn:</p>
<p>This thorn provides initial data for a rotating neutron star.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>rotation_type</td>
<td>"uniform"</td>
<td>Specify type of rotation law</td>
<td>"uniform" :: "uniform rotation"<em>OR</em> "diff" :: "KEH differential rotation law"<em>OR</em></td>
</tr>
<tr>
<td>axes_ratio</td>
<td>1</td>
<td>rnsid axes ratio</td>
<td>0: :: "Any positive number"<em>OR</em></td>
</tr>
<tr>
<td>rho_central</td>
<td>1.24e-3</td>
<td>Central Density for Star</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>A_diff</td>
<td>1.0</td>
<td>constant A in differential rotation law</td>
<td>0.0: :: "Any positive number"<em>OR</em></td>
</tr>
<tr>
<td>eos_type</td>
<td>"poly"</td>
<td>Specify type of equation of state</td>
<td>"poly" :: "Polytropic EOS"<em>OR</em> "tab"  :: "Tabulated EOS"<em>OR</em></td>
</tr>
<tr>
<td>RNS_Gamma</td>
<td>2</td>
<td>If we're using a different EoS at run time, this is the RNS Gamma</td>
<td><em>:</em> :: "Will be ignored if negative"<em>OR</em></td>
</tr>
<tr>
<td>RNS_K</td>
<td>100</td>
<td>If we're using a different EoS at run time, this is the RNS K</td>
<td><em>:</em> :: "Will be ignored if negative"<em>OR</em></td>
</tr>
<tr>
<td>eos_file</td>
<td>""</td>
<td>Equation of state table</td>
<td>.* :: "EOS table file"<em>OR</em></td>
</tr>
<tr>
<td>RNS_rho_min</td>
<td></td>
<td>A minimum rho below which evolution is turned off (atmosphere).</td>
<td>0.0: :: "Zero or larger. A useful value could be 0.0001"<em>OR</em></td>
</tr>
<tr>
<td>accuracy</td>
<td>1.0e-7</td>
<td>rnsid accuracy in convergence</td>
<td>0: :: "Any positive number"<em>OR</em></td>
</tr>
<tr>
<td>zero_shift</td>
<td>"no"</td>
<td>Set shift to zero?</td>
<td>"yes" :: "set shift to zero"<em>OR</em> "no" :: "don't set shift to zero"<em>OR</em></td>
</tr>
<tr>
<td>save_2Dmodel</td>
<td>"no"</td>
<td>Save 2D model?</td>
<td>"yes" :: "save 2D model"<em>OR</em> "no" :: "don't save 2D model"<em>OR</em></td>
</tr>
<tr>
<td>recover_2Dmodel</td>
<td>"no"</td>
<td>Recover 2D model?</td>
<td>"yes" :: "recover 2D model"<em>OR</em> "no" :: "don't recover 2D model"<em>OR</em></td>
</tr>
<tr>
<td>model2D_file</td>
<td>"model2D.dat"</td>
<td>Name of 2D model file</td>
<td>.* :: "Default 2D model file"<em>OR</em></td>
</tr>
<tr>
<td>cf</td>
<td>1.0</td>
<td>Convergence factor</td>
<td>0:  ::  "Any positive number"<em>OR</em></td>
</tr>
<tr>
<td>RNS_lmax</td>
<td>10</td>
<td>max. term in Legendre poly.</td>
<td>1: :: "Any positive, non zero number"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="idfileadm">IDFileADM</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<p>Cactus Code Thorn IDFileADM
Thorn Author(s)     : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Thorn Maintainer(s) : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>Make it possible to use the file reader to read initial data for the
ADM variables.  This checks whether the ADM variables are actually
supposed to be read, so that it is impossible to actually leave
something uninitialised.  However, read errors are not caught.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="idaxioddbrillbh">IDAxiOddBrillBH</h3>
<p>Cactus Code Thorn IDAxiOddBrillBH
Authors    : Ryoji Takahashi 
CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<hr />
<p>This thorn does calculates initial data for a black hole distorted
by a axisymmetric odd parity perturbation </p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>amp</td>
<td>0.1</td>
<td>Brill wave amplitude for extrinsic curveture</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>amp_me</td>
<td>0.0</td>
<td>Brill wave amplitude for metric</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>xi</td>
<td>0.0</td>
<td>for recoil</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>eta0</td>
<td>0.0</td>
<td>Brill wave center (in eta coords) for extrisic curvature</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>eta0_me</td>
<td>0.0</td>
<td>Brill wave center (in eta coords) for metric</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>sigma</td>
<td>1.0</td>
<td>Brill wave width (in eta) for extrinsic curveture</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>sigma_me</td>
<td>1.0</td>
<td>Brill wave width (in eta) for metric</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>byJ</td>
<td>0.0</td>
<td>Bowen and York Momenta</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>etamax</td>
<td>5.0</td>
<td>Eta value for outer edge of grid</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>n</td>
<td>3</td>
<td>sin**n theta in brill wave for extrinsic curveture</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>n_me</td>
<td>3</td>
<td>sin**n theta in brill wave for metric</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>neta</td>
<td>300</td>
<td>Eta resolution for solve</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>ntheta</td>
<td>50</td>
<td>Theta resolution for solve</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>brandt_seidel</td>
<td>"no"</td>
<td>Brand-Seidel initial data</td>
<td></td>
</tr>
<tr>
<td>sergio</td>
<td>"no"</td>
<td>Sergio initial data</td>
<td></td>
</tr>
<tr>
<td>verbose</td>
<td>"yes"</td>
<td></td>
<td></td>
</tr>
<tr>
<td>interpolation_order</td>
<td>1</td>
<td>Order for interpolation</td>
<td>1:3 :: "Choose between first, second, and third-order"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="rotatingdbhivp">RotatingDBHIVP</h3>
<p>Cactus Code Thorn RotatingDBHIVP
Authors    : Ryoji Takahashi 
CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<hr />
<p>This thorn does calculates initial data for a black hole distorted
by a non-axisymmetric odd parity perturbation </p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>kerr_slice</td>
<td>"no"</td>
<td>initial slice for kerr</td>
<td></td>
</tr>
<tr>
<td>kerr_shift</td>
<td>"no"</td>
<td>kerr shift</td>
<td></td>
</tr>
<tr>
<td>amp</td>
<td>0.1</td>
<td>Brill wave amplitude</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>eta0</td>
<td>0.0</td>
<td>Brill wave center (in eta coords)</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>sigma</td>
<td>1.0</td>
<td>Brill wave width (in eta)</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>byJ</td>
<td>1.0</td>
<td>Bowen York Angular momenta</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>mm</td>
<td>0.0</td>
<td>Azimuthal dependence factor</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>etamax</td>
<td>5.0</td>
<td>Eta value for outer edge of grid</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>neta</td>
<td>202</td>
<td>Eta resolution for solve</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>ntheta</td>
<td>54</td>
<td>Theta resolution for solve</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>nphi</td>
<td>5</td>
<td>Eta resolution for solve</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>"yes"</td>
<td></td>
<td></td>
</tr>
<tr>
<td>interpolation_order</td>
<td>1</td>
<td>Order for interpolation</td>
<td>1:3 :: "Choose between first, second, and third-order"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="idanalyticbh">IDAnalyticBH</h3>
<p>Cactus Code Thorn IDAnalyticBH
Author(s)    : Steve Brandt
               Carsten Gundlach
               Joan Masso
               Ed Seidel
               Paul Walker
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn calculates analytic initial data for the Einstein grid functions
(lapse, shift, metric, curv) for various black hole spacetimes:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>Schwarzschild black hole
2 Misner black holes placed on the z-axis
n Misner black holes placed in a circle in the x-y plane
Brill-Lindquist data
</pre></div>
</td></tr></table>

<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>mass</td>
<td>2.0</td>
<td>Mass of black hole</td>
<td>: :: "Not sure if it can be negative or not"<em>OR</em></td>
</tr>
<tr>
<td>a_Kerr</td>
<td>0.1</td>
<td>Angular momentum parameter of black hole</td>
<td>-1:1 :: "Between +1 and -1"<em>OR</em></td>
</tr>
<tr>
<td>mu</td>
<td>1.2</td>
<td>Misner mu value</td>
<td>0: :: "Non-negative"<em>OR</em></td>
</tr>
<tr>
<td>nmax</td>
<td>30</td>
<td>Number of terms to include for Misner series</td>
<td>0: :: "Non-negative"<em>OR</em></td>
</tr>
<tr>
<td>misner_nbh</td>
<td>1</td>
<td>Number of Misner black holes</td>
<td>1:10 :: "Not more than 10"<em>OR</em></td>
</tr>
<tr>
<td>bl_nbh</td>
<td>1</td>
<td>Number of Brill Lindquist black holes</td>
<td>1:4 :: "Between one and four holes implemented"<em>OR</em></td>
</tr>
<tr>
<td>bl_x0_1</td>
<td>0.0</td>
<td>x-position of 1<sup>st</sup> BL hole</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>bl_y0_1</td>
<td>0.0</td>
<td>y-position of 1<sup>st</sup> BL hole</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>bl_z0_1</td>
<td>0.0</td>
<td>z-position of 1<sup>st</sup> BL hole</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>bl_M_1</td>
<td>1.0</td>
<td>Mass of 1<sup>st</sup> BL hole</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>bl_x0_2</td>
<td>0.0</td>
<td>x-position of 2<sup>nd</sup> BL hole</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>bl_y0_2</td>
<td>0.0</td>
<td>y-position of 2<sup>nd</sup> BL hole</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>bl_z0_2</td>
<td>0.0</td>
<td>z-position of 2<sup>nd</sup> BL hole</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>bl_M_2</td>
<td>1.0</td>
<td>Mass of 2<sup>nd</sup> BL hole</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>bl_x0_3</td>
<td>0.0</td>
<td>x-position of 3nd BL hole</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>bl_y0_3</td>
<td>0.0</td>
<td>y-position of 3nd BL hole</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>bl_z0_3</td>
<td>0.0</td>
<td>z-position of 3nd BL hole</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>bl_M_3</td>
<td>1.0</td>
<td>Mass of 3<sup>rd</sup> BL hole</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>bl_x0_4</td>
<td>0.0</td>
<td>x-position of 4<sup>th</sup> BL hole</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>bl_y0_4</td>
<td>0.0</td>
<td>y-position of 4<sup>th</sup> BL hole</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>bl_z0_4</td>
<td>0.0</td>
<td>z-position of 4<sup>th</sup> BL hole</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>bl_M_4</td>
<td>1.0</td>
<td>Mass of 4<sup>th</sup> BL hole</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>epsilon</td>
<td>1.e-16</td>
<td>Fudge factor</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="meudon_mag_ns">Meudon_Mag_NS</h3>
<p>Cactus Code Thorn ID_Mag_NS
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Import LORENE Mag_NS magnetised neutron star initial data.</p>
<p>This thorn is one of three closely related thorns ID_Bin_BH,
ID_Bin_NS, and ID_Mag_NS which all import LORENE initial data.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>""</td>
<td>Input file name</td>
<td>"" :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="exact">Exact</h3>
<p>Cactus Code Thorn Exact
Authors    : Carsten Gundlach initially, plus many other authors.
Maintainer : Jonathan Thornburg <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<hr />
<h1 id="purpose-of-the-thorn_1">Purpose of the thorn</h1>
<p>The initial purpose of this thorn was the comparison of numerical
spacetimes against exact solutions.  One particular solution,
the boost-rotation-symmetric spacetimes, was the first application.</p>
<p>Later, the thorn developed as a reservoir for a variety of exact spacetimes,
some of them in different coordinate systems, and even some non-Einstein
spcetimes.  All of these exact spacetimes have been found useful for
testing different aspect of the code.  Since mamy different people have
contributed to this thorn by adding new exact solutions, you should expect
many different styles of coding here.</p>
<p>For more details see the comments in the param.ccl file, and the
documentation in the directory doc.  For instructions on how to add
a new model, see doc/how_to_add_a_new_model.</p>
<p>Note that the June 2002 revisions to this thorn included renaming
most of the parameters.  The perl script  par/convert-par.pl  will
convert old parameter files to use the new names, renaming the old
parameter files to ".par.bak" as backups.</p>
<h1 id="compilation">Compilation</h1>
<p>On some systems (notably the AEI Xeons using the Intel compilers) this
thorn only compiles if you use the Cactus (perl) preprocessor, i.e. you
need to configure with
   gmake foo-config CPP='$${PERL} <span><span class="MathJax_Preview"><span><span class="MathJax_Preview">{CCTK_HOME}/lib/sbin/cpp.pl'
(along with any other configuration options), or put the line
      CPP=</span><script type="math/tex">{CCTK_HOME}/lib/sbin/cpp.pl'
(along with any other configuration options), or put the line
      CPP=</script></span></span><script type="math/tex"><span><span class="MathJax_Preview">{CCTK_HOME}/lib/sbin/cpp.pl'
(along with any other configuration options), or put the line
      CPP=</span><script type="math/tex">{CCTK_HOME}/lib/sbin/cpp.pl'
(along with any other configuration options), or put the line
      CPP=</script></span></script></span>{PERL} $${CCTK_HOME}/lib/sbin/cpp.pl
in your ~/.cactus/config or other Cactus options file.</p>
<p>[Note by Erik Schnetter, 2005-05-15: The adivce above is outdated and
incorrect.  This issue is also treated in the Cactus FAQ.  Read it for
more information.]</p>
<p>This thorn is mostly written in Fortran 77, with a few files in C
and Fortran 90.  At present Fortran 90 is only used for the "arbitrary slice"
option (see the thorn guide for details).  If this option isn't needed,
then by changing a single line in  src/include/Exact.inc  (see the comments
there for details) you can #ifdef-out the Fortran 90 code, allowing the
rest of this thorn to be compiled on a system with no Fortran 90 compiler
available.</p>
<h1 id="copyright">Copyright</h1>
<p>As noted above, this code has been hacked on by many different people,
so its' copyright and licensing status is somewhat unclear.</p>
<p>Here is a (incomplete) list of authors and their wishes:</p>
<hr />
<p>Many of the individual metrics (you can find them by grepping in the
   header comments in the  src/metrics/  directory) are
   copyright (C) 2000-2003 by Dumitru "Mitica" Vulcanov <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#118;&#117;&#108;&#99;&#97;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#118;&#117;&#108;&#99;&#97;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<p>This code is under the same "GPL with exceptions for other thorns"
license as the Cactus flesh; see the file CACTUS.COPYRIGHT in this
directory for details.</p>
<hr />
<p>The new code added in the June 2002 revisions to this thorn
   is copyright (C) 2001-2002 by Jonathan Thornburg <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Minkowski_conf_wave and the conformal factor code added in January 2003
   is copyright (C) 2003 by Frank Loeffler <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#102;&#114;&#97;&#110;&#107;&#46;&#108;&#111;&#101;&#102;&#102;&#108;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#102;&#114;&#97;&#110;&#107;&#46;&#108;&#111;&#101;&#102;&#102;&#108;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Option to boost any non-stress-energy-tensor model
   is copyright (C) 2003 by Jonathan Thornburg <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<p>This code is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.</p>
<p>This code is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this thorn (see the file COPYING in this directory);
if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA</p>
<hr />
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>exblend_Ks</td>
<td>"yes"</td>
<td>Blend the K variables with the exact solution?</td>
<td></td>
</tr>
<tr>
<td>exblend_gs</td>
<td>"yes"</td>
<td>Blend the g variables with the exact solution?</td>
<td></td>
</tr>
<tr>
<td>exblend_gauge</td>
<td>"yes"</td>
<td>Blend the lapse and shift with the exact solution?</td>
<td></td>
</tr>
<tr>
<td>exblend_rout</td>
<td>-1.0</td>
<td>Outer boundary of blending region</td>
<td><em>:</em> :: "Positive means radial value, negative means use outer bound of grid"<em>OR</em></td>
</tr>
<tr>
<td>exblend_width</td>
<td>-3.0</td>
<td>Width of blending zone</td>
<td><em>:</em> :: "Positive means width in radius, negative means width = exbeldn_width*dx"<em>OR</em></td>
</tr>
<tr>
<td>slice_Gauss_ampl</td>
<td>0.0</td>
<td>Amplitude of Gauss slice in exact</td>
<td>0.0:* :: "Positive please"<em>OR</em></td>
</tr>
<tr>
<td>slice_Gauss_width</td>
<td>1.0</td>
<td>Width of Gauss slice in exact</td>
<td>0.0:* :: "Positive please"<em>OR</em></td>
</tr>
<tr>
<td>overwrite_boundary</td>
<td>"no"</td>
<td>Overwrite g and K on the boundary</td>
<td>"no"    :: "Do nothing"<em>OR</em>  "exact" :: "Use boundary data from an exact solution on a trivial slice"<em>OR</em></td>
</tr>
<tr>
<td>exact_order</td>
<td>2</td>
<td>finite differencing order</td>
<td>2 :: "2"<em>OR*4 :: "4"*OR</em></td>
</tr>
<tr>
<td>exact_eps</td>
<td>1.0e-6</td>
<td>finite differencing stencil size (in terms of the grid spacing)</td>
<td>(0.0:* :: "Positive please"<em>OR</em></td>
</tr>
<tr>
<td>boost_vx</td>
<td>0.0</td>
<td>x component of boost velocity</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>boost_vy</td>
<td>0.0</td>
<td>y component of boost velocity</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>boost_vz</td>
<td>0.0</td>
<td>z component of boost velocity</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>shift_add_x</td>
<td>0.0</td>
<td>x component of added shift</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>shift_add_y</td>
<td>0.0</td>
<td>y component of added shift</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>shift_add_z</td>
<td>0.0</td>
<td>z component of added shift</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>rotation_euler_phi</td>
<td>0.0</td>
<td>Euler angle phi (first rotation, about z axis) (irrelevant for axisymmetric models)</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>rotation_euler_theta</td>
<td>0.0</td>
<td>Euler angle theta (second rotation, about x axis)</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>rotation_euler_psi</td>
<td>0.0</td>
<td>Euler angle psi (third rotation, about z axis)</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>Schwarzschild_EF__mass</td>
<td>1.0</td>
<td>Schwarzschild/EF: BH mass</td>
<td>#  <em>:</em> :: "any real number"<em>OR</em>#</td>
</tr>
<tr>
<td>exact_model</td>
<td>"Minkowski"</td>
<td>The exact solution/coordinates used in thorn exact</td>
<td>#<em>OR</em># Minkowski spacetime*OR*#<em>OR</em>"Minkowski"                    :: "Minkowski spacetime"<em>OR</em>"Minkowski/shift"              :: "Minkowski spacetime with time-dependent shift vector"<em>OR</em>"Minkowski/funny"              :: "Minkowski spacetime in non-trivial spatial coordinates"<em>OR</em>"Minkowski/gauge wave"         :: "Minkowski spacetime in gauge-wave coordinates"<em>OR</em>"Minkowski/shifted gauge wave" :: "Minkowski spacetime in shifted gauge-wave coordinates"<em>OR</em>"Minkowski/conf wave"          :: "Minkowski spacetime with 'waves' in conformal factor"<em>OR</em>#<em>OR</em># black hole spacetimes*OR*#<em>OR</em>"Schwarzschild/EF"           :: "Schwarzschild spacetime in Eddington-Finkelstein coordinates"<em>OR</em>"Schwarzschild/PG"           :: "Schwarzschild spacetime in Painleve-Gullstrand coordinates"<em>OR</em>"Schwarzschild/BL"           :: "Schwarzschild spacetime in Brill-Lindquist coordinates"<em>OR</em>"Schwarzschild/Novikov"      :: "Schwarzschild spacetime in Novikov coordinates"<em>OR</em>"Schwarzschild-Lemaitre"     :: "Schwarzschild metric in Schwarzschild coordinates, with cosmological constant"<em>OR</em>"Kerr/Boyer-Lindquist"       :: "Kerr spacetime in Boyer-Lindquist coordinates"<em>OR</em>"Kerr/Kerr-Schild"           :: "Kerr spacetime in Kerr-Schild coordinates"<em>OR</em>"Kerr/Kerr-Schild/spherical" :: "Kerr spacetime in distorted Kerr-Schild coordinates such that the horizon is a coordinate sphere"<em>OR</em>"multi-BH"                   :: "Majumdar-Papapetrou or Kastor-Traschen maximally charged multi BH solutions"<em>OR</em>"Alvi"                       :: "Alvi post-Newtonian 2BH spacetime (not fully implemented yet)"<em>OR</em>"Thorne-fakebinary"          :: "Thorne's fake-binary spacetime (non-Einstein)"<em>OR</em>#<em>OR</em># cosmological spacetimes*OR*#<em>OR</em>"Lemaitre"              :: "Lemaitre-type spacetime"<em>OR</em>##"Robertson-Walker"      :: "Robertson-Walker spacetime"<em>OR</em>"de Sitter"             :: "de Sitter spacetime (R-W cosmology, near t=0, p=0)"<em>OR</em>"de Sitter+Lambda"      :: "de Sitter spacetime with cosmological constant"<em>OR</em>"anti-de Sitter+Lambda" :: "anti-de Sitter spacetime with cosmological constant"<em>OR</em>"Bianchi I"             :: "approximate Bianchi type I spacetime"<em>OR</em>"Goedel"                :: "Goedel spacetime"<em>OR</em>"Bertotti"              :: "Bertotti spacetime"<em>OR</em>"Kasner-like"           :: "Kasner-like spacetime"<em>OR</em>"Kasner-axisymmetric"   :: "axisymmetric Kasner spacetime"<em>OR</em>"Kasner-generalized"    :: "generalized Kasner spacetime"<em>OR</em>"Gowdy-wave"          :: "Gowdy spacetime with polarized wave on a torus"<em>OR</em>"Milne"                 :: "Milne spacetime for pre-big-bang cosmology"<em>OR</em>#<em>OR</em># miscelaneous spacetimes*OR*#<em>OR</em>"boost-rotation symmetric" :: "boost-rotation symmetric spacetime"<em>OR</em>"bowl"                     :: "bowl (bag-of-gold) spacetime (non-Einstein)"<em>OR</em>"constant density star"    :: "constant density (Schwarzschild) star"<em>OR</em></td>
</tr>
<tr>
<td>Minkowski_shift__amplitude</td>
<td>0.5</td>
<td>Minkowski/shift: amplitude of Gaussian</td>
<td>(-1:1) :: "any real number &lt; 1 in absolute value"<em>OR</em></td>
</tr>
<tr>
<td>Minkowski_shift__sigma</td>
<td>1.0</td>
<td>Minkowski/shift: width of Gaussian</td>
<td>(0.0:* :: "any real number &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>Minkowski_funny__amplitude</td>
<td>0.5</td>
<td>Minkowski/funny: amplitude of Gaussian</td>
<td>0.0:1.0) :: "any real number in the range [0,1)"<em>OR</em></td>
</tr>
<tr>
<td>Minkowski_funny__sigma</td>
<td>1.0</td>
<td>Minkowski/funny: width of Gaussian</td>
<td>(0.0: :: "any real number &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>Schwarzschild_EF__mass</td>
<td>1.0</td>
<td>Schwarzschild/EF: BH mass</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>Schwarzschild_EF__epsilon</td>
<td>1.e-16</td>
<td>Schwarzschild/EF: numerical fudge</td>
<td>0.0:* :: "any real number &gt;= 0.0"<em>OR</em></td>
</tr>
<tr>
<td>Schwarzschild_PG__mass</td>
<td>1.0</td>
<td>Schwarzschild/PG: BH mass</td>
<td>(0.0:* :: "any real number &gt; 0.0"<em>OR</em></td>
</tr>
<tr>
<td>Schwarzschild_PG__epsilon</td>
<td>1.e-16</td>
<td>Schwarzschild/PG: numerical fudge</td>
<td>0.0:* ::  "any real number &gt;= 0.0"<em>OR</em></td>
</tr>
<tr>
<td>Schwarzschild_BL__mass</td>
<td>1.0</td>
<td>Schwarzschild/BL: BH mass</td>
<td>(0.0:* :: "any real number &gt; 0.0"<em>OR</em></td>
</tr>
<tr>
<td>Schwarzschild_BL__epsilon</td>
<td>1.e-16</td>
<td>Schwarzschild/BL: numerical fudge</td>
<td>0.0:* :: "any real number &gt;= 0.0"<em>OR</em></td>
</tr>
<tr>
<td>Schwarzschild_Novikov__mass</td>
<td>1.0</td>
<td>Schwarzschild/Novikov: BH mass</td>
<td>(0.0:* :: "any real number &gt; 0.0"<em>OR</em></td>
</tr>
<tr>
<td>Schwarzschild_Novikov__epsilon</td>
<td>1.e-16</td>
<td>Schwarzschild/Novikov: numerical fudge</td>
<td>0.0:* :: "any real number &gt;= 0.0"<em>OR</em></td>
</tr>
<tr>
<td>Schwarzschild_Lemaitre__Lambda</td>
<td>1.0</td>
<td>Schwarzschild-Lemaitre: cosmological constant</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>Schwarzschild_Lemaitre__mass</td>
<td>1.0</td>
<td>Schwarzschild-Lemaitre: BH mass</td>
<td>(0.0:* :: "any real number &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>Kerr_BoyerLindquist__mass</td>
<td>1.0</td>
<td>Kerr/Boyer-Lindquist: BH mass</td>
<td>(0.0:* :: "any real number &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>Kerr_KerrSchild__boost_v</td>
<td>0.0</td>
<td>Kerr/Kerr-Schild: boost velocity of black hole in z direction</td>
<td>(-1:1) :: "any real number with absolute value &lt; 1"<em>OR</em></td>
</tr>
<tr>
<td>Kerr_KerrSchild__epsilon</td>
<td>1.e-16</td>
<td>Kerr/Kerr-Schild: numerical fudge</td>
<td>0.0:* :: "any real number &gt;= 0.0"<em>OR</em></td>
</tr>
<tr>
<td>Kerr_KerrSchild__power</td>
<td>4</td>
<td>Kerr/Kerr-Schild: power (exponent) of numerical fudge</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>Kerr_KerrSchild__parabolic</td>
<td>"no"</td>
<td>Kerr/Kerr-Schild: use a parabolic singularity-avoiding term</td>
<td></td>
</tr>
<tr>
<td>Kerr_KerrSchild__mass</td>
<td>1.0</td>
<td>Kerr/Kerr-Schild: BH mass</td>
<td>(0.0:* :: "any real number &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__nBH</td>
<td>0</td>
<td>multi-BH: number of black holes 0-4</td>
<td>0:4 :: "any integer in the range [0,4]"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__Hubble</td>
<td>0.0</td>
<td>multi-BH: Hubble constant = &plusmn; sqrt{Lambda/3}</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__mass1</td>
<td>0.0</td>
<td>multi-BH: mass of black hole number 1</td>
<td>0.0: :: "any real number &gt;= 0"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__x1</td>
<td>0.0</td>
<td>multi-BH: x coord of black hole number 1</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__y1</td>
<td>0.0</td>
<td>multi-BH: y coord of black hole number 1</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__z1</td>
<td>0.0</td>
<td>multi-BH: z coord of black hole number 1</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__mass2</td>
<td>0.0</td>
<td>multi-BH: mass of black hole number 2</td>
<td>0.0: :: "any real number &gt;= 0"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__x2</td>
<td>0.0</td>
<td>multi-BH: x coord of black hole number 2</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__y2</td>
<td>0.0</td>
<td>multi-BH: y coord of black hole number 2</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__z2</td>
<td>0.0</td>
<td>multi-BH: z coord of black hole number 2</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__mass3</td>
<td>0.0</td>
<td>multi-BH: mass of black hole number 3</td>
<td>0.0: :: "any real number &gt;= 0"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__x3</td>
<td>0.0</td>
<td>multi-BH: x coord of black hole number 3</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__y3</td>
<td>0.0</td>
<td>multi-BH: y coord of black hole number 3</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__z3</td>
<td>0.0</td>
<td>multi-BH: z coord of black hole number 3</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__mass4</td>
<td>0.0</td>
<td>multi-BH: mass of black hole number 4</td>
<td>0.0:* :: "any real number &gt;= 0"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__x4</td>
<td>0.0</td>
<td>multi-BH: x coord of black hole number 4</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__y4</td>
<td>0.0</td>
<td>multi-BH: y coord of black hole number 4</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>multi_BH__z4</td>
<td>0.0</td>
<td>multi-BH: z coord of black hole number 4</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>Alvi__mass1</td>
<td>1.0</td>
<td>Alvi: mass of BH number 1</td>
<td>0.0:* :: "any real number &gt;= 0"<em>OR</em></td>
</tr>
<tr>
<td>Alvi__mass2</td>
<td>1.0</td>
<td>Alvi: mass of BH number 2</td>
<td>0.0:* :: "any real number &gt;= 0"<em>OR</em></td>
</tr>
<tr>
<td>Alvi__separation</td>
<td>20.0</td>
<td>Alvi: spatial separation of the black holes</td>
<td>0.0:* :: "must be greater than m1+m2 + 2 sqrt(m1 m2)"<em>OR</em></td>
</tr>
<tr>
<td>Thorne_fakebinary__atype</td>
<td>"constant"</td>
<td>Thorne-fakebinary: binary type</td>
<td>"constant"   :: ""<em>OR</em>  "quadrupole" :: ""<em>OR</em></td>
</tr>
<tr>
<td>Thorne_fakebinary__retarded</td>
<td>"no"</td>
<td>Thorne-fakebinary: use retarded time?</td>
<td></td>
</tr>
<tr>
<td>Thorne_fakebinary__epsilon</td>
<td>1.e-16</td>
<td>Thorne-fakebinary: numerical fudge</td>
<td>0.0:* :: "any real number &gt;= 0.0"<em>OR</em></td>
</tr>
<tr>
<td>Thorne_fakebinary__separation</td>
<td>5.0</td>
<td>Thorne-fakebinary: initial separation</td>
<td>(0.0:* :: "any real number &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>Thorne_fakebinary__Omega0</td>
<td>1.0</td>
<td>Thorne-fakebinary: initial angular frequency</td>
<td>(0.0:* :: "any real number &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>Thorne_fakebinary__mass</td>
<td>1.0</td>
<td>Thorne-fakebinary: mass</td>
<td>(0.0:* :: "any real number &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>Lemaitre__kappa</td>
<td>-0.5</td>
<td>Lemaitre: multiplicative factor in equation of state</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>Lemaitre__Lambda</td>
<td>1.0</td>
<td>Lemaitre: cosmological constant</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>Lemaitre__epsilon0</td>
<td>1.0</td>
<td>Lemaitre: density of the universe at time t=0</td>
<td>0.0:* :: "any real number &gt;= 0"<em>OR</em></td>
</tr>
<tr>
<td>Lemaitre__R0</td>
<td>1.0</td>
<td>Lemaitre: scale factor (radius) of the universe at time t=0</td>
<td>(0.0:* :: "any positive real number"<em>OR</em></td>
</tr>
<tr>
<td>Robertson_Walker__rho</td>
<td>0.1</td>
<td>Robertson-Walker: density parameter</td>
<td>##0.0:* :: "any real number &gt;= 0"<em>OR</em>##</td>
</tr>
<tr>
<td>Robertson_Walker__k</td>
<td>0</td>
<td>Robertson-Walker: geometry type parameter</td>
<td>##-1:1:1 :: "one of the values -1, 0, 1"<em>OR</em>##</td>
</tr>
<tr>
<td>de_Sitter__scale</td>
<td>0.1</td>
<td>de Sitter: multiplicative scale factor</td>
<td>(0.0:* :: "any positive real number"<em>OR</em></td>
</tr>
<tr>
<td>de_Sitter_Lambda__scale</td>
<td>0.1</td>
<td>de Sitter+Lambda: multiplicative scale factor</td>
<td>(0.0:* :: "any positive real number"<em>OR</em></td>
</tr>
<tr>
<td>Bianchi_I__scale</td>
<td>0.1</td>
<td>Bianchi I: multiplicative scale factor</td>
<td>(0.0:* :: "any positive real number"<em>OR</em></td>
</tr>
<tr>
<td>Goedel__scale</td>
<td>0.1</td>
<td>Goedel: multiplicative scale factor</td>
<td>(0.0:* :: "any positive real number"<em>OR</em></td>
</tr>
<tr>
<td>Bertotti__Lambda</td>
<td>-1.0</td>
<td>Bertotti: cosmological constant</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>Kasner_like__q</td>
<td>0.66666666666666666666</td>
<td>Kasner-like: q parameter</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>Kasner_generalized__p1</td>
<td>0.1</td>
<td>Kasner-generalized: x exponent parameter</td>
<td>-1.0:1.0 :: "any real number in the range [-1,1]"<em>OR</em></td>
</tr>
<tr>
<td>Kasner_generalized__p2</td>
<td>0.1</td>
<td>Kasner-generalized: y exponent parameter</td>
<td>-1.0:1.0 :: "any real number in the range [-1,1]"<em>OR</em></td>
</tr>
<tr>
<td>Gowdy_wave__amplitude</td>
<td>0.0</td>
<td>Gowdy-wave: amplitude parameter</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>boost_rotation_symmetric__scale</td>
<td>1.0</td>
<td>boost-rotation symmetric: length scale</td>
<td>0.0:* :: "Positive please"<em>OR</em></td>
</tr>
<tr>
<td>bowl__shape</td>
<td>"Gaussian"</td>
<td>bowl: what shape of bowl should we use?</td>
<td>"Gaussian" :: "Gaussian bowl"<em>OR</em>  "Fermi"    :: "Fermi-function bowl"<em>OR</em></td>
</tr>
<tr>
<td>bowl__evolve</td>
<td>"false"</td>
<td>bowl: are we evolving the metric?</td>
<td></td>
</tr>
<tr>
<td>bowl__strength</td>
<td>0.5</td>
<td>bowl: deformation strength</td>
<td>0.0:* :: "any real number &gt;= 0"<em>OR</em></td>
</tr>
<tr>
<td>bowl__center</td>
<td>2.5</td>
<td>bowl: deformation center</td>
<td>(0.0:* :: "any positive real number"<em>OR</em></td>
</tr>
<tr>
<td>bowl__sigma</td>
<td>1.0</td>
<td>bowl: width of deformation</td>
<td>(0.0:* :: "any positive real number"<em>OR</em></td>
</tr>
<tr>
<td>bowl__x_scale</td>
<td>1.0</td>
<td>bowl: scale for x coordinate</td>
<td>(0.0:* :: "any positive real number"<em>OR</em></td>
</tr>
<tr>
<td>bowl__y_scale</td>
<td>1.0</td>
<td>bowl: scale for y coordinate</td>
<td>(0.0:* :: "any positive real number"<em>OR</em></td>
</tr>
<tr>
<td>bowl__z_scale</td>
<td>1.0</td>
<td>bowl: scale for z coordinate</td>
<td>(0.0:* :: "any positive real number"<em>OR</em></td>
</tr>
<tr>
<td>bowl__t0</td>
<td>1.0</td>
<td>bowl: center of Fermi step in time</td>
<td><em>:</em> :: "any real number"<em>OR</em></td>
</tr>
<tr>
<td>bowl__sigma_t</td>
<td>1.0</td>
<td>bowl: width of Fermi step in time</td>
<td>(0.0:* :: "any positive real number"<em>OR</em></td>
</tr>
<tr>
<td>constant_density_star__mass</td>
<td>1.0</td>
<td>constant density star: mass of star</td>
<td>(0.0:* :: "any positive real number"<em>OR</em></td>
</tr>
<tr>
<td>constant_density_star__radius</td>
<td>1.0</td>
<td>constant density star: radius of star</td>
<td>(0.0:* :: "any positive real number"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="hydro_initexcision">Hydro_InitExcision</h3>
<p>Cactus Code Thorn Hydro_InitExcision
Author(s)    : Andrea Nerozzi
               Frank Löffler
Maintainer(s): Frank Löffler
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Setup initial excision masks specified by parameters for testing.</p>
<ol>
<li>History</li>
</ol>
<p>This thorn was developed within the Whisky code under the name
Whisky_InitExcision, was made public by the group of Whisky
developers and was then included in the EinsteinToolkit using its
present name, because it is independend of any hydro evolution code,
as long as that uses HydroBase.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>hydro_initexcision_old_mask</td>
<td>0</td>
<td>Also set the old 'emask'?</td>
<td>0:1 :: "0 (default) for no, 1 for yes"<em>OR</em></td>
</tr>
<tr>
<td>hydro_initexcision_flip</td>
<td>0</td>
<td>Exchange excised and normal region</td>
<td>0:1 :: "0 (default) for no, 1 for yes"<em>OR</em></td>
</tr>
<tr>
<td>hydro_initexcision_fraction</td>
<td>0.25</td>
<td>Fraction of excised region</td>
<td>0:1      :: "Represents the fraction of excised region (0..1)"<em>OR</em></td>
</tr>
<tr>
<td>hydro_initexcision_coordinate_length</td>
<td>0</td>
<td>Length of excised region</td>
<td>0:  :: "Length of excised region, has different meanings for the types"<em>OR</em></td>
</tr>
<tr>
<td>hydro_initexcision_position_x</td>
<td>0.0</td>
<td>x-coordinate</td>
<td>: :: "anything real is ok"<em>OR</em></td>
</tr>
<tr>
<td>hydro_initexcision_position_y</td>
<td>0.0</td>
<td>y-coordinate</td>
<td>: :: "anything real is ok"<em>OR</em></td>
</tr>
<tr>
<td>hydro_initexcision_position_z</td>
<td>0.0</td>
<td>z-coordinate</td>
<td>: :: "anything real is ok"<em>OR</em></td>
</tr>
<tr>
<td>hydro_initexcision_min_points</td>
<td>0</td>
<td>minimal number of points of excision</td>
<td>0: :: "minimal number of points of excision, currently only partly implemented"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="meudon_bin_bh">Meudon_Bin_BH</h3>
<p>Cactus Code Thorn ID_Bin_BH
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Import LORENE Bin_BH binary black hole initial data.</p>
<p>This thorn is one of three closely related thorns ID_Bin_BH,
ID_Bin_NS, and ID_Mag_NS which all import LORENE initial data.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename</td>
<td>""</td>
<td>Input file name</td>
<td>"" :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="idbrilldata">IDBrillData</h3>
<p>Cactus Code Thorn IDBrillData
Author(s)    : Carsten Gundlach
               Miguel Alcubierre
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Initializes Brill wave data.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>solver</td>
<td>"sor"</td>
<td>Which elliptic solver to use</td>
<td>"sor"    ::  "Use SOR solver"<em>OR</em>  "petsc"  ::  "Use PETSc solver"<em>OR</em>  "bam"    ::  "Use bam solver"<em>OR</em></td>
</tr>
<tr>
<td>bound</td>
<td>"robin"</td>
<td>Which boundary condition to use</td>
<td>"const" :: "constant boundary: set const_v0"<em>OR</em>  "robin" :: "Robin boundary: set robin_falloff, robin_inf"<em>OR</em></td>
</tr>
<tr>
<td>robin_falloff</td>
<td>1</td>
<td>Fall-off of Robin BC</td>
<td>0: :: "any positive integer value"<em>OR</em></td>
</tr>
<tr>
<td>const_v0</td>
<td>1.0</td>
<td>Value of constant BC</td>
<td>: :: "anything goes"<em>OR</em></td>
</tr>
<tr>
<td>robin_inf</td>
<td>1.0</td>
<td>Value at infinity of Robin BC</td>
<td>: :: "anything goes"<em>OR</em></td>
</tr>
<tr>
<td>thresh</td>
<td>0.00001</td>
<td>How far (absolute norm) to go</td>
<td>0.0: :: "Positive number please"<em>OR</em></td>
</tr>
<tr>
<td>exp_a</td>
<td>0.0</td>
<td>Exp Brill wave: Amplitude</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>exp_b</td>
<td>2</td>
<td>Exp Brill wave: used in exponent in rho: rho^(2+b)</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>exp_rho0</td>
<td>0.0</td>
<td>Exp Brill wave: radius of torus in rho</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>exp_sigmaz</td>
<td>1.0</td>
<td>Exp Brill wave: sigma in z</td>
<td>(0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>eppley_a</td>
<td>0.0</td>
<td>Eppley Brill wave: Amplitude</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>eppley_b</td>
<td>2</td>
<td>Eppley Brill wave: used in exponent in rho: rho^b</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>eppley_c</td>
<td>0.0</td>
<td>Eppley Brill wave: (r^2 - r0<sup>2)</sup>(c/2)</td>
<td>0:* :: "Positive" <em>OR</em></td>
</tr>
<tr>
<td>eppley_sigmarho</td>
<td>1.0</td>
<td>Eppley Brill wave: sigma in rho</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>eppley_sigmar</td>
<td>1.0</td>
<td>Eppley Brill wave: sigma in r</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>gundlach_a</td>
<td>0.0</td>
<td>Gundlach Brill wave: Amplitude</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>gundlach_b</td>
<td>2</td>
<td>Gundlach Brill wave: used in exponent in rho: rho^b</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>gundlach_sigmarho</td>
<td>1.0</td>
<td>Gundlach Brill wave: sigma in rho</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>gundlach_r0</td>
<td>0.0</td>
<td>Gundlach Brill wave: radius of torus in r</td>
<td>0:* :: "Positive" <em>OR</em></td>
</tr>
<tr>
<td>gundlach_c</td>
<td>1.0</td>
<td>Gundlach Brill wave: (r^2 - r0<sup>2)</sup>(c/2)</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>brill3d_d</td>
<td>0.0</td>
<td>3D Brill wave:  d rho^m cos^2(n (phi + phi0))</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>brill3d_e</td>
<td>1.0</td>
<td>3D Brill wave:  d rho^m cos^2(n (phi + phi0))</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>brill3d_m</td>
<td>2.0</td>
<td>3D Brill wave:  d rho^m cos^2(n (phi + phi0))</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>brill3d_n</td>
<td>2.0</td>
<td>3D Brill wave:  d rho^m cos^2(n (phi + phi0))</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>brill3d_phi0</td>
<td>0.0</td>
<td>3D Brill wave:  d rho^m cos^2(n (phi + phi0))</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>rhofudge</td>
<td>0.00001</td>
<td>delta rho for axis fudge</td>
<td>0: :: "Positive please"<em>OR</em></td>
</tr>
<tr>
<td>sor_maxit</td>
<td>10000</td>
<td>Maximum number of iterations</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
</tbody>
</table>
<h2 id="ctthorns">CTThorns</h2>
<h3 id="ct_analytic">CT_Analytic</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>0</td>
<td>verbose</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>other_timelevels</td>
<td>1</td>
<td>Number of active timelevels for non-evolved grid functions</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>kx</td>
<td>0</td>
<td>Wavelength parameter along x</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ky</td>
<td>0</td>
<td>Wavelength parameter along y</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>kz</td>
<td>0</td>
<td>Wavelength parameter along z</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ampG</td>
<td>0</td>
<td>Coefficient of the gaussian term in the exact solution</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ampS</td>
<td>0</td>
<td>Coefficient of the sine term in the exact solution</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ampC</td>
<td>0</td>
<td>Constant coefficient in the exact solution</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ampI</td>
<td>0</td>
<td>Multiplication factor between initial guess and exact solution</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ampC1</td>
<td>0</td>
<td>Initial value for testc1</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ampSg</td>
<td>0</td>
<td>Coefficient of the 1/r term in the exact solution</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ampV</td>
<td>0</td>
<td>Coefficient of the vector part in the exact solution</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ampVG</td>
<td>0</td>
<td>Coefficient of the vector part in the exact solution (gaussian term)</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>sigma</td>
<td>1</td>
<td>Width of transition function in extrinsic curvature</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>l</td>
<td>0</td>
<td>Location of transition function in extrinsic curvature</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>phasex</td>
<td>0</td>
<td>Phase in the initial data for psi along x</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>phasey</td>
<td>0</td>
<td>Phase in the initial data for psi along y</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>phasez</td>
<td>0</td>
<td>Phase in the initial data for psi along z</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Kc</td>
<td>0</td>
<td>Coefficient of extrinsic curvature</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Ke</td>
<td>0</td>
<td>Coefficient of extrinsic curvature in exact solution</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>massa</td>
<td>0</td>
<td>mass of first black hole</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>massb</td>
<td>0</td>
<td>mass of second black hole</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>xa</td>
<td>0</td>
<td>x-coordinate of first black hole for BY initial data</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ya</td>
<td>0</td>
<td>y-coordinate of first black hole for BY initial data</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>za</td>
<td>0</td>
<td>z-coordinate of first black hole for BY initial data</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>xb</td>
<td>0</td>
<td>x-coordinate of second black hole for BY initial data</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>yb</td>
<td>0</td>
<td>y-coordinate of second black hole for BY initial data</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>zb</td>
<td>0</td>
<td>z-coordinate of second black hole for BY initial data</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Pax</td>
<td>0</td>
<td>x-component of linear momentum of first black hole for BY initial data</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Pay</td>
<td>0</td>
<td>y-component of linear momentum of first black hole for BY initial data</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Paz</td>
<td>0</td>
<td>z-component of linear momentum of first black hole for BY initial data</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Pbx</td>
<td>0</td>
<td>x-component of linear momentum of second black hole for BY initial data</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Pby</td>
<td>0</td>
<td>y-component of linear momentum of second black hole for BY initial data</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Pbz</td>
<td>0</td>
<td>z-component of linear momentum of second black hole for BY initial data</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>eps</td>
<td>1.e-6</td>
<td>Smoothing factor</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>edgeL</td>
<td>10</td>
<td>Coordinate length of cell edge</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>rBall</td>
<td>1</td>
<td>Coordinate radius of ball of density for Poisson's equation</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>vecA</td>
<td>1</td>
<td>Coordinate center of gaussian representing the X^i vector in the CTT decomposition of the constraints</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>imaxF</td>
<td>1</td>
<td>Max number of Fourier modes to include in x direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>jmaxF</td>
<td>1</td>
<td>Max number of Fourier modes to include in y direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>kmaxF</td>
<td>1</td>
<td>Max number of Fourier modes to include in z direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>tile_size</td>
<td>-1</td>
<td>Loop tile size</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>free_data</td>
<td>"exact"</td>
<td>How to set the free data for the extrinsic curvature?</td>
<td>"exact" :: ""<em>OR</em>  "Expanding BH lattice" :: ""<em>OR</em>  "Bowen-York" :: ""<em>OR</em>  "Poisson" :: ""<em>OR</em>  "Lump" :: ""<em>OR</em></td>
</tr>
<tr>
<td>CT_Analytic_MaxNumEvolvedVars</td>
<td>0</td>
<td>Number of evolved variables used by this thorn</td>
<td>0:0 :: "Number of evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>CT_Analytic_MaxNumArrayEvolvedVars</td>
<td>0</td>
<td>Number of Array evolved variables used by this thorn</td>
<td>0:0 :: "Number of Array evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>timelevels</td>
<td>3</td>
<td>Number of active timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>rhs_timelevels</td>
<td>1</td>
<td>Number of active RHS timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>CT_Analytic_Poisson_Calc_calc_every</td>
<td>1</td>
<td>CT_Analytic_Poisson_Calc_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>CT_Analytic_Exact_Calc_calc_every</td>
<td>1</td>
<td>CT_Analytic_Exact_Calc_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>CT_Analytic_ExpandingLattice_Calc_calc_every</td>
<td>1</td>
<td>CT_Analytic_ExpandingLattice_Calc_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>CT_Analytic_BY_Calc_calc_every</td>
<td>1</td>
<td>CT_Analytic_BY_Calc_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>CT_Analytic_Lump_Calc_calc_every</td>
<td>1</td>
<td>CT_Analytic_Lump_Calc_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>CT_Analytic_ExactBoundary_calc_every</td>
<td>1</td>
<td>CT_Analytic_ExactBoundary_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>CT_Analytic_LumpBoundary_calc_every</td>
<td>1</td>
<td>CT_Analytic_LumpBoundary_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>CT_Analytic_Poisson_Calc_calc_offset</td>
<td>0</td>
<td>CT_Analytic_Poisson_Calc_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>CT_Analytic_Exact_Calc_calc_offset</td>
<td>0</td>
<td>CT_Analytic_Exact_Calc_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>CT_Analytic_ExpandingLattice_Calc_calc_offset</td>
<td>0</td>
<td>CT_Analytic_ExpandingLattice_Calc_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>CT_Analytic_BY_Calc_calc_offset</td>
<td>0</td>
<td>CT_Analytic_BY_Calc_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>CT_Analytic_Lump_Calc_calc_offset</td>
<td>0</td>
<td>CT_Analytic_Lump_Calc_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>CT_Analytic_ExactBoundary_calc_offset</td>
<td>0</td>
<td>CT_Analytic_ExactBoundary_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>CT_Analytic_LumpBoundary_calc_offset</td>
<td>0</td>
<td>CT_Analytic_LumpBoundary_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="ct_multilevel">CT_MultiLevel</h3>
<p>Cactus Code Thorn CT_MultiLevel
Author(s)    : Eloisa Bentivegna <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#108;&#111;&#105;&#115;&#97;&#46;&#98;&#101;&#110;&#116;&#105;&#118;&#101;&#103;&#110;&#97;&#64;&#117;&#110;&#105;&#99;&#116;&#46;&#105;&#116;">&#101;&#108;&#111;&#105;&#115;&#97;&#46;&#98;&#101;&#110;&#116;&#105;&#118;&#101;&#103;&#110;&#97;&#64;&#117;&#110;&#105;&#99;&#116;&#46;&#105;&#116;</a>
Maintainer(s): Eloisa Bentivegna <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#108;&#111;&#105;&#115;&#97;&#46;&#98;&#101;&#110;&#116;&#105;&#118;&#101;&#103;&#110;&#97;&#64;&#117;&#110;&#105;&#99;&#116;&#46;&#105;&#116;">&#101;&#108;&#111;&#105;&#115;&#97;&#46;&#98;&#101;&#110;&#116;&#105;&#118;&#101;&#103;&#110;&#97;&#64;&#117;&#110;&#105;&#99;&#116;&#46;&#105;&#116;</a>
Copyright    : Eloisa Bentivegna, 2013-2016
Licence      : GPLv3+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn implements a multigrid solver for systems of elliptic PDEs.
It uses Carpet to manage the different grids and the transfer of data
between them. The solver is generic -- the system of equations to solve
is defined at runtime by setting its coefficients via external grid
functions. </p>
<p>Some examples are discussed in gr-qc/1305.5576.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>mode</td>
<td>"generic"</td>
<td>Which equation should we solve?</td>
<td>"generic" :: "Generic elliptic operator, to be defined via the coefficients"<em>OR</em>  "constraints" :: "The GR constraints"<em>OR</em></td>
</tr>
<tr>
<td>model</td>
<td>"None"</td>
<td>Model used to populate the auxiliary functions</td>
<td>"Bowen-York"                       :: "Bowen-York extrinsic curvature for multiple punctures"<em>OR</em>  "Expanding BH lattice"             :: "An expanding black-hole lattice"<em>OR</em>  "Lump"                             :: "Generic compact source in Tmunu"<em>OR</em>  "Inhomogeneous Helmholtz"          :: "Inhomogeneous Helmholtz equation"<em>OR</em>  "None"                             :: "No auxiliaries needed"<em>OR</em></td>
</tr>
<tr>
<td>cycle_type</td>
<td>"V</td>
<td>How should be cycle over the refinement levels?</td>
<td>"V cycle"   :: "A V cycle"<em>OR</em>  "FMG cycle" :: "A FMG cycle"<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Output debugging information?</td>
<td>"no" :: "no"<em>OR</em>  "yes" :: "yes"<em>OR</em></td>
</tr>
<tr>
<td>veryverbose</td>
<td>"no"</td>
<td>Output more debugging information?</td>
<td>"no" :: "no"<em>OR</em>  "yes" :: "yes"<em>OR</em></td>
</tr>
<tr>
<td>output_norms</td>
<td>"no"</td>
<td>Output the norms of psi and residual, and those of their errors?</td>
<td>"no" :: "no"<em>OR</em>  "yes" :: "yes"<em>OR</em></td>
</tr>
<tr>
<td>compare_to_exact</td>
<td>"no"</td>
<td>Output a file with the difference between the solution at each iteration and the exact solution, if known</td>
<td>"no" :: "no"<em>OR</em>  "yes" :: "yes"<em>OR</em></td>
</tr>
<tr>
<td>output_walk</td>
<td>"no"</td>
<td>Output a file with the parameter-space walk followed by the algorithm?</td>
<td>"no" :: "no"<em>OR</em>  "yes" :: "yes"<em>OR</em></td>
</tr>
<tr>
<td>fill_ADM</td>
<td>"no"</td>
<td>Should the equation solution be used to fill the ADM variables?</td>
<td>"no" :: "no"<em>OR</em>  "yes" :: "yes"<em>OR</em></td>
</tr>
<tr>
<td>boundary_conditions</td>
<td>"none"</td>
<td>Which boundary conditions to apply to psi</td>
<td>"Robin"        :: "Robin"<em>OR</em>  "TwoPunctures" :: "Dirichlet BCs from TwoPunctures"<em>OR</em>  "none"         :: "This thorn will apply no boundary conditions"<em>OR</em></td>
</tr>
<tr>
<td>exact_offset</td>
<td>0.0</td>
<td>Offset between exact solution and grid function pointed by exact_solution_gfname</td>
<td><em>:</em>  :: "Any real number"<em>OR</em></td>
</tr>
<tr>
<td>fd_order</td>
<td>2</td>
<td>Order of FD</td>
<td>2:4:2   :: "Order of differencing"<em>OR</em></td>
</tr>
<tr>
<td>number_of_equations</td>
<td>1</td>
<td>How many equations are to be solved concurrently?</td>
<td>1:10    :: "A positive integer smaller than or equal to 10"<em>OR</em></td>
</tr>
<tr>
<td>number_of_auxiliaries</td>
<td>0</td>
<td>How many auxiliary functions do we need?</td>
<td>0:      :: "A non-negative integer"<em>OR</em></td>
</tr>
<tr>
<td>nrelsteps_up</td>
<td>2</td>
<td>How many times should we relax each level inside the upward leg of a cycle?</td>
<td>0:      :: "Any non-negative integer"<em>OR</em></td>
</tr>
<tr>
<td>nrelsteps_down</td>
<td>2</td>
<td>How many times should we relax each level inside the downward leg of a cycle?</td>
<td>0:      :: "Any non-negative integer"<em>OR</em></td>
</tr>
<tr>
<td>nrelsteps_bottom</td>
<td>2</td>
<td>How many times should we relax each level at the bottom of a cycle?</td>
<td>0:      :: "Any non-negative integer"<em>OR</em></td>
</tr>
<tr>
<td>nrelsteps_top</td>
<td>2</td>
<td>How many times should we relax each level at the top of a cycle?</td>
<td>0:      :: "Any non-negative integer"<em>OR</em></td>
</tr>
<tr>
<td>integral_refinement</td>
<td>1</td>
<td>How much to refine the grid via interpolation before calculating integrals</td>
<td>1:*   :: "Any integer greater than zero"<em>OR</em></td>
</tr>
<tr>
<td>tol</td>
<td>1e-06</td>
<td>Maximum residual tolerated</td>
<td>0:* ::  "Any non-negative real"<em>OR</em></td>
</tr>
<tr>
<td>eps</td>
<td>1e-06</td>
<td>Regularization factor at the punctures</td>
<td>0:* ::  "Any non-negative real"<em>OR</em></td>
</tr>
<tr>
<td>omega</td>
<td>1</td>
<td>Overrelaxation factor</td>
<td>0:2 ::  "Real larger than zero and smaller than 2"<em>OR</em></td>
</tr>
<tr>
<td>reset_psi</td>
<td>"no"</td>
<td>Reset psi after each relaxation step? How?</td>
<td>"no"                    :: "Do not reset"<em>OR</em>  "to value"              :: "Reset to the value specified by reset_value"<em>OR</em>  "through integrability" :: "Reset so that the integrability condition is satisfied"<em>OR</em></td>
</tr>
<tr>
<td>reset_every</td>
<td>1</td>
<td>How often should we reset psi?</td>
<td>1:*   :: "Any positive integer"<em>OR</em></td>
</tr>
<tr>
<td>reset_x</td>
<td>0</td>
<td>x-coordinate of point of reference for variable resetting</td>
<td>: ::  "Any real number (contained in the domain!)"<em>OR</em></td>
</tr>
<tr>
<td>reset_y</td>
<td>0</td>
<td>y-coordinate of point of reference for variable resetting</td>
<td>: ::  "Any real number (contained in the domain!)"<em>OR</em></td>
</tr>
<tr>
<td>reset_z</td>
<td>0</td>
<td>z-coordinate of point of reference for variable resetting</td>
<td>: ::  "Any real number (contained in the domain!)"<em>OR</em></td>
</tr>
<tr>
<td>enforce_int</td>
<td>0</td>
<td>Enforce the integral compatibility condition?</td>
<td>0:1:1 :: "True or false"<em>OR</em></td>
</tr>
<tr>
<td>topMGlevel</td>
<td>0</td>
<td>Finest level that covers the entire domain</td>
<td>0:      :: "Any non-negative integer (&lt; Carpet::reflevels!)"<em>OR</em></td>
</tr>
<tr>
<td>fill_Aij</td>
<td>"Analytic</td>
<td>Where does the final Aij come from?</td>
<td>"Solver"       :: "Aij is solved for as well"<em>OR</em>  "Analytic Xi"  :: "Aij comes from differentiating an analytic Xi"<em>OR</em>  "Analytic Aij" :: "Aij comes from an exact solution"<em>OR</em></td>
</tr>
</tbody>
</table>
<h2 id="cactusconnect">CactusConnect</h2>
<h3 id="httpdextra">HTTPDExtra</h3>
<p>Cactus Code Thorn HTTPDExtra
Author(s)    : Gabrielle Allen
               Tom Goodale
               Thomas Radke
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn registers additional HTML pages with the web server provided by
thorn HTTPD.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>viewport_refresh_seconds</td>
<td>-1</td>
<td>Viewport web page refresh time seconds</td>
<td>-1:      :: "-1 for no refresh, 0 for immediate refresh"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="httpd">HTTPD</h3>
<p>Cactus Code Thorn HTTPD
Author(s)    : Gabrielle Allen
               Tom Goodale
               Thomas Radke
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This is a prototype C version of a web server thorn.  </p>
<p>[Note that it has not been audited against buffer overruns or other
security problems, so please be aware that it is possible that someone
could exploit this server to access your machine if you run the server
on an open network.]</p>
<h2 id="usage">Usage:</h2>
<h2 id="interface">Interface:</h2>
<p>The current interface for this webserver is contained in</p>
<p>http_Request.h</p>
<p>(Note that this will change once we have an agreed common protocol for
other thorns to talk to web-serving thorns.)  There are also utility
interface for parameter steering and HTTP authentication, which are
described in the files in the doc directory.</p>
<p>The primary mechanism is to</p>
<p>HTTP_RegisterPage(path, function, data)</p>
<p>where 'path' is the URI you want to register, e.g.</p>
<p>/parameters</p>
<p>'function' is a function of the form</p>
<p>int foo(const cGH *cctkGH, httpRequest *request, void *data)</p>
<p>which will be called when the page is accessed, with 'data' being the
same data pointer that was passed into the registration routine.</p>
<p>Note that a request of the form '/foo/bar/' will look for a page of
the called '/foo/var/index.html' first, followed by '/foo/bar',
followed by '/foo' followed by '/'.</p>
<p>The httpRequest structure contains various pieces of information -</p>
<p>request-&gt;body               The body of the http request.  This is
                            empty for a GET.</p>
<p>request-&gt;body_length        The length of the body.</p>
<p>request-&gt;method             The http method.
request-&gt;uri                The full URI of the request.
request-&gt;residual           The URI remaining after the registered URI 
                            is removed from it.</p>
<p>request-&gt;http_major_version The major version of the HTTP protocol
                            used.</p>
<p>request-&gt;http_minor_version The minor version of the HTTP protocol
                            used.</p>
<p>request-&gt;n_arguments        The number of arguments passed to the
                            request.</p>
<p>All other members of the structure should be considered opaque.</p>
<p>To get details of arguments or HTTP header lines, the functions</p>
<p>const char *HTTP_ArgumentValue(const httpRequest *request, 
                               const char *arg);</p>
<p>const char *HTTP_HeaderValue(const httpRequest *request, 
                             const char *header);</p>
<p>may be used.  Given the name of a header field or an argument, these
functions will return the corresponding value, or NULL if the argument 
or header does not exist.</p>
<p>There is also a function</p>
<p>const httpArg *HTTP_ArgumentWalk(httpRequest *request, int first);</p>
<p>which will walk through all the arguments passed to a page.  If
'first' is true it will start with the first argument, otherwise it
will start with the next argument after the last one queried.
Currently this is the only way to get arguments which are passed in
more than once.  The httpArg structure contains two public variables</p>
<p>arg                      The name of the argument.
value                    The value of the argument.</p>
<h2 id="writing-to-the-browser">Writing to the browser:</h2>
<p>This is done with the </p>
<p>HTTP_Write(httpRequest *request, const char *buffer, size_t count);</p>
<p>function.  This takes three arguments - the request, a buffer, and the
length of the buffer.</p>
<p>The first line sent to the browser should be</p>
<p>HTTP_Write(request, "HTTP/1.0 200 OK\r\n",19)</p>
<p>(or an error code, e.g. "404 Not Found").  This should be followed by
any HTTP headers, such as "Content-Type", followed by "\r\n\r\n" and
then the content of your page, or at least that's what the standard
says 8-).  You may make as many calls to this function as you like to
get the data to the browser.</p>
<h2 id="examples">Examples:</h2>
<p>For examples of how to use the interface, please look at the Content.c 
file.</p>
<h2 id="structure-of-the-thorn">Structure of the thorn:</h2>
<p>The thorn is split into three parts - basic web serving, utilities,
and content provision</p>
<h2 id="web-serving">Web serving:</h2>
<p>The web server capabilities are held in</p>
<p>Sockets.c           - basic socket utilities;  these should be
                      replaced by or moved to the Socket thorn.</p>
<p>Server.c            - Stuff to register and serve pages.</p>
<p>http.c              - Parsing of HTTP requests.</p>
<p>Startup.c           - normal scheduled stuff.</p>
<p>The above files should not need to be touched apart from debugging
purposes, to add more HTTP methods, or otherwise to enhance the
interaction with the network and protocols.</p>
<p>Utilities:</p>
<hr />
<p>The web server provided utilities to help content provision -</p>
<p>Steer.c             - parameter steering interface
                    - see doc/Steering.txt</p>
<p>Authorisation.c     - HTTP authentication
                    - see doc/Auth.txt</p>
<h2 id="content-provision">Content Provision:</h2>
<p>The content provision is currently  in </p>
<p>Headers.c</p>
<p>Content.c</p>
<p>Groups.c</p>
<p>Parameters.c</p>
<p>This makes use of the interfaces in http_Request.h described above to
provide content.  In principle this could be in another thorn, but
that should wait until we have an agreed set of interfaces to allow
web-server thorns to be interchangeable, at least at compile time, but 
hopefully at run-time.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>port</td>
<td>5555</td>
<td>HTTP port number to use (can be overridden by shell variable HTTPD_PORT)</td>
<td>1:65535 :: "Any valid port"<em>OR</em></td>
</tr>
<tr>
<td>hunt</td>
<td>"yes"</td>
<td>Should the server hunt for a port if the specified one is taken ?</td>
<td></td>
</tr>
<tr>
<td>steering_frequency</td>
<td>1</td>
<td>How many iterations between steering events</td>
<td>0:  :: "Any number, 0 means don't steer"<em>OR</em></td>
</tr>
<tr>
<td>provide_pages</td>
<td>"yes"</td>
<td>Should the server provide any pages ?</td>
<td></td>
</tr>
<tr>
<td>pause</td>
<td>"no"</td>
<td>Pause ?</td>
<td></td>
</tr>
<tr>
<td>user</td>
<td>"anon"</td>
<td>The username for Cactus Control</td>
<td>".+" :: "Any name of one or more characters"<em>OR</em></td>
</tr>
<tr>
<td>password</td>
<td>"anon"</td>
<td>The password for Cactus Control</td>
<td>".<em>" :: "Any password"*OR</em></td>
</tr>
<tr>
<td>encryption_scheme</td>
<td>"none"</td>
<td>How the password is encrypted</td>
<td>"none"  :: "Not encrypted"<em>OR</em>  "crypt" :: "crypt(3) (standard UNIX passwd format)"<em>OR</em></td>
</tr>
<tr>
<td>use_pthreads</td>
<td>"yes"</td>
<td>Use a threaded implementation if possible ?</td>
<td></td>
</tr>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Print information about HTTP requests</td>
<td></td>
</tr>
<tr>
<td>timeout_seconds</td>
<td>0</td>
<td>Polling timeout seconds</td>
<td>0:      :: "Any whole number"<em>OR</em></td>
</tr>
<tr>
<td>timeout_useconds</td>
<td>0</td>
<td>Polling timeout micro-seconds</td>
<td>0:      :: "Any whole number"<em>OR</em></td>
</tr>
<tr>
<td>queue_length</td>
<td></td>
<td>Listen queue length</td>
<td>1:      :: "Any positive number"<em>OR</em></td>
</tr>
<tr>
<td>refresh_seconds</td>
<td>-1</td>
<td>Page refresh time seconds</td>
<td>-1:      :: "-1 for no refresh, 0 for immediate refresh"<em>OR</em></td>
</tr>
<tr>
<td>terminate</td>
<td>"no"</td>
<td>Kill the simulation ?</td>
<td></td>
</tr>
<tr>
<td>single_step</td>
<td>"no"</td>
<td>Do one step then pause ?</td>
<td></td>
</tr>
<tr>
<td>until_it_active</td>
<td>"no"</td>
<td>Use until_it parameter ?</td>
<td></td>
</tr>
<tr>
<td>until_it</td>
<td>0</td>
<td>Pause at this iteration</td>
<td>: :: "Any iteration"<em>OR</em></td>
</tr>
<tr>
<td>until_time_active</td>
<td>"no"</td>
<td>Use until_time parameter ?</td>
<td></td>
</tr>
<tr>
<td>until_time</td>
<td>0</td>
<td>Pause after this simulation time</td>
<td>: :: "Any time"<em>OR</em></td>
</tr>
<tr>
<td>until_expression_active</td>
<td>"no"</td>
<td>Use until_expression parameter ?</td>
<td></td>
</tr>
<tr>
<td>until_expression</td>
<td>"iteration+40</td>
<td>Pause if this expression evaluates to true.</td>
<td>".<em>" :: "Any expression"*OR</em></td>
</tr>
</tbody>
</table>
<h3 id="socket">Socket</h3>
<p>Cactus Code Thorn Socket
Author(s)    : Tom Goodale
               Thomas Radke
               John Shalf
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides platform-independent socket calls.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="cactuswave">CactusWave</h2>
<h3 id="wavetoyf77">WaveToyF77</h3>
<p>Cactus Code Thorn WaveToyF77
Author(s)    : Tom Goodale
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn solves the linear wave equation</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>bound</td>
<td>"none"</td>
<td>Type of boundary condition to use</td>
<td>"none"      :: "Apply no boundary condition"<em>OR</em>  "flat"      :: "Flat (von Neumann, n grad phi = 0) boundary condition"<em>OR</em>  "static"    :: "Static (Dirichlet, dphi/dt=0) boundary condition"<em>OR</em>  "radiation" :: "Radiation boundary condition"<em>OR</em>  "robin"     :: "Robin (phi&reg; = C/r) boundary condition"<em>OR</em>  "zero"      :: "Zero (Dirichlet, phi=0) boundary condition"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="idscalarwave">IDScalarWave</h3>
<p>Cactus Code Thorn IDScalarWave
Author(s)    : Tom Goodale
               Gabrielle Allen
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorns sets initial data for the scalar wave equation evolver</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>initial_data</td>
<td>"gaussian"</td>
<td>Type of initial data</td>
<td>"plane"      :: "Plane wave"<em>OR</em>  "gaussian"   :: "Gaussian wave"<em>OR</em>  "box"        :: "Box wave"<em>OR</em>  "none"       :: "No initial data, zero phi"<em>OR</em></td>
</tr>
<tr>
<td>radius</td>
<td>0.0</td>
<td>The radius of the gaussian wave</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>sigma</td>
<td>0.1</td>
<td>The sigma for the gaussian wave</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>kx</td>
<td>4.0</td>
<td>The wave number in the x-direction</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>ky</td>
<td>0.0</td>
<td>The wave number in the y-direction</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>kz</td>
<td>0.0</td>
<td>The wave number in the z-direction</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>amplitude</td>
<td>1.0</td>
<td>The amplitude of the waves</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="wavetoyf90">WaveToyF90</h3>
<p>Cactus Code Thorn WaveToyF90
Author(s)    : Tom Goodale
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn solves the linear wave equation</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>bound</td>
<td>"none"</td>
<td>Type of boundary condition to use</td>
<td>"none"      :: "Apply no boundary condition"<em>OR</em>  "flat"      :: "Flat (von Neumann, n grad phi = 0) boundary condition"<em>OR</em>  "static"    :: "Static (Dirichlet, dphi/dt=0) boundary condition"<em>OR</em>  "radiation" :: "Radiation boundary condition"<em>OR</em>  "robin"     :: "Robin (phi&reg; = C/r) boundary condition"<em>OR</em>  "zero"      :: "Zero (Dirichlet, phi=0) boundary condition"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="idscalarwaveelliptic">IDScalarWaveElliptic</h3>
<p>Cactus Code Thorn IDScalarWaveElliptic
Author(s)    : unknown
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>not documented</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>radius</td>
<td>1.0</td>
<td>Radius of uniformly charged sphere</td>
<td>0:* :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>charge</td>
<td>1.0</td>
<td>Charge of uniformly charged sphere</td>
<td>0:* :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>output_tmp</td>
<td>"no"</td>
<td>Output intermediate variables</td>
<td></td>
</tr>
<tr>
<td>solver</td>
<td>"sor"</td>
<td>Name of elliptic solver</td>
<td>.* :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>sor_maxit</td>
<td>100</td>
<td>Maximum number of iterations for SOR solve</td>
<td>1:* :: "Positive"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="wavetoyc">WaveToyC</h3>
<p>Cactus Code Thorn WaveToyC
Author(s)    : Gabrielle Allen
               Tom Goodale
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn solves the linear wave equation.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>bound</td>
<td>"none"</td>
<td>Type of boundary condition to use</td>
<td>"none"      :: "Apply no boundary condition"<em>OR</em>  "flat"      :: "Flat (von Neumann, n grad phi = 0) boundary condition"<em>OR</em>  "static"    :: "Static (Dirichlet, dphi/dt=0) boundary condition"<em>OR</em>  "radiation" :: "Radiation boundary condition"<em>OR</em>  "robin"     :: "Robin (phi&reg; = C/r) boundary condition"<em>OR</em>  "zero"      :: "Zero (Dirichlet, phi=0) boundary condition"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="idscalarwavec">IDScalarWaveC</h3>
<p>Cactus Code Thorn IDScalarWaveC
Author(s)    : Tom Goodale
               Gabrielle Allen
               Werner Benger
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn sets initial data for the scalar wave equation evolver.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>initial_data</td>
<td>"gaussian"</td>
<td>Type of initial data</td>
<td>"plane"      :: "Plane wave"<em>OR</em>  "gaussian"   :: "Gaussian wave"<em>OR</em>  "box"        :: "Box wave"<em>OR</em>  "none"       :: "No initial data, zero phi"<em>OR</em></td>
</tr>
<tr>
<td>radius</td>
<td>0.0</td>
<td>The radius of the gaussian wave</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>sigma</td>
<td>0.1</td>
<td>The sigma for the gaussian wave</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>kx</td>
<td>4.0</td>
<td>The wave number in the x-direction</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>ky</td>
<td>0.0</td>
<td>The wave number in the y-direction</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>kz</td>
<td>0.0</td>
<td>The wave number in the z-direction</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>amplitude</td>
<td>1.0</td>
<td>The amplitude of the waves</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="wavebinarysource">WaveBinarySource</h3>
<p>Cactus Code Thorn WaveBinarySource
Author(s)    : Gerd Lanfermann
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Provides a source term to the scalar field evolution
for two rotating binary charges.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>binary_verbose</td>
<td>"no"</td>
<td>Rotating binary source verbose</td>
<td>"yes"  :: "Info on charge location/extension on first iteration"<em>OR</em>  "debug":: "Info on charge location/extension on all iterations"<em>OR</em>  "no"   :: "no output"<em>OR</em></td>
</tr>
<tr>
<td>binary_size</td>
<td>0.5</td>
<td>Radial extension of the binary source</td>
<td>0.0: :: "Some positive value"<em>OR</em></td>
</tr>
<tr>
<td>binary_omega</td>
<td>2.0</td>
<td>Frequency of the circular binary orbit</td>
<td>0.0: :: "Some positive value"<em>OR</em></td>
</tr>
<tr>
<td>binary_charge</td>
<td>0.1</td>
<td>Charge of source</td>
<td>: :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>binary_radius</td>
<td>2.0</td>
<td>Radius of the circular binary orbit</td>
<td>0.0: :: "Some positive value"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="wavetoyfreef90">WaveToyFreeF90</h3>
<p>Cactus Code Thorn WaveToyFreeF90
Author(s)    : Tom Goodale
               Erik Schnetter
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn solves the linear wave equation, using free form (as
opposed to fixed form) Fortran 90.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>bound</td>
<td>"none"</td>
<td>Type of boundary condition to use</td>
<td>"none"      :: "Apply no boundary condition"<em>OR</em>  "flat"      :: "Flat (von Neumann, n grad phi = 0) boundary condition"<em>OR</em>  "static"    :: "Static (Dirichlet, dphi/dt=0) boundary condition"<em>OR</em>  "radiation" :: "Radiation boundary condition"<em>OR</em>  "robin"     :: "Robin (phi&reg; = C/r) boundary condition"<em>OR</em>  "zero"      :: "Zero (Dirichlet, phi=0) boundary condition"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="wavetoyextra">WaveToyExtra</h3>
<p>Cactus Code Thorn WaveToyExtra
Author(s)    : Cactus team
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Additional functionality for the WaveToy example</p>
<ul>
<li>custom boundary conditions</li>
</ul>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>custom_bound</td>
<td>""</td>
<td>Custom boundary condition to use</td>
<td>.* :: "Any valid boundary condition"<em>OR</em></td>
</tr>
<tr>
<td>custom_options</td>
<td>""</td>
<td>Table string for custom boundary condition</td>
<td>.* :: "Any valid table string"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="idscalarwavecxx">IDScalarWaveCXX</h3>
<p>Cactus Code Thorn IDScalarWaveCXX
Author(s)    : Tom Goodale
               Gabrielle Allen
               Werner Benger
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorns sets initial data for the scalar wave equation evolver</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>initial_data</td>
<td>"gaussian"</td>
<td>Type of initial data</td>
<td>"plane"      :: "Plane wave"<em>OR</em>  "gaussian"   :: "Gaussian wave"<em>OR</em>  "box"        :: "Box wave"<em>OR</em>  "none"       :: "No initial data, zero phi"<em>OR</em></td>
</tr>
<tr>
<td>radius</td>
<td>0.0</td>
<td>The radius of the gaussian wave</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>sigma</td>
<td>0.1</td>
<td>The sigma for the gaussian wave</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>kx</td>
<td>4.0</td>
<td>The wave number in the x-direction</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>ky</td>
<td>0.0</td>
<td>The wave number in the y-direction</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>kz</td>
<td>0.0</td>
<td>The wave number in the z-direction</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>amplitude</td>
<td>1.0</td>
<td>The amplitude of the waves</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="wavetoycxx">WaveToyCXX</h3>
<p>Cactus Code Thorn WaveToyCXX
Author(s)    : unknown
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>not documented</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>bound</td>
<td>"none"</td>
<td>Type of boundary condition to use</td>
<td>"none"      :: "Apply no boundary condition"<em>OR</em>  "flat"      :: "Flat (von Neumann, n grad phi = 0) boundary condition"<em>OR</em>  "static"    :: "Static (Dirichlet, dphi/dt=0) boundary condition"<em>OR</em>  "radiation" :: "Radiation boundary condition"<em>OR</em>  "robin"     :: "Robin (phi&reg; = C/r) boundary condition"<em>OR</em>  "zero"      :: "Zero (Dirichlet, phi=0) boundary condition"<em>OR</em></td>
</tr>
</tbody>
</table>
<h2 id="einsteinexact">EinsteinExact</h2>
<h3 id="einsteinexact_test">EinsteinExact_Test</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="modifiedschwarzschildbl">ModifiedSchwarzschildBL</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>initial_data</td>
<td></td>
<td>initial_data</td>
<td>"ModifiedSchwarzschildBL" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_lapse</td>
<td></td>
<td>initial_lapse</td>
<td>"ModifiedSchwarzschildBL" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_shift</td>
<td></td>
<td>initial_shift</td>
<td>"ModifiedSchwarzschildBL" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_dtlapse</td>
<td></td>
<td>initial_dtlapse</td>
<td>"ModifiedSchwarzschildBL" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_dtshift</td>
<td></td>
<td>initial_dtshift</td>
<td>"ModifiedSchwarzschildBL" :: ""<em>OR</em></td>
</tr>
<tr>
<td>evolution_method</td>
<td></td>
<td>evolution_method</td>
<td>"ModifiedSchwarzschildBL" :: ""<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>0</td>
<td>verbose</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>other_timelevels</td>
<td>1</td>
<td>Number of active timelevels for non-evolved grid functions</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>timeoffset</td>
<td>0</td>
<td>timeoffset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positionx</td>
<td>0</td>
<td>positionx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positiony</td>
<td>0</td>
<td>positiony</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positionz</td>
<td>0</td>
<td>positionz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>theta</td>
<td>0</td>
<td>theta</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>phi</td>
<td>0</td>
<td>phi</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>psi</td>
<td>0</td>
<td>psi</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>lapsefactor</td>
<td>1</td>
<td>lapsefactor</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boostx</td>
<td>0</td>
<td>boostx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boosty</td>
<td>0</td>
<td>boosty</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boostz</td>
<td>0</td>
<td>boostz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddx</td>
<td>0</td>
<td>shiftaddx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddy</td>
<td>0</td>
<td>shiftaddy</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddz</td>
<td>0</td>
<td>shiftaddz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>M</td>
<td>0</td>
<td>M</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>epsilon</td>
<td>0</td>
<td>epsilon</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>tile_size</td>
<td>-1</td>
<td>Loop tile size</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>exact_method</td>
<td>"none"</td>
<td>exact_method</td>
<td>"none" :: ""<em>OR</em>  "ModifiedSchwarzschildBL" :: ""<em>OR</em></td>
</tr>
<tr>
<td>ModifiedSchwarzschildBL_MaxNumEvolvedVars</td>
<td>0</td>
<td>Number of evolved variables used by this thorn</td>
<td>0:0 :: "Number of evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>ModifiedSchwarzschildBL_MaxNumArrayEvolvedVars</td>
<td>0</td>
<td>Number of Array evolved variables used by this thorn</td>
<td>0:0 :: "Number of Array evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>timelevels</td>
<td>3</td>
<td>Number of active timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>rhs_timelevels</td>
<td>1</td>
<td>Number of active RHS timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>ModifiedSchwarzschildBL_initial_calc_every</td>
<td>1</td>
<td>ModifiedSchwarzschildBL_initial_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ModifiedSchwarzschildBL_always_calc_every</td>
<td>1</td>
<td>ModifiedSchwarzschildBL_always_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ModifiedSchwarzschildBL_exact_calc_every</td>
<td>1</td>
<td>ModifiedSchwarzschildBL_exact_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ModifiedSchwarzschildBL_initial_calc_offset</td>
<td>0</td>
<td>ModifiedSchwarzschildBL_initial_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ModifiedSchwarzschildBL_always_calc_offset</td>
<td>0</td>
<td>ModifiedSchwarzschildBL_always_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ModifiedSchwarzschildBL_exact_calc_offset</td>
<td>0</td>
<td>ModifiedSchwarzschildBL_exact_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="gaugewave">GaugeWave</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>initial_data</td>
<td></td>
<td>initial_data</td>
<td>"GaugeWave" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_lapse</td>
<td></td>
<td>initial_lapse</td>
<td>"GaugeWave" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_shift</td>
<td></td>
<td>initial_shift</td>
<td>"GaugeWave" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_dtlapse</td>
<td></td>
<td>initial_dtlapse</td>
<td>"GaugeWave" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_dtshift</td>
<td></td>
<td>initial_dtshift</td>
<td>"GaugeWave" :: ""<em>OR</em></td>
</tr>
<tr>
<td>evolution_method</td>
<td></td>
<td>evolution_method</td>
<td>"GaugeWave" :: ""<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>0</td>
<td>verbose</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>other_timelevels</td>
<td>1</td>
<td>Number of active timelevels for non-evolved grid functions</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>timeoffset</td>
<td>0</td>
<td>timeoffset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positionx</td>
<td>0</td>
<td>positionx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positiony</td>
<td>0</td>
<td>positiony</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positionz</td>
<td>0</td>
<td>positionz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>theta</td>
<td>0</td>
<td>theta</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>phi</td>
<td>0</td>
<td>phi</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>psi</td>
<td>0</td>
<td>psi</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>lapsefactor</td>
<td>1</td>
<td>lapsefactor</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boostx</td>
<td>0</td>
<td>boostx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boosty</td>
<td>0</td>
<td>boosty</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boostz</td>
<td>0</td>
<td>boostz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddx</td>
<td>0</td>
<td>shiftaddx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddy</td>
<td>0</td>
<td>shiftaddy</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddz</td>
<td>0</td>
<td>shiftaddz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>amp</td>
<td>0</td>
<td>amp</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>period</td>
<td>0</td>
<td>period</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>tile_size</td>
<td>-1</td>
<td>Loop tile size</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>exact_method</td>
<td>"none"</td>
<td>exact_method</td>
<td>"none" :: ""<em>OR</em>  "GaugeWave" :: ""<em>OR</em></td>
</tr>
<tr>
<td>GaugeWave_MaxNumEvolvedVars</td>
<td>0</td>
<td>Number of evolved variables used by this thorn</td>
<td>0:0 :: "Number of evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>GaugeWave_MaxNumArrayEvolvedVars</td>
<td>0</td>
<td>Number of Array evolved variables used by this thorn</td>
<td>0:0 :: "Number of Array evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>timelevels</td>
<td>3</td>
<td>Number of active timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>rhs_timelevels</td>
<td>1</td>
<td>Number of active RHS timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>GaugeWave_initial_calc_every</td>
<td>1</td>
<td>GaugeWave_initial_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>GaugeWave_always_calc_every</td>
<td>1</td>
<td>GaugeWave_always_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>GaugeWave_exact_calc_every</td>
<td>1</td>
<td>GaugeWave_exact_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>GaugeWave_initial_calc_offset</td>
<td>0</td>
<td>GaugeWave_initial_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>GaugeWave_always_calc_offset</td>
<td>0</td>
<td>GaugeWave_always_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>GaugeWave_exact_calc_offset</td>
<td>0</td>
<td>GaugeWave_exact_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="tests">tests</h3>
<h3 id="minkowski">Minkowski</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>initial_data</td>
<td></td>
<td>initial_data</td>
<td>"Minkowski" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_lapse</td>
<td></td>
<td>initial_lapse</td>
<td>"Minkowski" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_shift</td>
<td></td>
<td>initial_shift</td>
<td>"Minkowski" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_dtlapse</td>
<td></td>
<td>initial_dtlapse</td>
<td>"Minkowski" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_dtshift</td>
<td></td>
<td>initial_dtshift</td>
<td>"Minkowski" :: ""<em>OR</em></td>
</tr>
<tr>
<td>evolution_method</td>
<td></td>
<td>evolution_method</td>
<td>"Minkowski" :: ""<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>0</td>
<td>verbose</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>other_timelevels</td>
<td>1</td>
<td>Number of active timelevels for non-evolved grid functions</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>timeoffset</td>
<td>0</td>
<td>timeoffset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positionx</td>
<td>0</td>
<td>positionx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positiony</td>
<td>0</td>
<td>positiony</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positionz</td>
<td>0</td>
<td>positionz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>theta</td>
<td>0</td>
<td>theta</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>phi</td>
<td>0</td>
<td>phi</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>psi</td>
<td>0</td>
<td>psi</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>lapsefactor</td>
<td>1</td>
<td>lapsefactor</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boostx</td>
<td>0</td>
<td>boostx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boosty</td>
<td>0</td>
<td>boosty</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boostz</td>
<td>0</td>
<td>boostz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddx</td>
<td>0</td>
<td>shiftaddx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddy</td>
<td>0</td>
<td>shiftaddy</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddz</td>
<td>0</td>
<td>shiftaddz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>tile_size</td>
<td>-1</td>
<td>Loop tile size</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>exact_method</td>
<td>"none"</td>
<td>exact_method</td>
<td>"none" :: ""<em>OR</em>  "Minkowski" :: ""<em>OR</em></td>
</tr>
<tr>
<td>Minkowski_MaxNumEvolvedVars</td>
<td>0</td>
<td>Number of evolved variables used by this thorn</td>
<td>0:0 :: "Number of evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>Minkowski_MaxNumArrayEvolvedVars</td>
<td>0</td>
<td>Number of Array evolved variables used by this thorn</td>
<td>0:0 :: "Number of Array evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>timelevels</td>
<td>3</td>
<td>Number of active timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>rhs_timelevels</td>
<td>1</td>
<td>Number of active RHS timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>Minkowski_initial_calc_every</td>
<td>1</td>
<td>Minkowski_initial_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Minkowski_always_calc_every</td>
<td>1</td>
<td>Minkowski_always_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Minkowski_exact_calc_every</td>
<td>1</td>
<td>Minkowski_exact_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Minkowski_initial_calc_offset</td>
<td>0</td>
<td>Minkowski_initial_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Minkowski_always_calc_offset</td>
<td>0</td>
<td>Minkowski_always_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Minkowski_exact_calc_offset</td>
<td>0</td>
<td>Minkowski_exact_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="shiftedgaugewave">ShiftedGaugeWave</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>initial_data</td>
<td></td>
<td>initial_data</td>
<td>"ShiftedGaugeWave" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_lapse</td>
<td></td>
<td>initial_lapse</td>
<td>"ShiftedGaugeWave" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_shift</td>
<td></td>
<td>initial_shift</td>
<td>"ShiftedGaugeWave" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_dtlapse</td>
<td></td>
<td>initial_dtlapse</td>
<td>"ShiftedGaugeWave" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_dtshift</td>
<td></td>
<td>initial_dtshift</td>
<td>"ShiftedGaugeWave" :: ""<em>OR</em></td>
</tr>
<tr>
<td>evolution_method</td>
<td></td>
<td>evolution_method</td>
<td>"ShiftedGaugeWave" :: ""<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>0</td>
<td>verbose</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>other_timelevels</td>
<td>1</td>
<td>Number of active timelevels for non-evolved grid functions</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>timeoffset</td>
<td>0</td>
<td>timeoffset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positionx</td>
<td>0</td>
<td>positionx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positiony</td>
<td>0</td>
<td>positiony</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positionz</td>
<td>0</td>
<td>positionz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>theta</td>
<td>0</td>
<td>theta</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>phi</td>
<td>0</td>
<td>phi</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>psi</td>
<td>0</td>
<td>psi</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>lapsefactor</td>
<td>1</td>
<td>lapsefactor</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boostx</td>
<td>0</td>
<td>boostx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boosty</td>
<td>0</td>
<td>boosty</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boostz</td>
<td>0</td>
<td>boostz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddx</td>
<td>0</td>
<td>shiftaddx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddy</td>
<td>0</td>
<td>shiftaddy</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddz</td>
<td>0</td>
<td>shiftaddz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>amp</td>
<td>0</td>
<td>amp</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>period</td>
<td>0</td>
<td>period</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>tile_size</td>
<td>-1</td>
<td>Loop tile size</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>exact_method</td>
<td>"none"</td>
<td>exact_method</td>
<td>"none" :: ""<em>OR</em>  "ShiftedGaugeWave" :: ""<em>OR</em></td>
</tr>
<tr>
<td>ShiftedGaugeWave_MaxNumEvolvedVars</td>
<td>0</td>
<td>Number of evolved variables used by this thorn</td>
<td>0:0 :: "Number of evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>ShiftedGaugeWave_MaxNumArrayEvolvedVars</td>
<td>0</td>
<td>Number of Array evolved variables used by this thorn</td>
<td>0:0 :: "Number of Array evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>timelevels</td>
<td>3</td>
<td>Number of active timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>rhs_timelevels</td>
<td>1</td>
<td>Number of active RHS timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>ShiftedGaugeWave_initial_calc_every</td>
<td>1</td>
<td>ShiftedGaugeWave_initial_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ShiftedGaugeWave_always_calc_every</td>
<td>1</td>
<td>ShiftedGaugeWave_always_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ShiftedGaugeWave_exact_calc_every</td>
<td>1</td>
<td>ShiftedGaugeWave_exact_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ShiftedGaugeWave_initial_calc_offset</td>
<td>0</td>
<td>ShiftedGaugeWave_initial_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ShiftedGaugeWave_always_calc_offset</td>
<td>0</td>
<td>ShiftedGaugeWave_always_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ShiftedGaugeWave_exact_calc_offset</td>
<td>0</td>
<td>ShiftedGaugeWave_exact_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="doc_1">doc</h3>
<h3 id="kerrschild">KerrSchild</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>initial_data</td>
<td></td>
<td>initial_data</td>
<td>"KerrSchild" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_lapse</td>
<td></td>
<td>initial_lapse</td>
<td>"KerrSchild" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_shift</td>
<td></td>
<td>initial_shift</td>
<td>"KerrSchild" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_dtlapse</td>
<td></td>
<td>initial_dtlapse</td>
<td>"KerrSchild" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_dtshift</td>
<td></td>
<td>initial_dtshift</td>
<td>"KerrSchild" :: ""<em>OR</em></td>
</tr>
<tr>
<td>evolution_method</td>
<td></td>
<td>evolution_method</td>
<td>"KerrSchild" :: ""<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>0</td>
<td>verbose</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>other_timelevels</td>
<td>1</td>
<td>Number of active timelevels for non-evolved grid functions</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>timeoffset</td>
<td>0</td>
<td>timeoffset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positionx</td>
<td>0</td>
<td>positionx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positiony</td>
<td>0</td>
<td>positiony</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positionz</td>
<td>0</td>
<td>positionz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>theta</td>
<td>0</td>
<td>theta</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>phi</td>
<td>0</td>
<td>phi</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>psi</td>
<td>0</td>
<td>psi</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>lapsefactor</td>
<td>1</td>
<td>lapsefactor</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boostx</td>
<td>0</td>
<td>boostx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boosty</td>
<td>0</td>
<td>boosty</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boostz</td>
<td>0</td>
<td>boostz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddx</td>
<td>0</td>
<td>shiftaddx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddy</td>
<td>0</td>
<td>shiftaddy</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddz</td>
<td>0</td>
<td>shiftaddz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>M</td>
<td>0</td>
<td>M</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>a</td>
<td>0</td>
<td>a</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>tile_size</td>
<td>-1</td>
<td>Loop tile size</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>exact_method</td>
<td>"none"</td>
<td>exact_method</td>
<td>"none" :: ""<em>OR</em>  "KerrSchild" :: ""<em>OR</em></td>
</tr>
<tr>
<td>KerrSchild_MaxNumEvolvedVars</td>
<td>0</td>
<td>Number of evolved variables used by this thorn</td>
<td>0:0 :: "Number of evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>KerrSchild_MaxNumArrayEvolvedVars</td>
<td>0</td>
<td>Number of Array evolved variables used by this thorn</td>
<td>0:0 :: "Number of Array evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>timelevels</td>
<td>3</td>
<td>Number of active timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>rhs_timelevels</td>
<td>1</td>
<td>Number of active RHS timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>KerrSchild_initial_calc_every</td>
<td>1</td>
<td>KerrSchild_initial_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>KerrSchild_always_calc_every</td>
<td>1</td>
<td>KerrSchild_always_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>KerrSchild_exact_calc_every</td>
<td>1</td>
<td>KerrSchild_exact_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>KerrSchild_initial_calc_offset</td>
<td>0</td>
<td>KerrSchild_initial_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>KerrSchild_always_calc_offset</td>
<td>0</td>
<td>KerrSchild_always_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>KerrSchild_exact_calc_offset</td>
<td>0</td>
<td>KerrSchild_exact_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="vaidya2">Vaidya2</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>initial_data</td>
<td></td>
<td>initial_data</td>
<td>"Vaidya2" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_lapse</td>
<td></td>
<td>initial_lapse</td>
<td>"Vaidya2" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_shift</td>
<td></td>
<td>initial_shift</td>
<td>"Vaidya2" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_dtlapse</td>
<td></td>
<td>initial_dtlapse</td>
<td>"Vaidya2" :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_dtshift</td>
<td></td>
<td>initial_dtshift</td>
<td>"Vaidya2" :: ""<em>OR</em></td>
</tr>
<tr>
<td>evolution_method</td>
<td></td>
<td>evolution_method</td>
<td>"Vaidya2" :: ""<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>0</td>
<td>verbose</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>other_timelevels</td>
<td>1</td>
<td>Number of active timelevels for non-evolved grid functions</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>timeoffset</td>
<td>0</td>
<td>timeoffset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positionx</td>
<td>0</td>
<td>positionx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positiony</td>
<td>0</td>
<td>positiony</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>positionz</td>
<td>0</td>
<td>positionz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>theta</td>
<td>0</td>
<td>theta</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>phi</td>
<td>0</td>
<td>phi</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>psi</td>
<td>0</td>
<td>psi</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>lapsefactor</td>
<td>1</td>
<td>lapsefactor</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boostx</td>
<td>0</td>
<td>boostx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boosty</td>
<td>0</td>
<td>boosty</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>boostz</td>
<td>0</td>
<td>boostz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddx</td>
<td>0</td>
<td>shiftaddx</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddy</td>
<td>0</td>
<td>shiftaddy</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftaddz</td>
<td>0</td>
<td>shiftaddz</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>M</td>
<td>0</td>
<td>M</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>dM</td>
<td>0</td>
<td>dM</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>tile_size</td>
<td>-1</td>
<td>Loop tile size</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>exact_method</td>
<td>"none"</td>
<td>exact_method</td>
<td>"none" :: ""<em>OR</em>  "Vaidya2" :: ""<em>OR</em></td>
</tr>
<tr>
<td>Vaidya2_MaxNumEvolvedVars</td>
<td>0</td>
<td>Number of evolved variables used by this thorn</td>
<td>0:0 :: "Number of evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>Vaidya2_MaxNumArrayEvolvedVars</td>
<td>0</td>
<td>Number of Array evolved variables used by this thorn</td>
<td>0:0 :: "Number of Array evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>timelevels</td>
<td>3</td>
<td>Number of active timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>rhs_timelevels</td>
<td>1</td>
<td>Number of active RHS timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>Vaidya2_initial_calc_every</td>
<td>1</td>
<td>Vaidya2_initial_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Vaidya2_always_calc_every</td>
<td>1</td>
<td>Vaidya2_always_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Vaidya2_exact_calc_every</td>
<td>1</td>
<td>Vaidya2_exact_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Vaidya2_initial_calc_offset</td>
<td>0</td>
<td>Vaidya2_initial_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Vaidya2_always_calc_offset</td>
<td>0</td>
<td>Vaidya2_always_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Vaidya2_exact_calc_offset</td>
<td>0</td>
<td>Vaidya2_exact_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="m">m</h3>
<h2 id="mclachlan">McLachlan</h2>
<h3 id="ml_ccz4_test">ML_CCZ4_Test</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="ml_ccz4_helper">ML_CCZ4_Helper</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>ML_CCZ4_MaxNumConstrainedVars</td>
<td>20</td>
<td>Number of constrained variables used by this thorn</td>
<td>20:20 :: "Number of constrained variables used by this thorn"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="ml_wavetoy_test">ML_WaveToy_Test</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="ml_wavetoy">ML_WaveToy</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>0</td>
<td>verbose</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>other_timelevels</td>
<td>1</td>
<td>Number of active timelevels for non-evolved grid functions</td>
<td>0:4 :: ""<em>OR</em></td>
</tr>
<tr>
<td>amplitude</td>
<td>1</td>
<td>Amplitude of initial Gaussian</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>width</td>
<td>1</td>
<td>Width of initial Gaussian</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>tile_size</td>
<td>-1</td>
<td>Loop tile size</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_data</td>
<td>"Gaussian"</td>
<td>initial_data</td>
<td>"Gaussian" :: ""<em>OR</em>  "Standing" :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_WaveToy_MaxNumEvolvedVars</td>
<td>2</td>
<td>Number of evolved variables used by this thorn</td>
<td>2:2 :: "Number of evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>ML_WaveToy_MaxNumArrayEvolvedVars</td>
<td>0</td>
<td>Number of Array evolved variables used by this thorn</td>
<td>0:0 :: "Number of Array evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>timelevels</td>
<td>4</td>
<td>Number of active timelevels</td>
<td>0:4 :: ""<em>OR</em></td>
</tr>
<tr>
<td>rhs_timelevels</td>
<td>1</td>
<td>Number of active RHS timelevels</td>
<td>0:4 :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_Gaussian_calc_every</td>
<td>1</td>
<td>WT_Gaussian_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_Standing_calc_every</td>
<td>1</td>
<td>WT_Standing_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_RHS_calc_every</td>
<td>1</td>
<td>WT_RHS_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_Dirichlet_calc_every</td>
<td>1</td>
<td>WT_Dirichlet_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_Energy_calc_every</td>
<td>1</td>
<td>WT_Energy_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_EnergyBoundary_calc_every</td>
<td>1</td>
<td>WT_EnergyBoundary_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_Gaussian_calc_offset</td>
<td>0</td>
<td>WT_Gaussian_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_Standing_calc_offset</td>
<td>0</td>
<td>WT_Standing_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_RHS_calc_offset</td>
<td>0</td>
<td>WT_RHS_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_Dirichlet_calc_offset</td>
<td>0</td>
<td>WT_Dirichlet_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_Energy_calc_offset</td>
<td>0</td>
<td>WT_Energy_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_EnergyBoundary_calc_offset</td>
<td>0</td>
<td>WT_EnergyBoundary_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>u_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>rho_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>WT_u_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>WT_rho_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>u_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>rho_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>WT_u_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>WT_rho_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>u_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>rho_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>WT_u_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>WT_rho_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>u_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>rho_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>WT_u_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>WT_rho_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="ml_bssn_helper">ML_BSSN_Helper</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>ML_BSSN_MaxNumConstrainedVars</td>
<td>20</td>
<td>Number of constrained variables used by this thorn</td>
<td>20:20 :: "Number of constrained variables used by this thorn"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="ml_wavetoy_cl">ML_WaveToy_CL</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>0</td>
<td>verbose</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>other_timelevels</td>
<td>1</td>
<td>Number of active timelevels for non-evolved grid functions</td>
<td>0:4 :: ""<em>OR</em></td>
</tr>
<tr>
<td>amplitude</td>
<td>1</td>
<td>Amplitude of initial Gaussian</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>width</td>
<td>1</td>
<td>Width of initial Gaussian</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>tile_size</td>
<td>-1</td>
<td>Loop tile size</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_data</td>
<td>"Gaussian"</td>
<td>initial_data</td>
<td>"Gaussian" :: ""<em>OR</em>  "Standing" :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_WaveToy_CL_MaxNumEvolvedVars</td>
<td>2</td>
<td>Number of evolved variables used by this thorn</td>
<td>2:2 :: "Number of evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>ML_WaveToy_CL_MaxNumArrayEvolvedVars</td>
<td>0</td>
<td>Number of Array evolved variables used by this thorn</td>
<td>0:0 :: "Number of Array evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>timelevels</td>
<td>4</td>
<td>Number of active timelevels</td>
<td>0:4 :: ""<em>OR</em></td>
</tr>
<tr>
<td>rhs_timelevels</td>
<td>1</td>
<td>Number of active RHS timelevels</td>
<td>0:4 :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_CL_Gaussian_calc_every</td>
<td>1</td>
<td>WT_CL_Gaussian_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_CL_Standing_calc_every</td>
<td>1</td>
<td>WT_CL_Standing_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_CL_RHS_calc_every</td>
<td>1</td>
<td>WT_CL_RHS_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_CL_Dirichlet_calc_every</td>
<td>1</td>
<td>WT_CL_Dirichlet_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_CL_Energy_calc_every</td>
<td>1</td>
<td>WT_CL_Energy_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_CL_EnergyBoundary_calc_every</td>
<td>1</td>
<td>WT_CL_EnergyBoundary_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_CL_Gaussian_calc_offset</td>
<td>0</td>
<td>WT_CL_Gaussian_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_CL_Standing_calc_offset</td>
<td>0</td>
<td>WT_CL_Standing_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_CL_RHS_calc_offset</td>
<td>0</td>
<td>WT_CL_RHS_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_CL_Dirichlet_calc_offset</td>
<td>0</td>
<td>WT_CL_Dirichlet_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_CL_Energy_calc_offset</td>
<td>0</td>
<td>WT_CL_Energy_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WT_CL_EnergyBoundary_calc_offset</td>
<td>0</td>
<td>WT_CL_EnergyBoundary_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>u_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>rho_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>WT_u_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>WT_rho_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>u_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>rho_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>WT_u_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>WT_rho_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>u_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>rho_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>WT_u_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>WT_rho_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>u_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>rho_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>WT_u_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>WT_rho_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="doc_2">doc</h3>
<h3 id="ml_bssn">ML_BSSN</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>evolution_method</td>
<td></td>
<td>evolution_method</td>
<td>"ML_BSSN" :: ""<em>OR</em></td>
</tr>
<tr>
<td>lapse_evolution_method</td>
<td></td>
<td>lapse_evolution_method</td>
<td>"ML_BSSN" :: ""<em>OR</em></td>
</tr>
<tr>
<td>shift_evolution_method</td>
<td></td>
<td>shift_evolution_method</td>
<td>"ML_BSSN" :: ""<em>OR</em></td>
</tr>
<tr>
<td>dtlapse_evolution_method</td>
<td></td>
<td>dtlapse_evolution_method</td>
<td>"ML_BSSN" :: ""<em>OR</em></td>
</tr>
<tr>
<td>dtshift_evolution_method</td>
<td></td>
<td>dtshift_evolution_method</td>
<td>"ML_BSSN" :: ""<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>0</td>
<td>verbose</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>other_timelevels</td>
<td>1</td>
<td>Number of active timelevels for non-evolved grid functions</td>
<td>0:4 :: ""<em>OR</em></td>
</tr>
<tr>
<td>harmonicF</td>
<td>1</td>
<td>d/dt alpha = - f alpha^n K   (harmonic: f=1, 1+log: f=2)</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>alphaDriver</td>
<td>0</td>
<td>d/dt alpha = ... - alphaDriver (alpha - 1)   (use 1/M (?))</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftGammaCoeff</td>
<td>0</td>
<td>d/dt beta^i = C Xt^i   (use C=0.75/M)</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>betaDriver</td>
<td>0</td>
<td>d/dt beta^i = ... - betaDriver alpha^shiftAlphaPower beta^i   (use 1/M (?))</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftAlphaPower</td>
<td>0</td>
<td>d/dt beta^i = ... - betaDriver alpha^shiftAlphaPower beta^i   (use 0 (?))</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>spatialBetaDriverRadius</td>
<td>1000000000000</td>
<td>Radius at which the betaDriver starts to be reduced</td>
<td>(0:* :: "positive"<em>OR</em></td>
</tr>
<tr>
<td>spatialShiftGammaCoeffRadius</td>
<td>1000000000000</td>
<td>Radius at which shiftGammaCoeff starts to be reduced</td>
<td>(0:* :: "positive"<em>OR</em></td>
</tr>
<tr>
<td>minimumLapse</td>
<td>0</td>
<td>Enforced minimum of the lapse function</td>
<td>0:* :: "non-negative"<em>OR</em></td>
</tr>
<tr>
<td>epsDiss</td>
<td>0</td>
<td>Dissipation strength</td>
<td>0:* :: "non-negative"<em>OR</em></td>
</tr>
<tr>
<td>LapseACoeff</td>
<td>-1.</td>
<td>(OUTDATED) Evolve time derivative of lapse A? (now evolveA)</td>
<td>0. :: "off"<em>OR</em>  1. :: "on"<em>OR</em>  -1. :: "default"<em>OR</em></td>
</tr>
<tr>
<td>ShiftBCoeff</td>
<td>-1.</td>
<td>(OUTDATED) Evolve time derivative of shift B^i? (now evolveB)</td>
<td>0. :: "off"<em>OR</em>  1. :: "on"<em>OR</em>  -1. :: "default"<em>OR</em></td>
</tr>
<tr>
<td>LapseAdvectionCoeff</td>
<td>-1.</td>
<td>(OUTDATED) Advect lapse? (now advectLapse)</td>
<td>0. :: "off"<em>OR</em>  1. :: "on"<em>OR</em>  -1. :: "default"<em>OR</em></td>
</tr>
<tr>
<td>ShiftAdvectionCoeff</td>
<td>-1.</td>
<td>(OUTDATED) Advect shift? (now advectShift)</td>
<td>0. :: "off"<em>OR</em>  1. :: "on"<em>OR</em>  -1. :: "default"<em>OR</em></td>
</tr>
<tr>
<td>fdOrder</td>
<td>4</td>
<td>Finite differencing order</td>
<td>2 :: ""<em>OR</em>  4 :: ""<em>OR</em>  6 :: ""<em>OR</em>  8 :: ""<em>OR</em></td>
</tr>
<tr>
<td>conformalMethod</td>
<td>0</td>
<td>Treatment of conformal factor</td>
<td>0 :: "phi method"<em>OR</em>  1 :: "W method"<em>OR</em></td>
</tr>
<tr>
<td>evolveA</td>
<td>0</td>
<td>Evolve time derivative of lapse A? (former LapseACoeff)</td>
<td>0 :: "off"<em>OR</em>  1 :: "on"<em>OR</em></td>
</tr>
<tr>
<td>evolveB</td>
<td>1</td>
<td>Evolve time derivative of shift B^i? (former ShiftBCoeff)</td>
<td>0 :: "off"<em>OR</em>  1 :: "on"<em>OR</em></td>
</tr>
<tr>
<td>harmonicN</td>
<td>2</td>
<td>d/dt alpha = - f alpha^n K  (harmonic: n=2, 1+log: n=1)</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftFormulation</td>
<td>0</td>
<td>shift formulation</td>
<td>0 :: "Gamma driver"<em>OR</em>  1 :: "harmonic"<em>OR</em></td>
</tr>
<tr>
<td>useSpatialBetaDriver</td>
<td>0</td>
<td>Enable spatially varying betaDriver</td>
<td>0 :: "off"<em>OR</em>  1 :: "on"<em>OR</em></td>
</tr>
<tr>
<td>useSpatialShiftGammaCoeff</td>
<td>0</td>
<td>Enable spatially varying shiftGammaCoeff</td>
<td>0 :: "off"<em>OR</em>  1 :: "on"<em>OR</em></td>
</tr>
<tr>
<td>advectLapse</td>
<td>1</td>
<td>Advect lapse? (former LapseAdvectionCoeff)</td>
<td>0 :: "off"<em>OR</em>  1 :: "on"<em>OR</em></td>
</tr>
<tr>
<td>advectShift</td>
<td>1</td>
<td>Advect shift? (former ShiftAdvectionCoeff)</td>
<td>0 :: "off"<em>OR</em>  1 :: "on"<em>OR</em></td>
</tr>
<tr>
<td>fixAdvectionTerms</td>
<td>0</td>
<td>Modify driver and advection terms to work better?</td>
<td>0 :: "off"<em>OR</em>  1 :: "on"<em>OR</em></td>
</tr>
<tr>
<td>tile_size</td>
<td>-1</td>
<td>Loop tile size</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_boundary_condition</td>
<td>"scalar"</td>
<td>Boundary condition for initial condition for some of the BSSN variables</td>
<td>"scalar" :: "not recommended; use ML_BSSN_Helper's value 'extrapolate-gammas' instead"<em>OR</em></td>
</tr>
<tr>
<td>rhs_boundary_condition</td>
<td>"scalar"</td>
<td>Boundary condition for BSSN RHS and some of the ADMBase variables</td>
<td>"scalar" :: "not recommended; use ML_BSSN_Helper's option 'NewRad' instead"<em>OR</em></td>
</tr>
<tr>
<td>rhs_evaluation</td>
<td>"splitBy"</td>
<td>Whether and how the RHS routine should be split to improve performance</td>
<td>"combined" :: "use a single routine (probably slow)"<em>OR</em>  "splitBy" :: "split into 3 routines via Kranc"<em>OR</em></td>
</tr>
<tr>
<td>my_initial_data</td>
<td>"default"</td>
<td>(OUTDATED)</td>
<td>"ADMBase" :: "from ADMBase"<em>OR</em>  "default" :: "do nothing"<em>OR</em></td>
</tr>
<tr>
<td>my_initial_boundary_condition</td>
<td>"default"</td>
<td>(OUTDATED)</td>
<td>"none" :: "none"<em>OR</em>  "default" :: "do nothing"<em>OR</em></td>
</tr>
<tr>
<td>my_rhs_boundary_condition</td>
<td>"default"</td>
<td>(OUTDATED)</td>
<td>"none" :: "none"<em>OR</em>  "static" :: "static"<em>OR</em>  "default" :: "do nothing"<em>OR</em></td>
</tr>
<tr>
<td>my_boundary_condition</td>
<td>"default"</td>
<td>(OUTDATED)</td>
<td>"none" :: "none"<em>OR</em>  "Minkowski" :: "Minkowski"<em>OR</em>  "default" :: "do nothing"<em>OR</em></td>
</tr>
<tr>
<td>dt_lapse_shift_method</td>
<td>"default"</td>
<td>(OUTDATED) Treatment of ADMBase dtlapse and dtshift</td>
<td>"correct" :: "(unused)"<em>OR</em>  "noLapseShiftAdvection" :: "(unused)"<em>OR</em>  "default" :: "do nothing"<em>OR</em></td>
</tr>
<tr>
<td>apply_dissipation</td>
<td>"default"</td>
<td>(OUTDATED) Whether to apply dissipation to the RHSs</td>
<td>"always" :: "yes"<em>OR</em>  "never" :: "no"<em>OR</em>  "default" :: "do nothing"<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_MaxNumEvolvedVars</td>
<td>25</td>
<td>Number of evolved variables used by this thorn</td>
<td>25:25 :: "Number of evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_MaxNumArrayEvolvedVars</td>
<td>0</td>
<td>Number of Array evolved variables used by this thorn</td>
<td>0:0 :: "Number of Array evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>timelevels</td>
<td>3</td>
<td>Number of active timelevels</td>
<td>0:4 :: ""<em>OR</em></td>
</tr>
<tr>
<td>rhs_timelevels</td>
<td>1</td>
<td>Number of active RHS timelevels</td>
<td>0:4 :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_InitialADMBase1Everywhere_calc_every</td>
<td>1</td>
<td>ML_BSSN_InitialADMBase1Everywhere_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_InitialADMBase2Interior_calc_every</td>
<td>1</td>
<td>ML_BSSN_InitialADMBase2Interior_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_InitialADMBase2BoundaryScalar_calc_every</td>
<td>1</td>
<td>ML_BSSN_InitialADMBase2BoundaryScalar_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_EnforceEverywhere_calc_every</td>
<td>1</td>
<td>ML_BSSN_EnforceEverywhere_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_ADMBaseEverywhere_calc_every</td>
<td>1</td>
<td>ML_BSSN_ADMBaseEverywhere_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_ADMBaseInterior_calc_every</td>
<td>1</td>
<td>ML_BSSN_ADMBaseInterior_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_ADMBaseBoundaryScalar_calc_every</td>
<td>1</td>
<td>ML_BSSN_ADMBaseBoundaryScalar_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_EvolutionInterior_calc_every</td>
<td>1</td>
<td>ML_BSSN_EvolutionInterior_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_EvolutionInteriorSplitBy1_calc_every</td>
<td>1</td>
<td>ML_BSSN_EvolutionInteriorSplitBy1_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_EvolutionInteriorSplitBy2_calc_every</td>
<td>1</td>
<td>ML_BSSN_EvolutionInteriorSplitBy2_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_EvolutionInteriorSplitBy3_calc_every</td>
<td>1</td>
<td>ML_BSSN_EvolutionInteriorSplitBy3_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_EvolutionBoundaryScalar_calc_every</td>
<td>1</td>
<td>ML_BSSN_EvolutionBoundaryScalar_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_EvolutionAnalysisInit_calc_every</td>
<td>1</td>
<td>ML_BSSN_EvolutionAnalysisInit_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_EvolutionAnalysisInterior_calc_every</td>
<td>1</td>
<td>ML_BSSN_EvolutionAnalysisInterior_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_ConstraintsEverywhere_calc_every</td>
<td>1</td>
<td>ML_BSSN_ConstraintsEverywhere_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_ConstraintsInterior_calc_every</td>
<td>1</td>
<td>ML_BSSN_ConstraintsInterior_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_InitialADMBase1Everywhere_calc_offset</td>
<td>0</td>
<td>ML_BSSN_InitialADMBase1Everywhere_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_InitialADMBase2Interior_calc_offset</td>
<td>0</td>
<td>ML_BSSN_InitialADMBase2Interior_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_InitialADMBase2BoundaryScalar_calc_offset</td>
<td>0</td>
<td>ML_BSSN_InitialADMBase2BoundaryScalar_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_EnforceEverywhere_calc_offset</td>
<td>0</td>
<td>ML_BSSN_EnforceEverywhere_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_ADMBaseEverywhere_calc_offset</td>
<td>0</td>
<td>ML_BSSN_ADMBaseEverywhere_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_ADMBaseInterior_calc_offset</td>
<td>0</td>
<td>ML_BSSN_ADMBaseInterior_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_ADMBaseBoundaryScalar_calc_offset</td>
<td>0</td>
<td>ML_BSSN_ADMBaseBoundaryScalar_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_EvolutionInterior_calc_offset</td>
<td>0</td>
<td>ML_BSSN_EvolutionInterior_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_EvolutionInteriorSplitBy1_calc_offset</td>
<td>0</td>
<td>ML_BSSN_EvolutionInteriorSplitBy1_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_EvolutionInteriorSplitBy2_calc_offset</td>
<td>0</td>
<td>ML_BSSN_EvolutionInteriorSplitBy2_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_EvolutionInteriorSplitBy3_calc_offset</td>
<td>0</td>
<td>ML_BSSN_EvolutionInteriorSplitBy3_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_EvolutionBoundaryScalar_calc_offset</td>
<td>0</td>
<td>ML_BSSN_EvolutionBoundaryScalar_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_EvolutionAnalysisInit_calc_offset</td>
<td>0</td>
<td>ML_BSSN_EvolutionAnalysisInit_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_EvolutionAnalysisInterior_calc_offset</td>
<td>0</td>
<td>ML_BSSN_EvolutionAnalysisInterior_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_ConstraintsEverywhere_calc_offset</td>
<td>0</td>
<td>ML_BSSN_ConstraintsEverywhere_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_BSSN_ConstraintsInterior_calc_offset</td>
<td>0</td>
<td>ML_BSSN_ConstraintsInterior_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>phi_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>gt11_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>gt12_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>gt13_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>gt22_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>gt23_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>gt33_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>Xt1_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>Xt2_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>Xt3_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>trK_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>At11_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>At12_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>At13_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>At22_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>At23_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>At33_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>alpha_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>A_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>beta1_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>beta2_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>beta3_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>B1_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>B2_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>B3_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_log_confac_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_metric_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_Gamma_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_trace_curv_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_curv_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_lapse_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_dtlapse_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_shift_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_dtshift_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>phi_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>gt11_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>gt12_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>gt13_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>gt22_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>gt23_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>gt33_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>Xt1_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>Xt2_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>Xt3_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>trK_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>At11_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>At12_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>At13_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>At22_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>At23_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>At33_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>alpha_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>A_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>beta1_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>beta2_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>beta3_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>B1_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>B2_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>B3_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_log_confac_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_metric_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_Gamma_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_trace_curv_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_curv_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_lapse_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_dtlapse_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_shift_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_dtshift_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>phi_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt11_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt12_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt13_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt22_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt23_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt33_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>Xt1_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>Xt2_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>Xt3_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>trK_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At11_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At12_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At13_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At22_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At23_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At33_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>alpha_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>A_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>beta1_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>beta2_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>beta3_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>B1_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>B2_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>B3_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_log_confac_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_metric_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_Gamma_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_trace_curv_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_curv_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_lapse_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_dtlapse_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_shift_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_dtshift_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>phi_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt11_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt12_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt13_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt22_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt23_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt33_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>Xt1_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>Xt2_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>Xt3_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>trK_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At11_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At12_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At13_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At22_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At23_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At33_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>alpha_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>A_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>beta1_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>beta2_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>beta3_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>B1_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>B2_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>B3_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_log_confac_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_metric_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_Gamma_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_trace_curv_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_curv_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_lapse_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_dtlapse_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_shift_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_dtshift_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="ml_admconstraints">ML_ADMConstraints</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>0</td>
<td>verbose</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>other_timelevels</td>
<td>1</td>
<td>Number of active timelevels for non-evolved grid functions</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>tile_size</td>
<td>-1</td>
<td>Loop tile size</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_ADMConstraints_MaxNumEvolvedVars</td>
<td>0</td>
<td>Number of evolved variables used by this thorn</td>
<td>0:0 :: "Number of evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>ML_ADMConstraints_MaxNumArrayEvolvedVars</td>
<td>0</td>
<td>Number of Array evolved variables used by this thorn</td>
<td>0:0 :: "Number of Array evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>timelevels</td>
<td>3</td>
<td>Number of active timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>rhs_timelevels</td>
<td>1</td>
<td>Number of active RHS timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_ADMConstraints_evaluate_calc_every</td>
<td>1</td>
<td>ML_ADMConstraints_evaluate_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_ADMConstraints_evaluate_calc_offset</td>
<td>0</td>
<td>ML_ADMConstraints_evaluate_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="ml_ccz4">ML_CCZ4</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>evolution_method</td>
<td></td>
<td>evolution_method</td>
<td>"ML_CCZ4" :: ""<em>OR</em></td>
</tr>
<tr>
<td>lapse_evolution_method</td>
<td></td>
<td>lapse_evolution_method</td>
<td>"ML_CCZ4" :: ""<em>OR</em></td>
</tr>
<tr>
<td>shift_evolution_method</td>
<td></td>
<td>shift_evolution_method</td>
<td>"ML_CCZ4" :: ""<em>OR</em></td>
</tr>
<tr>
<td>dtlapse_evolution_method</td>
<td></td>
<td>dtlapse_evolution_method</td>
<td>"ML_CCZ4" :: ""<em>OR</em></td>
</tr>
<tr>
<td>dtshift_evolution_method</td>
<td></td>
<td>dtshift_evolution_method</td>
<td>"ML_CCZ4" :: ""<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>0</td>
<td>verbose</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>other_timelevels</td>
<td>1</td>
<td>Number of active timelevels for non-evolved grid functions</td>
<td>0:4 :: ""<em>OR</em></td>
</tr>
<tr>
<td>GammaShift</td>
<td>0.5</td>
<td>CCZ4 dovariant shift term in Gamma</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>dampk1</td>
<td>0</td>
<td>CCZ4 damping term 1 for Theta and Z</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>dampk2</td>
<td>0</td>
<td>CCZ4 damping term 2 for Theta and Z</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>harmonicF</td>
<td>1</td>
<td>d/dt alpha = - f alpha^n K   (harmonic: f=1, 1+log: f=2)</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>alphaDriver</td>
<td>0</td>
<td>d/dt alpha = ... - alphaDriver (alpha - 1)   (use 1/M (?))</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftGammaCoeff</td>
<td>0</td>
<td>d/dt beta^i = C Xt^i   (use C=0.75/M)</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>betaDriver</td>
<td>0</td>
<td>d/dt beta^i = ... - betaDriver alpha^shiftAlphaPower beta^i   (use 1/M (?))</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftAlphaPower</td>
<td>0</td>
<td>d/dt beta^i = ... - betaDriver alpha^shiftAlphaPower beta^i   (use 0 (?))</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>spatialBetaDriverRadius</td>
<td>1000000000000</td>
<td>Radius at which the betaDriver starts to be reduced</td>
<td>(0:* :: "positive"<em>OR</em></td>
</tr>
<tr>
<td>spatialShiftGammaCoeffRadius</td>
<td>1000000000000</td>
<td>Radius at which shiftGammaCoeff starts to be reduced</td>
<td>(0:* :: "positive"<em>OR</em></td>
</tr>
<tr>
<td>minimumLapse</td>
<td>0</td>
<td>Enforced minimum of the lapse function</td>
<td>0:* :: "non-negative"<em>OR</em></td>
</tr>
<tr>
<td>epsDiss</td>
<td>0</td>
<td>Dissipation strength</td>
<td>0:* :: "non-negative"<em>OR</em></td>
</tr>
<tr>
<td>LapseACoeff</td>
<td>-1.</td>
<td>(OUTDATED) Evolve time derivative of lapse A? (now evolveA)</td>
<td>0. :: "off"<em>OR</em>  1. :: "on"<em>OR</em>  -1. :: "default"<em>OR</em></td>
</tr>
<tr>
<td>ShiftBCoeff</td>
<td>-1.</td>
<td>(OUTDATED) Evolve time derivative of shift B^i? (now evolveB)</td>
<td>0. :: "off"<em>OR</em>  1. :: "on"<em>OR</em>  -1. :: "default"<em>OR</em></td>
</tr>
<tr>
<td>LapseAdvectionCoeff</td>
<td>-1.</td>
<td>(OUTDATED) Advect lapse? (now advectLapse)</td>
<td>0. :: "off"<em>OR</em>  1. :: "on"<em>OR</em>  -1. :: "default"<em>OR</em></td>
</tr>
<tr>
<td>ShiftAdvectionCoeff</td>
<td>-1.</td>
<td>(OUTDATED) Advect shift? (now advectShift)</td>
<td>0. :: "off"<em>OR</em>  1. :: "on"<em>OR</em>  -1. :: "default"<em>OR</em></td>
</tr>
<tr>
<td>fdOrder</td>
<td>4</td>
<td>Finite differencing order</td>
<td>2 :: ""<em>OR</em>  4 :: ""<em>OR</em>  6 :: ""<em>OR</em>  8 :: ""<em>OR</em></td>
</tr>
<tr>
<td>conformalMethod</td>
<td>1</td>
<td>Treatment of conformal factor</td>
<td>1 :: "W method"<em>OR</em></td>
</tr>
<tr>
<td>evolveA</td>
<td>0</td>
<td>Evolve time derivative of lapse A? (former LapseACoeff)</td>
<td>0 :: "off"<em>OR</em>  1 :: "on"<em>OR</em></td>
</tr>
<tr>
<td>evolveB</td>
<td>1</td>
<td>Evolve time derivative of shift B^i? (former ShiftBCoeff)</td>
<td>0 :: "off"<em>OR</em>  1 :: "on"<em>OR</em></td>
</tr>
<tr>
<td>harmonicN</td>
<td>2</td>
<td>d/dt alpha = - f alpha^n K  (harmonic: n=2, 1+log: n=1)</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>shiftFormulation</td>
<td>0</td>
<td>shift formulation</td>
<td>0 :: "Gamma driver"<em>OR</em>  1 :: "harmonic"<em>OR</em></td>
</tr>
<tr>
<td>useSpatialBetaDriver</td>
<td>0</td>
<td>Enable spatially varying betaDriver</td>
<td>0 :: "off"<em>OR</em>  1 :: "on"<em>OR</em></td>
</tr>
<tr>
<td>useSpatialShiftGammaCoeff</td>
<td>0</td>
<td>Enable spatially varying shiftGammaCoeff</td>
<td>0 :: "off"<em>OR</em>  1 :: "on"<em>OR</em></td>
</tr>
<tr>
<td>advectLapse</td>
<td>1</td>
<td>Advect lapse? (former LapseAdvectionCoeff)</td>
<td>0 :: "off"<em>OR</em>  1 :: "on"<em>OR</em></td>
</tr>
<tr>
<td>advectShift</td>
<td>1</td>
<td>Advect shift? (former ShiftAdvectionCoeff)</td>
<td>0 :: "off"<em>OR</em>  1 :: "on"<em>OR</em></td>
</tr>
<tr>
<td>fixAdvectionTerms</td>
<td>0</td>
<td>Modify driver and advection terms to work better?</td>
<td>0 :: "off"<em>OR</em>  1 :: "on"<em>OR</em></td>
</tr>
<tr>
<td>tile_size</td>
<td>-1</td>
<td>Loop tile size</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_boundary_condition</td>
<td>"scalar"</td>
<td>Boundary condition for initial condition for some of the BSSN variables</td>
<td>"scalar" :: "not recommended; use ML_BSSN_Helper's value 'extrapolate-gammas' instead"<em>OR</em></td>
</tr>
<tr>
<td>rhs_boundary_condition</td>
<td>"scalar"</td>
<td>Boundary condition for BSSN RHS and some of the ADMBase variables</td>
<td>"scalar" :: "not recommended; use ML_BSSN_Helper's option 'NewRad' instead"<em>OR</em></td>
</tr>
<tr>
<td>rhs_evaluation</td>
<td>"splitBy"</td>
<td>Whether and how the RHS routine should be split to improve performance</td>
<td>"combined" :: "use a single routine (probably slow)"<em>OR</em>  "splitBy" :: "split into 3 routines via Kranc"<em>OR</em></td>
</tr>
<tr>
<td>my_initial_data</td>
<td>"default"</td>
<td>(OUTDATED)</td>
<td>"ADMBase" :: "from ADMBase"<em>OR</em>  "default" :: "do nothing"<em>OR</em></td>
</tr>
<tr>
<td>my_initial_boundary_condition</td>
<td>"default"</td>
<td>(OUTDATED)</td>
<td>"none" :: "none"<em>OR</em>  "default" :: "do nothing"<em>OR</em></td>
</tr>
<tr>
<td>my_rhs_boundary_condition</td>
<td>"default"</td>
<td>(OUTDATED)</td>
<td>"none" :: "none"<em>OR</em>  "static" :: "static"<em>OR</em>  "default" :: "do nothing"<em>OR</em></td>
</tr>
<tr>
<td>my_boundary_condition</td>
<td>"default"</td>
<td>(OUTDATED)</td>
<td>"none" :: "none"<em>OR</em>  "Minkowski" :: "Minkowski"<em>OR</em>  "default" :: "do nothing"<em>OR</em></td>
</tr>
<tr>
<td>dt_lapse_shift_method</td>
<td>"default"</td>
<td>(OUTDATED) Treatment of ADMBase dtlapse and dtshift</td>
<td>"correct" :: "(unused)"<em>OR</em>  "noLapseShiftAdvection" :: "(unused)"<em>OR</em>  "default" :: "do nothing"<em>OR</em></td>
</tr>
<tr>
<td>apply_dissipation</td>
<td>"default"</td>
<td>(OUTDATED) Whether to apply dissipation to the RHSs</td>
<td>"always" :: "yes"<em>OR</em>  "never" :: "no"<em>OR</em>  "default" :: "do nothing"<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_MaxNumEvolvedVars</td>
<td>26</td>
<td>Number of evolved variables used by this thorn</td>
<td>26:26 :: "Number of evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_MaxNumArrayEvolvedVars</td>
<td>0</td>
<td>Number of Array evolved variables used by this thorn</td>
<td>0:0 :: "Number of Array evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>timelevels</td>
<td>3</td>
<td>Number of active timelevels</td>
<td>0:4 :: ""<em>OR</em></td>
</tr>
<tr>
<td>rhs_timelevels</td>
<td>1</td>
<td>Number of active RHS timelevels</td>
<td>0:4 :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_InitialADMBase1Everywhere_calc_every</td>
<td>1</td>
<td>ML_CCZ4_InitialADMBase1Everywhere_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_InitialADMBase2Interior_calc_every</td>
<td>1</td>
<td>ML_CCZ4_InitialADMBase2Interior_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_InitialADMBase2BoundaryScalar_calc_every</td>
<td>1</td>
<td>ML_CCZ4_InitialADMBase2BoundaryScalar_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_EnforceEverywhere_calc_every</td>
<td>1</td>
<td>ML_CCZ4_EnforceEverywhere_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_ADMBaseEverywhere_calc_every</td>
<td>1</td>
<td>ML_CCZ4_ADMBaseEverywhere_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_ADMBaseInterior_calc_every</td>
<td>1</td>
<td>ML_CCZ4_ADMBaseInterior_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_ADMBaseBoundaryScalar_calc_every</td>
<td>1</td>
<td>ML_CCZ4_ADMBaseBoundaryScalar_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_EvolutionInterior_calc_every</td>
<td>1</td>
<td>ML_CCZ4_EvolutionInterior_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_EvolutionInteriorSplitBy1_calc_every</td>
<td>1</td>
<td>ML_CCZ4_EvolutionInteriorSplitBy1_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_EvolutionInteriorSplitBy2_calc_every</td>
<td>1</td>
<td>ML_CCZ4_EvolutionInteriorSplitBy2_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_EvolutionInteriorSplitBy3_calc_every</td>
<td>1</td>
<td>ML_CCZ4_EvolutionInteriorSplitBy3_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_EvolutionBoundaryScalar_calc_every</td>
<td>1</td>
<td>ML_CCZ4_EvolutionBoundaryScalar_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_EvolutionAnalysisInit_calc_every</td>
<td>1</td>
<td>ML_CCZ4_EvolutionAnalysisInit_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_EvolutionAnalysisInterior_calc_every</td>
<td>1</td>
<td>ML_CCZ4_EvolutionAnalysisInterior_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_ConstraintsEverywhere_calc_every</td>
<td>1</td>
<td>ML_CCZ4_ConstraintsEverywhere_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_ConstraintsInterior_calc_every</td>
<td>1</td>
<td>ML_CCZ4_ConstraintsInterior_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_InitialADMBase1Everywhere_calc_offset</td>
<td>0</td>
<td>ML_CCZ4_InitialADMBase1Everywhere_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_InitialADMBase2Interior_calc_offset</td>
<td>0</td>
<td>ML_CCZ4_InitialADMBase2Interior_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_InitialADMBase2BoundaryScalar_calc_offset</td>
<td>0</td>
<td>ML_CCZ4_InitialADMBase2BoundaryScalar_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_EnforceEverywhere_calc_offset</td>
<td>0</td>
<td>ML_CCZ4_EnforceEverywhere_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_ADMBaseEverywhere_calc_offset</td>
<td>0</td>
<td>ML_CCZ4_ADMBaseEverywhere_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_ADMBaseInterior_calc_offset</td>
<td>0</td>
<td>ML_CCZ4_ADMBaseInterior_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_ADMBaseBoundaryScalar_calc_offset</td>
<td>0</td>
<td>ML_CCZ4_ADMBaseBoundaryScalar_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_EvolutionInterior_calc_offset</td>
<td>0</td>
<td>ML_CCZ4_EvolutionInterior_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_EvolutionInteriorSplitBy1_calc_offset</td>
<td>0</td>
<td>ML_CCZ4_EvolutionInteriorSplitBy1_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_EvolutionInteriorSplitBy2_calc_offset</td>
<td>0</td>
<td>ML_CCZ4_EvolutionInteriorSplitBy2_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_EvolutionInteriorSplitBy3_calc_offset</td>
<td>0</td>
<td>ML_CCZ4_EvolutionInteriorSplitBy3_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_EvolutionBoundaryScalar_calc_offset</td>
<td>0</td>
<td>ML_CCZ4_EvolutionBoundaryScalar_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_EvolutionAnalysisInit_calc_offset</td>
<td>0</td>
<td>ML_CCZ4_EvolutionAnalysisInit_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_EvolutionAnalysisInterior_calc_offset</td>
<td>0</td>
<td>ML_CCZ4_EvolutionAnalysisInterior_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_ConstraintsEverywhere_calc_offset</td>
<td>0</td>
<td>ML_CCZ4_ConstraintsEverywhere_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_CCZ4_ConstraintsInterior_calc_offset</td>
<td>0</td>
<td>ML_CCZ4_ConstraintsInterior_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>phi_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>gt11_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>gt12_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>gt13_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>gt22_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>gt23_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>gt33_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>Xt1_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>Xt2_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>Xt3_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>trK_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>At11_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>At12_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>At13_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>At22_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>At23_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>At33_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>Theta_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>alpha_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>A_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>beta1_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>beta2_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>beta3_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>B1_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>B2_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>B3_bound</td>
<td>"skip"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_log_confac_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_metric_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_Gamma_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_trace_curv_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_curv_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_Theta_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_lapse_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_dtlapse_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_shift_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>ML_dtshift_bound</td>
<td>"none"</td>
<td>Boundary condition to implement</td>
<td>"flat" :: "Flat boundary condition"<em>OR</em>  "none" :: "No boundary condition"<em>OR</em>  "static" :: "Boundaries held fixed"<em>OR</em>  "radiative" :: "Radiation boundary condition"<em>OR</em>  "scalar" :: "Dirichlet boundary condition"<em>OR</em>  "newrad" :: "Improved radiative boundary condition"<em>OR</em>  "skip" :: "skip boundary condition code"<em>OR</em></td>
</tr>
<tr>
<td>phi_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>gt11_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>gt12_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>gt13_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>gt22_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>gt23_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>gt33_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>Xt1_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>Xt2_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>Xt3_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>trK_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>At11_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>At12_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>At13_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>At22_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>At23_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>At33_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>Theta_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>alpha_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>A_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>beta1_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>beta2_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>beta3_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>B1_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>B2_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>B3_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_log_confac_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_metric_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_Gamma_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_trace_curv_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_curv_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_Theta_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_lapse_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_dtlapse_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_shift_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>ML_dtshift_bound_speed</td>
<td>1.</td>
<td>characteristic speed at boundary</td>
<td>0:* :: "outgoing characteristic speed &gt; 0"<em>OR</em></td>
</tr>
<tr>
<td>phi_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt11_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt12_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt13_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt22_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt23_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt33_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>Xt1_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>Xt2_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>Xt3_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>trK_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At11_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At12_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At13_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At22_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At23_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At33_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>Theta_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>alpha_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>A_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>beta1_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>beta2_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>beta3_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>B1_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>B2_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>B3_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_log_confac_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_metric_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_Gamma_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_trace_curv_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_curv_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_Theta_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_lapse_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_dtlapse_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_shift_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_dtshift_bound_limit</td>
<td>0.</td>
<td>limit value for r -&gt; infinity</td>
<td><em>:</em> :: "value of limit value is unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>phi_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt11_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt12_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt13_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt22_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt23_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>gt33_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>Xt1_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>Xt2_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>Xt3_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>trK_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At11_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At12_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At13_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At22_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At23_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>At33_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>Theta_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>alpha_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>A_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>beta1_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>beta2_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>beta3_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>B1_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>B2_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>B3_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_log_confac_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_metric_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_Gamma_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_trace_curv_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_curv_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_Theta_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_lapse_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_dtlapse_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_shift_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
<tr>
<td>ML_dtshift_bound_scalar</td>
<td>0.</td>
<td>Dirichlet boundary value</td>
<td><em>:</em> :: "unrestricted"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="m_1">m</h3>
<h3 id="ml_bssn_test">ML_BSSN_Test</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="par">par</h3>
<h3 id="ml_admquantities">ML_ADMQuantities</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>0</td>
<td>verbose</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>other_timelevels</td>
<td>1</td>
<td>Number of active timelevels for non-evolved grid functions</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>conformalMethod</td>
<td>0</td>
<td>Treatment of conformal factor</td>
<td>0 :: "phi method"<em>OR</em>  1 :: "W method"<em>OR</em></td>
</tr>
<tr>
<td>tile_size</td>
<td>-1</td>
<td>Loop tile size</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_ADMQuantities_MaxNumEvolvedVars</td>
<td>0</td>
<td>Number of evolved variables used by this thorn</td>
<td>0:0 :: "Number of evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>ML_ADMQuantities_MaxNumArrayEvolvedVars</td>
<td>0</td>
<td>Number of Array evolved variables used by this thorn</td>
<td>0:0 :: "Number of Array evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>timelevels</td>
<td>3</td>
<td>Number of active timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>rhs_timelevels</td>
<td>1</td>
<td>Number of active RHS timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_ADMQuantities_calculate_calc_every</td>
<td>1</td>
<td>ML_ADMQuantities_calculate_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ML_ADMQuantities_calculate_calc_offset</td>
<td>0</td>
<td>ML_ADMQuantities_calculate_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h2 id="pittnullcode">PITTNullCode</h2>
<h3 id="sphericalharmonicrecon">SphericalHarmonicRecon</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header:</span><script type="math/tex">Header:</script></span></p>
<p>Cactus Code Thorn SphericalHarmonicRecon
Thorn Author(s)     : Yosef Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;</a>
Thorn Maintainer(s) : Yosef Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>This code is available under the  GPL General Public License, 
version 2, or later (see GPLv2 file included).</p>
<p>The code in this arrangement is a results of many years of work by
many different authors. Major contributors to this code include
(in alphabetical order)</p>
<p>M.C. Babiuc
N. T. Bishop
R. Gomez
R. A. Isaacson
L. Lehner
P. Papadopoulos
C. Reisswig
B. Szilagyi
J. Welling
J. Winicour
Y. Zlochower</p>
<p>If you use this code, then we request that you cite the following papers:</p>
<p>Title: Characteristic Extraction Tool for Gravitational Waveforms
 Authors: M.C. Babiuc, B. Szilagyi, J. Winicour, Y. Zlochower
 arXiv:1011.4223, Phys Rev D 84, 044057,
 doi: <a href="http://dx.doi.org/10.1103/PhysRevD.84.044057">http://dx.doi.org/10.1103/PhysRevD.84.044057</a></p>
<p>Title: Cauchy-characteristic matching
 Authors: N. Bishop, R. Isaacson, R. Gomez, L. Lehner, B. Szilagyi, J.
 Winicour arXiv: gr-qc/9801070
 In "Black Holes, Gravitational Radiation and the Universe"
 eds. B. Iyer and B. Bhawal (Kluwer, Dordrecht, Boston,1999)</p>
<p>This code is maintained by</p>
<p>M. C.Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
B. Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a>
C. Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Y. Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;</a></p>
<p>Please contact the maintainers of the code if you require
write access.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>order</td>
<td>4</td>
<td>order used in time interpolation / differentiation</td>
<td>2 :: "two or four"<em>OR</em>  4 :: "two or four"<em>OR</em></td>
</tr>
<tr>
<td>r_extract</td>
<td>50.0</td>
<td>the radius of the worldtube</td>
<td>(0:* :: "positive"<em>OR</em></td>
</tr>
<tr>
<td>metric_data_filename</td>
<td>"metric_Decomp.h5"</td>
<td>filename for the cauchy metric data</td>
<td>".<em>"   :: "the Cauchy metric data"*OR</em></td>
</tr>
<tr>
<td>time_derivative_in_file</td>
<td>"no"</td>
<td>is the time derivative of the metric in the cauchy file</td>
<td></td>
</tr>
<tr>
<td>override_extraction_parameters</td>
<td>no</td>
<td>never set this</td>
<td></td>
</tr>
<tr>
<td>override_spin</td>
<td>0</td>
<td>spin: never set this</td>
<td><em>:</em> :: "anything, but you probably want 0"<em>OR</em></td>
</tr>
<tr>
<td>override_nn</td>
<td>1</td>
<td>number of Chabyshev coefficition: never use this</td>
<td>1:* :: "positive: must actualy match the extraction run"<em>OR</em></td>
</tr>
<tr>
<td>override_na</td>
<td>1</td>
<td>number of angular coefficition: never use this</td>
<td>1:* :: "positive: must actualy match the extraction run"<em>OR</em></td>
</tr>
<tr>
<td>override_Rin</td>
<td>1</td>
<td>inner radius of extraction zone: ...</td>
<td>(0:* :: "positive"<em>OR</em></td>
</tr>
<tr>
<td>override_Rout</td>
<td>1</td>
<td>outer radius of extraction zone: ...</td>
<td>(0:* :: "positive"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="nullconstr">NullConstr</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<p>Cactus Code Thorn NullConstr
Thorn Author(s)     : Bela Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a>
                    : N T Bishop <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#105;&#115;&#104;&#111;&#110;&#116;&#64;&#117;&#110;&#105;&#115;&#97;&#46;&#97;&#99;&#46;&#122;&#97;">&#98;&#105;&#115;&#104;&#111;&#110;&#116;&#64;&#117;&#110;&#105;&#115;&#97;&#46;&#97;&#99;&#46;&#122;&#97;</a>
                    : Chi Wai Lai <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#108;&#97;&#105;&#99;&#119;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#117;&#110;&#105;&#115;&#97;&#46;&#97;&#99;&#46;&#122;&#97;">&#108;&#97;&#105;&#99;&#119;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#117;&#110;&#105;&#115;&#97;&#46;&#97;&#99;&#46;&#122;&#97;</a>
Thorn Maintainer(s) : Bela Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a>
                    : N T Bishop <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#105;&#115;&#104;&#111;&#110;&#116;&#64;&#117;&#110;&#105;&#115;&#97;&#46;&#97;&#99;&#46;&#122;&#97;">&#98;&#105;&#115;&#104;&#111;&#110;&#116;&#64;&#117;&#110;&#105;&#115;&#97;&#46;&#97;&#99;&#46;&#122;&#97;</a>
                    : Chi Wai Lai <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#108;&#97;&#105;&#99;&#119;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#117;&#110;&#105;&#115;&#97;&#46;&#97;&#99;&#46;&#122;&#97;">&#108;&#97;&#105;&#99;&#119;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#117;&#110;&#105;&#115;&#97;&#46;&#97;&#99;&#46;&#122;&#97;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>This code is available under the  GPL General Public License, 
version 2, or later (see GPLv2 file included).</p>
<p>The code in this arrangement is a results of many years of work by
many different authors. Major contributors to this code include
(in alphabetical order)</p>
<p>M.C. Babiuc
N. T. Bishop
R. Gomez
R. A. Isaacson
L. Lehner
P. Papadopoulos
C. Reisswig
B. Szilagyi
J. Welling
J. Winicour
Y. Zlochower</p>
<p>If you use this code, then we request that you cite the following papers:</p>
<p>Title: Characteristic Extraction Tool for Gravitational Waveforms
 Authors: M.C. Babiuc, B. Szilagyi, J. Winicour, Y. Zlochower
 arXiv:1011.4223, Phys Rev D 84, 044057, 
 doi: <a href="http://dx.doi.org/10.1103/PhysRevD.84.044057">http://dx.doi.org/10.1103/PhysRevD.84.044057</a></p>
<p>Title: Cauchy-characteristic matching
 Authors: N. Bishop, R. Isaacson, R. Gomez, L. Lehner, B. Szilagyi, J.
 Winicour arXiv: gr-qc/9801070
 In "Black Holes, Gravitational Radiation and the Universe"
 eds. B. Iyer and B. Bhawal (Kluwer, Dordrecht, Boston,1999)</p>
<p>This code is maintained by</p>
<p>M. C.Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
B. Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a>
C. Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Y. Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;</a></p>
<p>Please contact the maintainers of the code if you require
write access.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="nullgrid">NullGrid</h3>
<p>Purpose of the thorn:</p>
<p>This thorn demonstrates the use of the Cactus interpolation API.
This code is available under the  GPL General Public License, 
version 2, or later (see GPLv2 file included).</p>
<p>The code in this arrangement is a results of many years of work by
many different authors. Major contributors to this code include
(in alphabetical order)</p>
<p>M.C. Babiuc
N. T. Bishop
R. Gomez
R. A. Isaacson
L. Lehner
P. Papadopoulos
C. Reisswig
B. Szilagyi
J. Welling
J. Winicour
Y. Zlochower</p>
<p>If you use this code, then we request that you cite the following papers:</p>
<p>Title: Characteristic Extraction Tool for Gravitational Waveforms
 Authors: M.C. Babiuc, B. Szilagyi, J. Winicour, Y. Zlochower
 arXiv:1011.4223, Phys Rev D 84, 044057,
 doi: <a href="http://dx.doi.org/10.1103/PhysRevD.84.044057">http://dx.doi.org/10.1103/PhysRevD.84.044057</a></p>
<p>Title: Cauchy-characteristic matching
 Authors: N. Bishop, R. Isaacson, R. Gomez, L. Lehner, B. Szilagyi, J.
 Winicour arXiv: gr-qc/9801070
 In "Black Holes, Gravitational Radiation and the Universe"
 eds. B. Iyer and B. Bhawal (Kluwer, Dordrecht, Boston,1999)</p>
<p>This code is maintained by</p>
<p>M. C.Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
B. Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a>
C. Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Y. Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;</a></p>
<p>Please contact the maintainers of the code if you require
write access.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>0</td>
<td>Should this thorn be verbose or not</td>
<td>0:1  :: "0 or 1"<em>OR</em></td>
</tr>
<tr>
<td>null_xin</td>
<td>41</td>
<td>Innermost compactified radial point</td>
<td>0.0:<em>::  "positive real number"*OR</em>}0.5*OR**OR*CCTK_REAL null_rwt "Compactification Parameter"<em>OR</em>{<em>OR*0.0:</em>::  "positive real number"<em>OR</em>}1.0*OR**OR*CCTK_INT N_radial_pts "radial gridsize"<em>OR</em>{<em>OR</em>  4:<em>:: "pos"*OR</em>}21*OR**OR*####################################<em>OR</em>### ANGULAR GRID*OR*####################################<em>OR**OR*int N_ang_pts_inside_eq "nr of points inside equator, spanning the diameter of the unit circle"*OR</em>{<em>OR</em>  2:* :: "larger than one"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="nullpsiint">NullPsiInt</h3>
<p>Cactus Code Thorn NullPsi4IO
Author(s)    : Maria Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Maria Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
Licence      : N</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>not documented
This code is available under the  GPL General Public License, 
version 2, or later (see GPLv2 file included).</p>
<p>The code in this arrangement is a results of many years of work by
many different authors. Major contributors to this code include
(in alphabetical order)</p>
<p>M.C. Babiuc
N. T. Bishop
R. Gomez
R. A. Isaacson
L. Lehner
P. Papadopoulos
C. Reisswig
B. Szilagyi
J. Welling
J. Winicour
Y. Zlochower</p>
<p>If you use this code, then we request that you cite the following papers:</p>
<p>Title: Characteristic Extraction Tool for Gravitational Waveforms
 Authors: M.C. Babiuc, B. Szilagyi, J. Winicour, Y. Zlochower
 arXiv:1011.4223, Phys Rev D 84, 044057,
 doi: <a href="http://dx.doi.org/10.1103/PhysRevD.84.044057">http://dx.doi.org/10.1103/PhysRevD.84.044057</a></p>
<p>Title: Cauchy-characteristic matching
 Authors: N. Bishop, R. Isaacson, R. Gomez, L. Lehner, B. Szilagyi, J.
 Winicour arXiv: gr-qc/9801070
 In "Black Holes, Gravitational Radiation and the Universe"
 eds. B. Iyer and B. Bhawal (Kluwer, Dordrecht, Boston,1999)</p>
<p>This code is maintained by</p>
<p>M. C.Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
B. Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a>
C. Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Y. Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;</a></p>
<p>Please contact the maintainers of the code if you require
write access.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="nulldecomp">NullDecomp</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<p>Cactus Code Thorn NullDecomp
Thorn Author(s)     : Yosef Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#112;&#104;&#121;&#115;&#46;&#117;&#116;&#98;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#112;&#104;&#121;&#115;&#46;&#117;&#116;&#98;&#46;&#101;&#100;&#117;</a>
Thorn Maintainer(s) : Yosef Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#112;&#104;&#121;&#115;&#46;&#117;&#116;&#98;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#112;&#104;&#121;&#115;&#46;&#117;&#116;&#98;&#46;&#101;&#100;&#117;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>This code is available under the  GPL General Public License, 
version 2, or later (see GPLv2 file included).</p>
<p>The code in this arrangement is a results of many years of work by
many different authors. Major contributors to this code include
(in alphabetical order)</p>
<p>M.C. Babiuc
N. T. Bishop
R. Gomez
R. A. Isaacson
L. Lehner
P. Papadopoulos
C. Reisswig
B. Szilagyi
J. Welling
J. Winicour
Y. Zlochower</p>
<p>If you use this code, then we request that you cite the following papers:</p>
<p>Title: Characteristic Extraction Tool for Gravitational Waveforms
 Authors: M.C. Babiuc, B. Szilagyi, J. Winicour, Y. Zlochower
 arXiv:1011.4223, Phys Rev D 84, 044057, 
 doi: <a href="http://dx.doi.org/10.1103/PhysRevD.84.044057">http://dx.doi.org/10.1103/PhysRevD.84.044057</a></p>
<p>Title: Cauchy-characteristic matching
 Authors: N. Bishop, R. Isaacson, R. Gomez, L. Lehner, B. Szilagyi, J.
 Winicour arXiv: gr-qc/9801070
 In "Black Holes, Gravitational Radiation and the Universe"
 eds. B. Iyer and B. Bhawal (Kluwer, Dordrecht, Boston,1999)</p>
<p>This code is maintained by</p>
<p>M. C.Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
B. Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a>
C. Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Y. Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;</a></p>
<p>Please contact the maintainers of the code if you require
write access.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>l_max</td>
<td>9</td>
<td>Decompose into spherical harmonics \ell = spin up to \ell = l_max</td>
<td>2: :: "2 or greater "<em>OR</em></td>
</tr>
<tr>
<td>use_rsYlm</td>
<td>"no"</td>
<td>use the rsYlm's rather than the standard sYlm's</td>
<td></td>
</tr>
<tr>
<td>store_ylms</td>
<td>"yes"</td>
<td>should the Ylm's be stored rather than recomputed each time?</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="nullnews">NullNews</h3>
<p>This code is available under the  GPL General Public License, 
version 2, or later (see GPLv2 file included).</p>
<p>The code in this arrangement is a results of many years of work by
many different authors. Major contributors to this code include
(in alphabetical order)</p>
<p>M.C. Babiuc
N. T. Bishop
R. Gomez
R. A. Isaacson
L. Lehner
P. Papadopoulos
C. Reisswig
B. Szilagyi
J. Welling
J. Winicour
Y. Zlochower</p>
<p>If you use this code, then we request that you cite the following papers:</p>
<p>Title: Characteristic Extraction Tool for Gravitational Waveforms
 Authors: M.C. Babiuc, B. Szilagyi, J. Winicour, Y. Zlochower
 arXiv:1011.4223, Phys Rev D 84, 044057,
 doi: <a href="http://dx.doi.org/10.1103/PhysRevD.84.044057">http://dx.doi.org/10.1103/PhysRevD.84.044057</a></p>
<p>Title: Cauchy-characteristic matching
 Authors: N. Bishop, R. Isaacson, R. Gomez, L. Lehner, B. Szilagyi, J.
 Winicour arXiv: gr-qc/9801070
 In "Black Holes, Gravitational Radiation and the Universe"
 eds. B. Iyer and B. Bhawal (Kluwer, Dordrecht, Boston,1999)</p>
<p>This code is maintained by</p>
<p>M. C.Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
B. Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a>
C. Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Y. Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;</a></p>
<p>Please contact the maintainers of the code if you require
write access.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>linearized_news</td>
<td>"no"</td>
<td>shall we calculate only the linearized news</td>
<td></td>
</tr>
<tr>
<td>first_order_scheme</td>
<td>"yes"</td>
<td>should angular derviatives be reduced to first order?</td>
<td></td>
</tr>
<tr>
<td>filter_scri_fields</td>
<td>"no"</td>
<td>filter null code fields before constructing News</td>
<td></td>
</tr>
<tr>
<td>filter_omega</td>
<td>"no"</td>
<td>filter omega and comega</td>
<td></td>
</tr>
<tr>
<td>filter_news</td>
<td>"no"</td>
<td>filter news (prior to intorpolation)</td>
<td></td>
</tr>
<tr>
<td>write_spherical_harmonics</td>
<td>"no"</td>
<td>Write the spherical harmonics of the News to a file?</td>
<td></td>
</tr>
<tr>
<td>NewsSpinWeight</td>
<td>2</td>
<td>What weight for the News when writing the spherical harmonics?</td>
<td>0:2 :: "Small range"<em>OR</em></td>
</tr>
<tr>
<td>DEBUG_skip_BondiNews</td>
<td>"no"</td>
<td>should the bondi news algorithm be skipped?</td>
<td></td>
</tr>
<tr>
<td>debug_output</td>
<td>"no"</td>
<td>Decompose also J and omega at Scri for debugging purposes</td>
<td></td>
</tr>
<tr>
<td>interp_to_constant_uBondi</td>
<td>5</td>
<td>Interpolate quantities at Scri to constant Bondi time</td>
<td>1:* :: "anything &gt;= 1"<em>OR</em></td>
</tr>
<tr>
<td>use_linearized_omega</td>
<td>0.0</td>
<td>This switch is useful when the code is operating in the linear regime</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>news_interp_order</td>
<td>3</td>
<td>Order for news interpolation</td>
<td>1:6   :: "Choose between first, second, third, and fourth-order"<em>OR</em></td>
</tr>
<tr>
<td>Jl_deriv_order</td>
<td>2</td>
<td>What order shall we use for the l derivative of J at scri?</td>
<td>1:4 :: "Choose between first, second, third and fourth"<em>OR</em></td>
</tr>
<tr>
<td>mask_Psi4</td>
<td>"no"</td>
<td>should Psi4 be masked over used points?</td>
<td></td>
</tr>
<tr>
<td>mask_NewsB</td>
<td>"no"</td>
<td>should NewsB be masked over used points?</td>
<td></td>
</tr>
<tr>
<td>Ylm_at_Scri</td>
<td>"no"</td>
<td>This switch is introduced to check convergence for the spherical decomposition</td>
<td></td>
</tr>
<tr>
<td>compute_lin_strain</td>
<td>no</td>
<td>Compute linearized strain?</td>
<td></td>
</tr>
<tr>
<td>linearized_inertial_frame</td>
<td>no</td>
<td>Interpolation to inertial angular coordinates is linearized</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="sphericalharmonicrecongen">SphericalHarmonicReconGen</h3>
<p>Cactus Code Thorn SphericalHarmonicReconGen
Thorn Author(s)     : Christian Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Thorn Maintainer(s) : Christian Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Licence      : lGPL</p>
<hr />
<p>Purpose of the thorn: </p>
<p>Reads in ADM metric boundary data from a file. The files must contain scalar spherical harmonic modes up to some lmax
for the lapse, shift, and 3-metric decomposed on some finite-radius coordinate sphere S^2.
Gnuplot compatible ASCII files are supported (this includes Cactus'/Llama's Worldtube output), as well as
some SpEC specific ASCII files, and SpEC HDF5 output.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>format</td>
<td>"ASCII"</td>
<td>Boundary data file format</td>
<td>ASCII      :: "standard ASCII format: lm-modes and spheres are stored in a 2d array (gnuplot style) for a given timestep"<em>OR</em>  DAT        :: "optimized ASCII format: all variables and lm-modes are stored in one row for a given timestep"<em>OR</em>  DAT-v2     :: "optimized ASCII format: all variables and lm-modes are stored in one row for a given timestep. m-modes are in reverse order."<em>OR</em>  SpEC-H5    :: "SpEC-HDF5 format: Data is stored in HDF5 files grouped according to SpEC output."<em>OR</em>  SpEC-H5-v2 :: "SpEC-HDF5 format (v2): Data is stored in HDF5 files grouped according to new SpEC output."<em>OR</em></td>
</tr>
<tr>
<td>disable_auto_time_offset</td>
<td>no</td>
<td>Should the automatically determined time-offset be diabled?</td>
<td></td>
</tr>
<tr>
<td>adjust_timestep</td>
<td>no</td>
<td>Should the time-step be adjusted? Ignored if time_interpolate==false.</td>
<td></td>
</tr>
<tr>
<td>sphere_number</td>
<td>0</td>
<td>the sphere number (if multiple spheres are present in one file) that corresponds to the worldtube radius NullSHRExtract::cr</td>
<td>0:* :: "positive"<em>OR</em></td>
</tr>
<tr>
<td>lmaxInFile</td>
<td>0</td>
<td>maximum l-mode contained in file (only needed for DAT format)</td>
<td>0:* :: "anything positive"<em>OR</em></td>
</tr>
<tr>
<td>time_derivative_in_file</td>
<td>"no"</td>
<td>is the time derivative of the metric in the cauchy file</td>
<td></td>
</tr>
<tr>
<td>time_fd_order</td>
<td>4</td>
<td>the order of accuracy of time derivative if not contained in file</td>
<td>2  :: "second-order"<em>OR</em>   4  :: "fourth-order"<em>OR</em></td>
</tr>
<tr>
<td>time_interpolate</td>
<td>no</td>
<td>Interpolate coefficients to different dt?</td>
<td></td>
</tr>
<tr>
<td>initial_time</td>
<td>0.0</td>
<td>time from the worldtube data that we use as first characteristic timestep (this is a relative time, i.e. we always count the time from 0, independent of the actual initial time t_0 found in the file)</td>
<td><em>:</em> :: "anything"<em>OR</em></td>
</tr>
<tr>
<td>initial_relaxation_time</td>
<td>0.0</td>
<td>A time intervall for which we just use the initial set of metric data in order to relax the characteristic slice towards our initial data</td>
<td>0:* :: "A psoitive timescale"<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>no</td>
<td>turn verbosity on/off</td>
<td></td>
</tr>
<tr>
<td>cached_timesteps</td>
<td>0</td>
<td>Number of timesteps that shall be read in advance and cached in memory for faster access.</td>
<td>0:* :: "anything positive"<em>OR</em></td>
</tr>
<tr>
<td>sYlm_convention</td>
<td>Goldberg67</td>
<td>convention of sYlm's used for decomposed input worldtube data.</td>
<td>Goldberg67             :: "Convention used in the Goldberg 1967 paper."<em>OR</em>   Condon-Shortley-Phase  :: "Definition that differs by a factor (-1)^m wrt to the Goldberg67 definition."<em>OR</em></td>
</tr>
<tr>
<td>dt_tolerance</td>
<td>1e-9</td>
<td>A minimum tolerance for which timesteps are considered being identical</td>
<td>0:* :: "Small and positive"<em>OR</em></td>
</tr>
<tr>
<td>file</td>
<td>""</td>
<td>The boundary data file. If this string is empty, we assume that the user provided files for each quantity individually (parameters below)</td>
<td>""   :: "a valid filename"<em>OR</em></td>
</tr>
<tr>
<td>path</td>
<td>""</td>
<td>the directory that contains the input files, leave blank if filenames contain directory paths already</td>
<td>""   :: "a path name"<em>OR</em></td>
</tr>
<tr>
<td>column_iteration</td>
<td>-1</td>
<td>the column of the iteration (counting from 1)</td>
<td>-1  :: "-1 if not avalaible"<em>OR</em>  1:* :: "column number"<em>OR</em></td>
</tr>
<tr>
<td>column_time</td>
<td>1</td>
<td>the column of the time (counting from 1)</td>
<td>-1  :: "-1 if not avalaible"<em>OR</em>  1:* :: "column number"<em>OR</em></td>
</tr>
<tr>
<td>column_radius</td>
<td>-1</td>
<td>the column of the radius (counting from 1)</td>
<td>-1  :: "-1 if not avalaible"<em>OR</em>  1:* :: "column number"<em>OR</em></td>
</tr>
<tr>
<td>column_lmax</td>
<td>-1</td>
<td>the column of number of l-modes (counting from 1)</td>
<td>-1  :: "-1 if not avalaible"<em>OR</em>  1:* :: "column number"<em>OR</em></td>
</tr>
<tr>
<td>column_n_variables</td>
<td>-1</td>
<td>the column of number of variables (counting from 1)</td>
<td>-1  :: "-1 if not avalaible"<em>OR</em>  1:* :: "column number"<em>OR</em></td>
</tr>
<tr>
<td>column_data</td>
<td>3</td>
<td>the column where the data begins (only needed for DAT format)</td>
<td>2:* :: "anything greater than 2"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="nullinterp">NullInterp</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<p>Cactus Code Thorn NullInterp
Thorn Author(s)     : Maria Cristina Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#97;&#114;&#105;&#97;&#64;&#101;&#105;&#110;&#115;&#116;&#101;&#105;&#110;&#46;&#112;&#104;&#121;&#97;&#115;&#116;&#46;&#112;&#105;&#116;&#116;&#46;&#101;&#100;&#117;">&#109;&#97;&#114;&#105;&#97;&#64;&#101;&#105;&#110;&#115;&#116;&#101;&#105;&#110;&#46;&#112;&#104;&#121;&#97;&#115;&#116;&#46;&#112;&#105;&#116;&#116;&#46;&#101;&#100;&#117;</a>
                    : Bela Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a>
                    : Yosef Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#101;&#105;&#110;&#115;&#116;&#101;&#105;&#110;&#46;&#112;&#104;&#121;&#97;&#115;&#116;&#46;&#112;&#105;&#116;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#101;&#105;&#110;&#115;&#116;&#101;&#105;&#110;&#46;&#112;&#104;&#121;&#97;&#115;&#116;&#46;&#112;&#105;&#116;&#116;&#46;&#101;&#100;&#117;</a>
Thorn Maintainer(s) : Maria Cristina Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#97;&#114;&#105;&#97;&#64;&#101;&#105;&#110;&#115;&#116;&#101;&#105;&#110;&#46;&#112;&#104;&#121;&#97;&#115;&#116;&#46;&#112;&#105;&#116;&#116;&#46;&#101;&#100;&#117;">&#109;&#97;&#114;&#105;&#97;&#64;&#101;&#105;&#110;&#115;&#116;&#101;&#105;&#110;&#46;&#112;&#104;&#121;&#97;&#115;&#116;&#46;&#112;&#105;&#116;&#116;&#46;&#101;&#100;&#117;</a>
                    : Bela Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>This code is available under the  GPL General Public License, 
version 2, or later (see GPLv2 file included).</p>
<p>The code in this arrangement is a results of many years of work by
many different authors. Major contributors to this code include
(in alphabetical order)</p>
<p>M.C. Babiuc
N. T. Bishop
R. Gomez
R. A. Isaacson
L. Lehner
P. Papadopoulos
C. Reisswig
B. Szilagyi
J. Welling
J. Winicour
Y. Zlochower</p>
<p>If you use this code, then we request that you cite the following papers:</p>
<p>Title: Characteristic Extraction Tool for Gravitational Waveforms
 Authors: M.C. Babiuc, B. Szilagyi, J. Winicour, Y. Zlochower
 arXiv:1011.4223, Phys Rev D 84, 044057,
 doi: <a href="http://dx.doi.org/10.1103/PhysRevD.84.044057">http://dx.doi.org/10.1103/PhysRevD.84.044057</a></p>
<p>Title: Cauchy-characteristic matching
 Authors: N. Bishop, R. Isaacson, R. Gomez, L. Lehner, B. Szilagyi, J.
 Winicour arXiv: gr-qc/9801070
 In "Black Holes, Gravitational Radiation and the Universe"
 eds. B. Iyer and B. Bhawal (Kluwer, Dordrecht, Boston,1999)</p>
<p>This code is maintained by</p>
<p>M. C.Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
B. Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a>
C. Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Y. Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;</a></p>
<p>Please contact the maintainers of the code if you require
write access.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>interpolation_order</td>
<td>3</td>
<td>Order for interpolation</td>
<td>1:6 :: "Choose between first, second, third, and fourth-order"<em>OR</em></td>
</tr>
<tr>
<td>deriv_accuracy</td>
<td>2</td>
<td>Order of derivative operators</td>
<td>2  :: "2<sup>nd</sup> order accurate derivatives"<em>OR</em>  4  :: "4<sup>th</sup> order accurate derivatives"  <em>OR</em></td>
</tr>
<tr>
<td>poison_test</td>
<td>"no"</td>
<td>should invalid interpolation input points be poisoned?</td>
<td></td>
</tr>
<tr>
<td>skip_interpolation</td>
<td>"no"</td>
<td>should the interpolation be skipped?</td>
<td></td>
</tr>
<tr>
<td>extended_guard_zone</td>
<td>"no"</td>
<td>should the set of guard points be extended to contain all inactive points?</td>
<td></td>
</tr>
<tr>
<td>poison_value</td>
<td>1.0e+10</td>
<td>use this value to mark illegal interpolation input points</td>
<td><em>:</em> :: "any value, should be something like a NaN"<em>OR</em></td>
</tr>
<tr>
<td>mask_testinterp_tolerance</td>
<td>1.0e-10</td>
<td>tolerance level when detecting interpolation values from illegal input points</td>
<td><em>:</em>    :: "any value, should be something like eps"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="sphericalharmonicdecomp">SphericalHarmonicDecomp</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header:</span><script type="math/tex">Header:</script></span></p>
<p>Cactus Code Thorn SphericalHarmonicDecomp
Thorn Author(s)     : Yosef Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;</a>
Thorn Maintainer(s) : Yosef Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>This code is available under the  GPL General Public License, 
version 2, or later (see GPLv2 file included).</p>
<p>The code in this arrangement is a results of many years of work by
many different authors. Major contributors to this code include
(in alphabetical order)</p>
<p>M.C. Babiuc
N. T. Bishop
R. Gomez
R. A. Isaacson
L. Lehner
P. Papadopoulos
C. Reisswig
B. Szilagyi
J. Welling
J. Winicour
Y. Zlochower</p>
<p>If you use this code, then we request that you cite the following papers:</p>
<p>Title: Characteristic Extraction Tool for Gravitational Waveforms
 Authors: M.C. Babiuc, B. Szilagyi, J. Winicour, Y. Zlochower
 arXiv:1011.4223, Phys Rev D 84, 044057,
 doi: <a href="http://dx.doi.org/10.1103/PhysRevD.84.044057">http://dx.doi.org/10.1103/PhysRevD.84.044057</a></p>
<p>Title: Cauchy-characteristic matching
 Authors: N. Bishop, R. Isaacson, R. Gomez, L. Lehner, B. Szilagyi, J.
 Winicour arXiv: gr-qc/9801070
 In "Black Holes, Gravitational Radiation and the Universe"
 eds. B. Iyer and B. Bhawal (Kluwer, Dordrecht, Boston,1999)</p>
<p>This code is maintained by</p>
<p>M. C.Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
B. Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a>
C. Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Y. Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;</a></p>
<p>Please contact the maintainers of the code if you require
write access.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>out_dir</td>
<td>""</td>
<td>output directory</td>
<td>"^$" :: "Empty stting -&gt; use IO::out_dir"<em>OR</em>  ".+" :: "directory name"<em>OR</em></td>
</tr>
<tr>
<td>max_spin</td>
<td>2</td>
<td>maximum absolute spin of fields</td>
<td>0:* :: "positive only"<em>OR</em></td>
</tr>
<tr>
<td>num_l_modes</td>
<td>7</td>
<td>number of l modes ... not lmax</td>
<td>1:* :: "1 or larger"<em>OR</em></td>
</tr>
<tr>
<td>num_m_modes</td>
<td>15</td>
<td>number of m modes ... = 2*mmax + 1</td>
<td>#  1:<em>:2 :: "must be odd and 1 or larger"*OR</em>#</td>
</tr>
<tr>
<td>num_n_modes</td>
<td>15</td>
<td>number of n modes</td>
<td>1:* :: " 1 or larger"<em>OR</em></td>
</tr>
<tr>
<td>num_mu_points</td>
<td>15</td>
<td>number of points in mu direction</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>num_phi_points</td>
<td>31</td>
<td>number of points in phi directions</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>num_x_points</td>
<td>31</td>
<td>number of points in phi directions</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>Rin</td>
<td>10.0</td>
<td>inner radius for decomp</td>
<td>0:* :: "positive"<em>OR</em></td>
</tr>
<tr>
<td>Rout</td>
<td>100.0</td>
<td>outer radius for decomp</td>
<td>(0:* :: "positive &gt; Rin"<em>OR</em></td>
</tr>
<tr>
<td>num_radii</td>
<td>100</td>
<td>number of radii</td>
<td>1:99 :: ""<em>OR</em>}1*OR**OR*CCTK_INT output_m_max "don't dump m modes larger than this"<em>OR</em>{<em>OR</em>  0:* :: "positive or zero"<em>OR</em></td>
</tr>
<tr>
<td>output_l_max</td>
<td>100</td>
<td>don't dump l modes larger than this</td>
<td>0:* :: "positive, but if l_max &lt;</td>
</tr>
<tr>
<td>sync_file_each_time</td>
<td>"yes"</td>
<td>not yet activated</td>
<td></td>
</tr>
<tr>
<td>do_test</td>
<td>"no"</td>
<td>to test or not to test</td>
<td></td>
</tr>
<tr>
<td>extract_spacetime_metric_every</td>
<td>0</td>
<td></td>
<td>0:* :: "0 or positive. 0 means never"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="nullexact">NullExact</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<p>Cactus Code Thorn NullExact
Thorn Author(s)     : Bela Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a>
                    : N T Bishop <N T Bishop <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#105;&#115;&#104;&#111;&#110;&#116;&#64;&#117;&#110;&#105;&#115;&#97;&#46;&#97;&#99;&#46;&#122;&#97;">&#98;&#105;&#115;&#104;&#111;&#110;&#116;&#64;&#117;&#110;&#105;&#115;&#97;&#46;&#97;&#99;&#46;&#122;&#97;</a>>
                    : Chi Wai Lai <Kevin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#108;&#97;&#105;&#99;&#119;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#117;&#110;&#105;&#115;&#97;&#46;&#97;&#99;&#46;&#122;&#97;">&#108;&#97;&#105;&#99;&#119;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#117;&#110;&#105;&#115;&#97;&#46;&#97;&#99;&#46;&#122;&#97;</a>>
Thorn Maintainer(s) : Bela Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a>
                    : N T Bishop <N T Bishop <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#105;&#115;&#104;&#111;&#110;&#116;&#64;&#117;&#110;&#105;&#115;&#97;&#46;&#97;&#99;&#46;&#122;&#97;">&#98;&#105;&#115;&#104;&#111;&#110;&#116;&#64;&#117;&#110;&#105;&#115;&#97;&#46;&#97;&#99;&#46;&#122;&#97;</a>>
                    : Chi Wai Lai <Kevin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#108;&#97;&#105;&#99;&#119;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#117;&#110;&#105;&#115;&#97;&#46;&#97;&#99;&#46;&#122;&#97;">&#108;&#97;&#105;&#99;&#119;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#117;&#110;&#105;&#115;&#97;&#46;&#97;&#99;&#46;&#122;&#97;</a>></p>
<hr />
<p>Purpose of the thorn:</p>
<p>This code is available under the  GPL General Public License, 
version 2, or later (see GPLv2 file included).</p>
<p>The code in this arrangement is a results of many years of work by
many different authors. Major contributors to this code include
(in alphabetical order)</p>
<p>M.C. Babiuc
N. T. Bishop
R. Gomez
R. A. Isaacson
L. Lehner
P. Papadopoulos
C. Reisswig
B. Szilagyi
J. Welling
J. Winicour
Y. Zlochower</p>
<p>If you use this code, then we request that you cite the following papers:</p>
<p>Title: Characteristic Extraction Tool for Gravitational Waveforms
 Authors: M.C. Babiuc, B. Szilagyi, J. Winicour, Y. Zlochower
 arXiv:1011.4223, Phys Rev D 84, 044057, 
 doi: <a href="http://dx.doi.org/10.1103/PhysRevD.84.044057">http://dx.doi.org/10.1103/PhysRevD.84.044057</a></p>
<p>Title: Cauchy-characteristic matching
 Authors: N. Bishop, R. Isaacson, R. Gomez, L. Lehner, B. Szilagyi, J.
 Winicour arXiv: gr-qc/9801070
 In "Black Holes, Gravitational Radiation and the Universe"
 eds. B. Iyer and B. Bhawal (Kluwer, Dordrecht, Boston,1999)</p>
<p>This code is maintained by</p>
<p>M. C.Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
B. Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a>
C. Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Y. Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;</a></p>
<p>Please contact the maintainers of the code if you require
write access.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="nullshrextract">NullSHRExtract</h3>
<p>Cactus Code Thorn NullExtract
Author(s)    : Maria Babiuc-Hamilton <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Maria Babiuc-Hamilton <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
Licence      : N</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>not documented
This code is available under the  GPL General Public License, 
version 2, or later (see GPLv2 file included).</p>
<p>The code in this arrangement is a results of many years of work by
many different authors. Major contributors to this code include
(in alphabetical order)</p>
<p>M.C. Babiuc
N. T. Bishop
R. Gomez
R. A. Isaacson
L. Lehner
P. Papadopoulos
C. Reisswig
B. Szilagyi
J. Welling
J. Winicour
Y. Zlochower</p>
<p>If you use this code, then we request that you cite the following papers:</p>
<p>Title: Characteristic Extraction Tool for Gravitational Waveforms
 Authors: M.C. Babiuc, B. Szilagyi, J. Winicour, Y. Zlochower
 arXiv:1011.4223, Phys Rev D 84, 044057,
 doi: <a href="http://dx.doi.org/10.1103/PhysRevD.84.044057">http://dx.doi.org/10.1103/PhysRevD.84.044057</a></p>
<p>Title: Cauchy-characteristic matching
 Authors: N. Bishop, R. Isaacson, R. Gomez, L. Lehner, B. Szilagyi, J.
 Winicour arXiv: gr-qc/9801070
 In "Black Holes, Gravitational Radiation and the Universe"
 eds. B. Iyer and B. Bhawal (Kluwer, Dordrecht, Boston,1999)</p>
<p>This code is maintained by</p>
<p>M. C.Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
B. Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a>
C. Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Y. Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;</a></p>
<p>Please contact the maintainers of the code if you require
write access.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>cr</td>
<td>2</td>
<td>radius of the worltube</td>
<td>(0.0:<em>::  "strictly positive real number"*OR</em>}0.5*OR**OR*CCTK_REAL mass "mass parameter"<em>OR</em>{<em>OR</em>  (0.0:<em>::  "strictly positive real number"*OR</em>}0.1*OR**OR*int l_max "l_max in Ylm"<em>OR</em>{<em>OR</em>   0:*   :: "positive"<em>OR</em></td>
</tr>
<tr>
<td>MinimumDistanceTo2Bp1</td>
<td>0.0</td>
<td>minimum distance from the extraction world-tube to the B+1 point</td>
<td>0:*  :: "positive. Should be O(1)"<em>OR</em></td>
</tr>
<tr>
<td>fcoef</td>
<td>0.01</td>
<td>Coefficient of the time dependence for Schwazchild time metric</td>
<td><em>:</em>    :: "anything"<em>OR</em>}0.0*OR**OR*CCTK_REAL Afact "Factor in front of the sine time dependence for Schwazchild time metric"<em>OR</em>{<em>OR</em> <em>:</em>    :: "anything"<em>OR</em>}0.0*OR**OR*CCTK_REAL elld_min_coef "definition of elld_min = elld_min_coef * dt**elld_min_pow"<em>OR</em>{<em>OR</em>  0:*   :: "larger than zero"<em>OR</em></td>
</tr>
<tr>
<td>elld_min_pow</td>
<td>2</td>
<td>definition of elld_min = elld_min_coef * dt**elld_min_pow</td>
<td>0:*   :: "larger than zero"<em>OR</em></td>
</tr>
<tr>
<td>halt_on_negative_elld</td>
<td>"no"</td>
<td>Should the code quit if the denominator of the null vector changes sign?</td>
<td></td>
</tr>
<tr>
<td>rl_min_coef</td>
<td>0.01</td>
<td>definition of rl_min = rl_min_coef * dt**rl_min_pow</td>
<td>0:*   :: "larger than zero"<em>OR</em></td>
</tr>
<tr>
<td>rl_min_pow</td>
<td>2</td>
<td>definition of rl_min = rl_min_coef * dt**rl_min_pow</td>
<td>0:*   :: "larger than zero"<em>OR</em></td>
</tr>
<tr>
<td>halt_on_negative_rl</td>
<td>"no"</td>
<td>Should the code quit if r_{lambda} goes negative?</td>
<td></td>
</tr>
<tr>
<td>WT_spherical_harmonics</td>
<td>"no"</td>
<td>Output the spherical harmonics of the Worldtube to a file?</td>
<td></td>
</tr>
<tr>
<td>WT_spherical_harmonics_on_nullgrid</td>
<td>"no"</td>
<td>Output the spherical harmonics on the nullgrid just off the Worldtube to a file?</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="nullevolve">NullEvolve</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<p>Cactus Code Thorn NullEvolve
Thorn Author(s)     : Y.Z. <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#114;&#97;&#118;&#101;&#110;&#46;&#112;&#104;&#121;&#97;&#115;&#116;&#46;&#112;&#105;&#116;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#114;&#97;&#118;&#101;&#110;&#46;&#112;&#104;&#121;&#97;&#115;&#116;&#46;&#112;&#105;&#116;&#116;&#46;&#101;&#100;&#117;</a>
Thorn Maintainer(s) : Y.Z. <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#114;&#97;&#118;&#101;&#110;&#46;&#112;&#104;&#121;&#97;&#115;&#116;&#46;&#112;&#105;&#116;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#114;&#97;&#118;&#101;&#110;&#46;&#112;&#104;&#121;&#97;&#115;&#116;&#46;&#112;&#105;&#116;&#116;&#46;&#101;&#100;&#117;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>Characteristic evolution</p>
<p>TODO:
add dissipation to J:
J_{ur} += eps * f&reg; * eth_ethb_J_r
This code is available under the  GPL General Public License, 
version 2, or later (see GPLv2 file included).</p>
<p>The code in this arrangement is a results of many years of work by
many different authors. Major contributors to this code include
(in alphabetical order)</p>
<p>M.C. Babiuc
N. T. Bishop
R. Gomez
R. A. Isaacson
L. Lehner
P. Papadopoulos
C. Reisswig
B. Szilagyi
J. Welling
J. Winicour
Y. Zlochower</p>
<p>If you use this code, then we request that you cite the following papers:</p>
<p>Title: Characteristic Extraction Tool for Gravitational Waveforms
 Authors: M.C. Babiuc, B. Szilagyi, J. Winicour, Y. Zlochower
 arXiv:1011.4223, Phys Rev D 84, 044057,
 doi: <a href="http://dx.doi.org/10.1103/PhysRevD.84.044057">http://dx.doi.org/10.1103/PhysRevD.84.044057</a></p>
<p>Title: Cauchy-characteristic matching
 Authors: N. Bishop, R. Isaacson, R. Gomez, L. Lehner, B. Szilagyi, J.
 Winicour arXiv: gr-qc/9801070
 In "Black Holes, Gravitational Radiation and the Universe"
 eds. B. Iyer and B. Bhawal (Kluwer, Dordrecht, Boston,1999)</p>
<p>This code is maintained by</p>
<p>M. C.Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
B. Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a>
C. Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Y. Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;</a></p>
<p>Please contact the maintainers of the code if you require
write access.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>first_order_scheme</td>
<td>"yes"</td>
<td>Should the first order (angular) scheme be used?</td>
<td></td>
</tr>
<tr>
<td>boundary_data</td>
<td>"flat"</td>
<td>Choose boundary data type</td>
<td>"whitehole"    ::"White hole boundary data"<em>OR</em>  "flat"    ::"flat boundary data"<em>OR</em>  "randomJ"   ::"random number boundary data"<em>OR</em></td>
</tr>
<tr>
<td>initial_J_data</td>
<td>"vanishing_J_scri"</td>
<td>What kind of initial data for J shall we pick?</td>
<td>"vanishing_J"        :: "vanishing J"<em>OR</em>  "vanishing_J_scri"    :: "vanishing J at scri"<em>OR</em>  "rotating_pulse"  :: "rotating pulse"<em>OR</em>  "compact_J"        :: "compact suport J"<em>OR</em>  "smooth_J"           :: "smoothly vanishing J"<em>OR</em>  "extracted_J"        :: "J as given by extraction"<em>OR</em>  "polynomial_J"   :: "J as third power polynomial to vanish J_xx at scri"<em>OR</em>  "fitted_linearized_J" :: "linearized fitted J based on some previous run"<em>OR</em></td>
</tr>
<tr>
<td>first_order_dissip</td>
<td>"no"</td>
<td>Should the first order agnular variables be dissipated?</td>
<td>#</td>
</tr>
<tr>
<td>use_rsYlm</td>
<td>0.0</td>
<td>do we use real spherical harmonics for compact pulse initial data</td>
<td>}"yes"<em>OR**OR</em>####################################################################################<em>OR</em>## DEBUGGING*OR*####################################################################################<em>OR**OR*restricted:*OR**OR*CCTK_REAL Diagnostics_Coord_x "the coordinate x at which diagnostics are to be measured" STEERABLE=ALWAYS*OR</em>{<em>OR</em>  0:1  :: "will test only for x &gt;= NullGrid::null_xin."<em>OR</em></td>
</tr>
<tr>
<td>DEBUG_skip_evolution</td>
<td>"no"</td>
<td>Should the evolution be turned off?</td>
<td>}"no"<em>OR**OR*BOOLEAN DEBUG_skip_J_update "Should the update of J be turned off?" *OR</em>{<em>OR</em>}"no"<em>OR**OR*BOOLEAN DEBUG_skip_NU_update "Should the update of NU be turned off?" *OR</em>{<em>OR</em>}"no"<em>OR**OR*BOOLEAN DEBUG_skip_CK_update "Should the update of CK be turned off?" *OR</em>{<em>OR</em>}"no"<em>OR**OR*BOOLEAN DEBUG_skip_B_update "Should the update of B be turned off?" *OR</em>{<em>OR</em>}"no"<em>OR**OR*BOOLEAN DEBUG_skip_CB_update "Should the update of CB be turned off?" *OR</em>{<em>OR</em>}"no"<em>OR**OR*BOOLEAN DEBUG_skip_Q_update "Should the update of Q be turned off?" *OR</em>{<em>OR</em>}"no"<em>OR**OR*BOOLEAN DEBUG_skip_U_update "Should the update of U be turned off?" *OR</em>{<em>OR</em>}"no"<em>OR**OR*BOOLEAN DEBUG_skip_W_update "Should the update of W be turned off?" *OR</em>{<em>OR</em>}"no"<em>OR**OR*BOOLEAN debug_verbose "should debugging messages be printed?"*OR</em>{<em>OR</em></td>
</tr>
<tr>
<td>old_J_xderiv</td>
<td>"no"</td>
<td>should we compute the x derivative of J with the old values?</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="nullvars">NullVars</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<p>Cactus Code Thorn NullVars
Thorn Author(s)     : Y.Z. <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#114;&#97;&#118;&#101;&#110;&#46;&#112;&#104;&#121;&#97;&#115;&#116;&#46;&#112;&#105;&#116;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#114;&#97;&#118;&#101;&#110;&#46;&#112;&#104;&#121;&#97;&#115;&#116;&#46;&#112;&#105;&#116;&#116;&#46;&#101;&#100;&#117;</a>
Thorn Maintainer(s) : Y.Z. <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#114;&#97;&#118;&#101;&#110;&#46;&#112;&#104;&#121;&#97;&#115;&#116;&#46;&#112;&#105;&#116;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#114;&#97;&#118;&#101;&#110;&#46;&#112;&#104;&#121;&#97;&#115;&#116;&#46;&#112;&#105;&#116;&#116;&#46;&#101;&#100;&#117;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>This code is available under the  GPL General Public License, 
version 2, or later (see GPLv2 file included).</p>
<p>The code in this arrangement is a results of many years of work by
many different authors. Major contributors to this code include
(in alphabetical order)</p>
<p>M.C. Babiuc
N. T. Bishop
R. Gomez
R. A. Isaacson
L. Lehner
P. Papadopoulos
C. Reisswig
B. Szilagyi
J. Welling
J. Winicour
Y. Zlochower</p>
<p>If you use this code, then we request that you cite the following papers:</p>
<p>Title: Characteristic Extraction Tool for Gravitational Waveforms
 Authors: M.C. Babiuc, B. Szilagyi, J. Winicour, Y. Zlochower
 arXiv:1011.4223, Phys Rev D 84, 044057,
 doi: <a href="http://dx.doi.org/10.1103/PhysRevD.84.044057">http://dx.doi.org/10.1103/PhysRevD.84.044057</a></p>
<p>Title: Cauchy-characteristic matching
 Authors: N. Bishop, R. Isaacson, R. Gomez, L. Lehner, B. Szilagyi, J.
 Winicour arXiv: gr-qc/9801070
 In "Black Holes, Gravitational Radiation and the Universe"
 eds. B. Iyer and B. Bhawal (Kluwer, Dordrecht, Boston,1999)</p>
<p>This code is maintained by</p>
<p>M. C.Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
B. Szilagyi <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;">&#98;&#101;&#108;&#97;&#46;&#115;&#122;&#105;&#108;&#97;&#103;&#121;&#105;&#64;&#106;&#112;&#108;&#46;&#110;&#97;&#115;&#97;&#46;&#103;&#111;&#118;</a>
C. Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Y. Zlochower <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;">&#121;&#111;&#115;&#101;&#102;&#64;&#97;&#115;&#116;&#114;&#111;&#46;&#114;&#105;&#116;&#46;&#101;&#100;&#117;</a></p>
<p>Please contact the maintainers of the code if you require
write access.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="cactuspughio">CactusPUGHIO</h2>
<h3 id="iohdf5">IOHDF5</h3>
<p>Cactus Code Thorn IOHDF5
Author(s)    : Thomas Radke
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn does output of arbitrary Cactus variables in HDF5 file format.</p>
<p>It also provides checkpointing/recovery functionality -
you can create HDF5 checkpoint files and recover from them.</p>
<ol>
<li>Additional information</li>
</ol>
<p>Please refer to the documentation.tex file in the doc/ subdirectory.</p>
<p>Fore more information on HDF5 see <a href="http://hdf.ncsa.uiuc.edu/HDF5/">http://hdf.ncsa.uiuc.edu/HDF5/</a>.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>out_every</td>
<td>-1</td>
<td>How often to do IOHDF5 output, overrides IO::out_every</td>
<td>1:* :: "Every so many iterations"<em>OR</em>   0:  :: "Disable IOHDF5 output"<em>OR</em>  -1:  :: "Default to IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>out_dir</td>
<td>""</td>
<td>Output directory for IOHDF5 files, overrides IO::out_dir</td>
<td>".+" :: "A valid directory name"<em>OR</em>  "^$" :: "An empty string to choose the default from IO::out_dir"<em>OR</em></td>
</tr>
<tr>
<td>out_vars</td>
<td>""</td>
<td>Variables to output in HDF5 file format</td>
<td>".+" :: "Space-separated list of fully qualified variable/group names"<em>OR</em>  "^$" :: "An empty string to output nothing"<em>OR</em></td>
</tr>
<tr>
<td>checkpoint</td>
<td>"no"</td>
<td>Do checkpointing with HDF5</td>
<td></td>
</tr>
<tr>
<td>checkpoint_next</td>
<td>"no"</td>
<td>Checkpoint at next iteration</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="iohdf5util">IOHDF5Util</h3>
<p>Cactus Code Thorn IOHDF5Util
Author(s)    : Thomas Radke
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn serves as a utility thorn for other HDF5 I/O thorns such as
IOStreamedHDF5 and IOHDF5.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>compression_level</td>
<td>0</td>
<td>Compression level to use for writing HDF5 data</td>
<td>0:9 :: "Higher numbers compress better, a value of zero disables compression"<em>OR</em></td>
</tr>
</tbody>
</table>
<h2 id="cactusutils">CactusUtils</h2>
<h3 id="formaline">Formaline</h3>
<p>Cactus Code Thorn Formaline
Thorn Author(s)     : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Thorn Maintainer(s) : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>Send meta information about a run to a server, so that it is kept
there forever.  The information sent is e.g. the parameter file, date,
time, machine, and user id of the run, location of the output data,
number of iterations, an efficiency summary, etc.</p>
<p>Meaning and pronunciation.  Formaline (or: formalin) is a solution of
formaldehyde (methanal) in water.  The chemical formula of
formaldehyde is H_2CO.  Formaline is commonly used to preserve
biological specimen.  It is pronounced "fOrmaleen".</p>
<p>How to get a stored source tree out of a git repository:
git checkout GIT-COMMIT-ID</p>
<p>TODO:</p>
<p>put unique job IDs into all output files
        done for Carpet output
        but not yet after restarting</p>
<p>BSD tar: read files from file: -I filename
tar: don't use -z; use tar and gzip
AIX: tar is GNU tar, but uses -L instead of -T
use GNU tar, and autodetect it properly</p>
<p>follow symbolic links
(maybe: respect hard links)</p>
<p>IOUtil should not depend on anything
(MoL should not depend on NaNChecker)</p>
<p>use a configuration script to amend all thorns' make.code.deps files
to create the tarballs when the thorns are compiled</p>
<p>put arrangement name into thorn source name
use subdirectories for arrangements
use strings instead of chars for data</p>
<p>announce: maybe use <array> for parameter arrays
          maybe use <dateTime.iso8601>20100302T00:00:00</dateTime.iso8601>
                for dates and times</p>
<p>put the output files into the build directory instead of the scratch
directory</p>
<p>output grid variables
register as output method
implement reductions
implement missing data types
output only if value has changed</p>
<p>update the source tarballs not only when the thorn library changes,
but also when a <em>.ccl or make.</em> file changes.
do not necessarily update them all when the bindings change.</p>
<p>fork (or spawn a thread) before announcing, so that the simulation
does not have to wait
        make sure to kill the old spawn before a new is created</p>
<p>make max_warn_level and output_info steerable</p>
<p>register with Portal/Announce as information provider
[Tom/Ian want to make Announce accept a table instead of XMLRPC]</p>
<p>prevent connecting to the wrong simulation, if a simulation is
outdated, and a new simulation uses the same hostname/port
combination: the portal can store the job id, and if there is a new
port id for the same hostname/port combination, deactivate the old
link.</p>
<p>rebuild the flesh tarball when the ThornList changes</p>
<p>announce in the background, maybe with a larger timeout</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>no</td>
<td>Produce screen output</td>
<td></td>
</tr>
<tr>
<td>collect_metadata</td>
<td>yes</td>
<td>Collect metadata and output it in various ways</td>
<td></td>
</tr>
<tr>
<td>update_interval</td>
<td>3600.0</td>
<td>Update interval for the meta information (in seconds)</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>publish_level</td>
<td>1</td>
<td>Importance level for meta data to be published via the Publish API</td>
<td>0:10 :: "the lower the level the more important the meta data to be published"<em>OR</em></td>
</tr>
<tr>
<td>timeout</td>
<td>10</td>
<td>Timeout for sending meta information to a server (in seconds)</td>
<td>1:* :: "a positive value"<em>OR</em></td>
</tr>
<tr>
<td>metadata_lifetime</td>
<td>100</td>
<td>Lifetime of meta information sent to a server (in hours)</td>
<td>0   :: "zero to store the metadata forever"<em>OR</em>  1:* :: "a positive value to limit the lifetime to so many hours"<em>OR</em></td>
</tr>
<tr>
<td>steered_parameters_log_exclusion_list</td>
<td>"CarpetRegrid::coordinates"</td>
<td>Parameters for which runtime changes should not be logged</td>
<td>"" :: "whitespace-separated list of parameter names"<em>OR</em></td>
</tr>
<tr>
<td>nr_of_parameter_changes_to_be_logged</td>
<td>-1</td>
<td>number of parameter changes to be logged</td>
<td>-1: :: "log all changes"<em>OR</em>   0: :: "no logs please"<em>OR</em>   1:<em>:: "log this many changes for a given parameter, then stop logging"*OR</em></td>
</tr>
<tr>
<td>create_id_files</td>
<td>yes</td>
<td>Create files from the build and job ids</td>
<td></td>
</tr>
<tr>
<td>announce_to_portal</td>
<td>no</td>
<td>Announce meta information to the portal</td>
<td></td>
</tr>
<tr>
<td>portal_username</td>
<td>""</td>
<td>User name on the portal</td>
<td>"" :: ""<em>OR</em></td>
</tr>
<tr>
<td>send_as_rdf</td>
<td>no</td>
<td>Send meta as RDF to a server</td>
<td></td>
</tr>
<tr>
<td>store_into_file</td>
<td>yes</td>
<td>Store meta information in a file</td>
<td></td>
</tr>
<tr>
<td>store_into_json_file</td>
<td>yes</td>
<td>Store meta information in a file in JSON format</td>
<td></td>
</tr>
<tr>
<td>storage_filename</td>
<td>"formaline-jar.txt"</td>
<td>File name for meta information</td>
<td>"" :: ""<em>OR</em></td>
</tr>
<tr>
<td>storage_json_filename</td>
<td>"formaline-jar.json"</td>
<td>File name for meta information in JSON format</td>
<td>"" :: ""<em>OR</em></td>
</tr>
<tr>
<td>use_relay_host</td>
<td>yes</td>
<td>Use a relay host for connecting to the portal</td>
<td></td>
</tr>
<tr>
<td>relay_host</td>
<td>""</td>
<td>Relay host for connecting to the portal</td>
<td>".+" :: "host name"<em>OR</em>  ""   :: "try to determine a relay host automatically"<em>OR</em></td>
</tr>
<tr>
<td>output_source</td>
<td>yes</td>
<td>Output a tarball with the cactus source tree</td>
<td></td>
</tr>
<tr>
<td>output_source_subdirectory</td>
<td>"cactus-source"</td>
<td>Subdirectory, relative to IO::out_dir, for the Cactus source tarballs</td>
<td>"" :: ""<em>OR</em></td>
</tr>
<tr>
<td>out_vars</td>
<td>""</td>
<td>Cactus variables that should be output</td>
<td>"" :: "space separated list of groups or variables"<em>OR</em></td>
</tr>
<tr>
<td>out_reductions</td>
<td>"minimum</td>
<td>Reduction operators that should be applied to the output variables</td>
<td>"" :: "space separated list of reduction operators"<em>OR</em></td>
</tr>
<tr>
<td>max_warn_level</td>
<td>-1</td>
<td>Only output warnings with at most this level of severity</td>
<td>-1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>output_info</td>
<td>"no"</td>
<td>Output info messages?</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="openclruntime">OpenCLRunTime</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Output detailed device information</td>
<td></td>
</tr>
<tr>
<td>veryverbose</td>
<td>"no"</td>
<td>Output even more detailed information</td>
<td></td>
</tr>
<tr>
<td>disassemble_kernels</td>
<td>"yes"</td>
<td>Disassemble kernels</td>
<td></td>
</tr>
<tr>
<td>disassemble_in_background</td>
<td>"yes"</td>
<td>Disassemble in the background (using fork)</td>
<td></td>
</tr>
<tr>
<td>opencl_options</td>
<td>"-cl-mad-enable</td>
<td>OpenCL compiler options</td>
<td>"" :: ""<em>OR</em></td>
</tr>
<tr>
<td>opencl_device_type</td>
<td>"CPU"</td>
<td>Device type</td>
<td>"CPU"         :: ""<em>OR</em>  "GPU"         :: ""<em>OR</em>  "accelerator" :: ""<em>OR</em>  "any"         :: ""<em>OR</em></td>
</tr>
<tr>
<td>memory_model</td>
<td>"copy"</td>
<td>Memory model</td>
<td>"always-mapped" :: "CPU and GPU use the same memory (may violate standard)"<em>OR</em>  "copy"          :: "Copy buffers"<em>OR</em>  "map"           :: "Map buffers (requires same layout)"<em>OR</em></td>
</tr>
<tr>
<td>sync_copy_whole_buffer</td>
<td>"no"</td>
<td>Copy whole buffer before/after syncing</td>
<td></td>
</tr>
<tr>
<td>vector_size_x</td>
<td>0</td>
<td>Vector size in x direction</td>
<td>0   :: "use preferred vector size"<em>OR</em>  1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>vector_size_y</td>
<td>1</td>
<td>Vector size in y direction</td>
<td>1 :: ""<em>OR</em></td>
</tr>
<tr>
<td>vector_size_z</td>
<td>1</td>
<td>Vector size in z direction</td>
<td>1 :: ""<em>OR</em></td>
</tr>
<tr>
<td>unroll_size_x</td>
<td>1</td>
<td>Unroll size in x direction</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>unroll_size_y</td>
<td>1</td>
<td>Unroll size in y direction</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>unroll_size_z</td>
<td>1</td>
<td>Unroll size in z direction</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>group_size_x</td>
<td>1</td>
<td>Group size in x direction</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>group_size_y</td>
<td>1</td>
<td>Group size in y direction</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>group_size_z</td>
<td>1</td>
<td>Group size in z direction</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>tile_size_x</td>
<td>1</td>
<td>Tile size in x direction</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>tile_size_y</td>
<td>1</td>
<td>Tile size in y direction</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>tile_size_z</td>
<td>1</td>
<td>Tile size in z direction</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="trigger">Trigger</h3>
<p>Cactus Code Thorn SystemStatistics
Author(s)    : Frank Loeffler <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#107;&#110;&#97;&#114;&#102;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#107;&#110;&#97;&#114;&#102;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Frank Loeffler <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#107;&#110;&#97;&#114;&#102;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#107;&#110;&#97;&#114;&#102;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : LGPLv2.1 or later</p>
<hr />
<h2 id="purpose-of-this-thorn">Purpose of this thorn</h2>
<p>This thorn can be used to define triggers to output variables due to
relations of (evl. other) variables.</p>
<h2 id="documentation_1">Documentation</h2>
<p>Look into the doc/ directory for more documentation.</p>
<h2 id="copyright_1">Copyright</h2>
<p>This thorn is copyright (C) 2003-2012
by Frank Loeffler <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#107;&#110;&#97;&#114;&#102;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#107;&#110;&#97;&#114;&#102;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a></p>
<p>This thorn is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.</p>
<p>This thorn is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this thorn (see the file COPYING in this directory);
if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>Trigger_Number</td>
<td>0</td>
<td>Number of triggers</td>
<td>0:10 :: "The number of triggers that are defined"<em>OR</em></td>
</tr>
<tr>
<td>Trigger_Debug</td>
<td>0</td>
<td>turnes on debug messages</td>
<td>0:1 :: "Only 0 (off, default) or 1 (on)"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="nice">Nice</h3>
<p>Cactus Code Thorn Nice
Author(s)    : Frank Löffler
Maintainer(s): Frank Löffler
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn changes the nice level of Cactus processes.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>Nice_nice</td>
<td>19</td>
<td>Nice level</td>
<td>-20:19 :: "The range for the nice is from -20 to 19, but only root can use negative values, default is 19."<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="nompi">NoMPI</h3>
<p>Cactus Code Thorn NoMPI
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Provide a dummy MPI implementation that works only a single process.
This implements only a subset of the MPI standard.</p>
<p>This thorn disables itself when an actual MPI implementation is
present.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="systemtopology">SystemTopology</h3>
<p>Cactus Code Thorn SystemTopology
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Report the system topology (nodes, cores, etc.) as reported by MPI and
hwloc.</p>
<p>Set thread affinities.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>set_thread_bindings</td>
<td>"auto"</td>
<td>Set thread bindings (aka thread-CPU affinity)</td>
<td>"yes"  :: "set bindings"<em>OR</em>  "no"   :: "no not modify bindings"<em>OR</em>  "auto" :: "depends on system architecture"<em>OR</em></td>
</tr>
<tr>
<td>thread_layout</td>
<td>"dense"</td>
<td>How to lay out threads over cores</td>
<td>"dense" :: "Pack threads on as few NUMA nodes/cores as possible"<em>OR</em>  "loose" :: "Spread threads over all NUMA nodes/cores"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="nancatcher">NaNCatcher</h3>
<p>Cactus Code Thorn NaNCatcher
Authors    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#117;&#110;&#105;&#45;&#116;&#117;&#101;&#98;&#105;&#110;&#103;&#101;&#110;&#46;&#100;&#101;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#117;&#110;&#105;&#45;&#116;&#117;&#101;&#98;&#105;&#110;&#103;&#101;&#110;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>Switch the FPU into a mode where it catches nans and infinities.
Whether this is possible, andor whether this code knows how to do
that, is hardware and operating system dependent.</p>
<p>This should work on the following systems:</p>
<p>Systems with a GNU C library (glibc), version 2.2 or later, using
<fenv.h>.</p>
<p>Linux systems with an IA32 (aka i386) processor, when the compiler is
GNU or Intel, using <fpu_control.h>.</p>
<p>PowerPC systems with a GNU compiler, using code taken from the GNU C
library.</p>
<p>In cases where the nan-catcher does not work, you will see a warning
message "NaNCatcher disabled -- no support for your compiler" early at
run time.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="systemstatistics">SystemStatistics</h3>
<p>Cactus Code Thorn SystemStatistics
Author(s)    : Ian Hinder <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#105;&#97;&#110;&#46;&#104;&#105;&#110;&#100;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#105;&#97;&#110;&#46;&#104;&#105;&#110;&#100;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Maintainer(s): Ian Hinder <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#105;&#97;&#110;&#46;&#104;&#105;&#110;&#100;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#105;&#97;&#110;&#46;&#104;&#105;&#110;&#100;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Licence      : LGPLv2.1 or later</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn collects information about the system Cactus is running on
and exposes it in Cactus grid variables.</p>
<h1 id="copyright_2">Copyright</h1>
<p>This thorn is copyright (C) 2010-2013 by Ian Hinder
<a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#105;&#97;&#110;&#46;&#104;&#105;&#110;&#100;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#105;&#97;&#110;&#46;&#104;&#105;&#110;&#100;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<p>This thorn is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.</p>
<p>This thorn is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this thorn (see the file COPYING in this directory);
if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="vectors">Vectors</h3>
<p>Cactus Code Thorn Vectors
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : LGPLv2.1 or later</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Provide C macro definitions and a C++ class template that help
vectorisation.</p>
<ol>
<li>Build-time choices</li>
</ol>
<p>Several choices can be made via configuration options, which can be
set to "yes" or "no":</p>
<p>VECTORISE (default "no"): Vectorise. Otherwise, scalar code is
generated, and the other options have no effect.</p>
<p>VECTORISE_ALIGNED_ARRAYS (default "no", experimental): Assume that all
arrays have an extent in the x direction that is a multiple of the
vector size. This allows aligned load operations e.g. for finite
differencing operators in the y and z directions. (Setting this
produces faster code, but may lead to segfaults if the assumption is
not true.)</p>
<p>VECTORISE_ALWAYS_USE_UNALIGNED_LOADS (default "no", experimental):
Replace all aligned load operations with unaligned load operations.
This may simplify some code where alignment is unknown at compile
time. This should never lead to better code, since the default is to
use aligned load operations iff the alignment is known to permit this
at build time. This options is probably useless.</p>
<p>VECTORISE_ALWAYS_USE_ALIGNED_LOADS (default "no", experimental):
Replace all unaligned load operations by (multiple) aligned load
operations and corresponding vector-gather operations. This may be
beneficial if unaligned load operations are slow, and if vector-gather
operations are fast.</p>
<p>VECTORISE_INLINE (default "no"): Inline functions into the loop body
as much as possible.  This can cause some compilers to run out of
memory for complex codes. (Enabling this may increase code size, which
can degrade performance if the instruction cache is small, but may
lead to increased performance due to omission of function-call
overhead.)</p>
<p>VECTORISE_STREAMING_STORES (default "yes"): Use streaming stores, i.e.
use store operations that bypass the cache. (Disabling this produces
slower code.)</p>
<p>VECTORISE_EMULATE_AVX (default "no", experimental): Emulate AVX
instructions with SSE2 instructions. This produces slower code, but
can be used to test AVX code on systems that don't support AVX.</p>
<ol>
<li>Tests</li>
</ol>
<p>Correctness testing is run at startup (in CCTK_PARAMCHECK) provided the
Vectors thorn is in the list of ActiveThorns. This aims to test all vector
operations by comparing the results with the same operations done using a
scalar implementation. The number of passed tests is always reported. If any
test fails, the run is aborted immediately.</p>
<ol>
<li>Related software</li>
</ol>
<p>[1] Vc: portable, zero-overhead SIMD library for C++,
<a href="http://compeng.uni-frankfurt.de/index.php?id=88">http://compeng.uni-frankfurt.de/index.php?id=88</a></p>
<p>[2] SLEEF - SIMD Library for Evaluating Elementary Functions,
<a href="http://shibatch.sourceforge.net">http://shibatch.sourceforge.net</a></p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Verbose output during vector tests</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="nanchecker">NaNChecker</h3>
<p>Cactus Code Thorn NaNChecker
Author(s)    : Thomas Radke
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn can be used to analyze CCTK variables of real or complex data type
for NaN (Not-a-Number) and (on availability of finite(3)) infinite values.</p>
<p>For details see the NaNChecker section in the Cactus ThornGuide.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>check_every</td>
<td>0</td>
<td>How often to check for NaNs</td>
<td>0   :: "Never (default)"<em>OR</em>  1:* :: "Every so many iterations"<em>OR</em></td>
</tr>
<tr>
<td>check_after</td>
<td>0</td>
<td>Start checking for NaNs after so many iterations</td>
<td>0:* :: "Any valid iteration number"<em>OR</em></td>
</tr>
<tr>
<td>report_max</td>
<td>-1</td>
<td>How many NaNs to report for a single variable</td>
<td>-1   :: "Report all (default)"<em>OR</em>   0:* :: "Do not report more than report_max number of NaNs"<em>OR</em></td>
</tr>
<tr>
<td>check_vars</td>
<td>""</td>
<td>Groups and/or variables to check for NaNs</td>
<td>.* :: "List of full group and/or variable names, or 'all' for everything"<em>OR</em></td>
</tr>
<tr>
<td>check_for</td>
<td>"both"</td>
<td>Check for NaNs and/or infinite numbers (only evaluated if finite(3) is available)</td>
<td>"NaN"  :: "Check only for NaNs"<em>OR</em>  "Inf"  :: "Check only for infinite numbers"<em>OR</em>  "both" :: "Check for both NaNs and infinite numbers"<em>OR</em></td>
</tr>
<tr>
<td>out_NaNmask</td>
<td>"yes"</td>
<td>Dump the NaN grid function mask into an HDF5 file</td>
<td></td>
</tr>
<tr>
<td>action_if_found</td>
<td>"just</td>
<td>What to do if a NaN was found</td>
<td>"just warn" :: "Just print a level 1 warning"<em>OR</em>  "terminate" :: "Warn and terminate Cactus gracefully as soon as possible"<em>OR</em>  "abort"     :: "Warn and abort Cactus immediately"<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>"standard"</td>
<td>How much information to give</td>
<td>"all"      :: "All information"<em>OR</em>  "standard" :: "Standard information"<em>OR</em></td>
</tr>
<tr>
<td>ignore_restricted_points</td>
<td>"no"</td>
<td>do not check grid points whose values will be restricted away</td>
<td></td>
</tr>
<tr>
<td>setup_test</td>
<td>"no"</td>
<td>set up grid function with NaNs</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="watchdog">WatchDog</h3>
<p>Cactus Code Thorn WatchDog
Author(s)    : David Radice <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#100;&#114;&#97;&#100;&#105;&#99;&#101;&#64;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#100;&#114;&#97;&#100;&#105;&#99;&#101;&#64;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
               Einstein Toolkit maintainers <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#97;&#105;&#110;&#116;&#97;&#105;&#110;&#101;&#114;&#115;&#64;&#101;&#105;&#110;&#115;&#116;&#101;&#105;&#110;&#116;&#111;&#111;&#108;&#107;&#105;&#116;&#46;&#111;&#114;&#103;">&#109;&#97;&#105;&#110;&#116;&#97;&#105;&#110;&#101;&#114;&#115;&#64;&#101;&#105;&#110;&#115;&#116;&#101;&#105;&#110;&#116;&#111;&#111;&#108;&#107;&#105;&#116;&#46;&#111;&#114;&#103;</a>
Maintainer(s): Einstein Toolkit maintainers <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#97;&#105;&#110;&#116;&#97;&#105;&#110;&#101;&#114;&#115;&#64;&#101;&#105;&#110;&#115;&#116;&#101;&#105;&#110;&#116;&#111;&#111;&#108;&#107;&#105;&#116;&#46;&#111;&#114;&#103;">&#109;&#97;&#105;&#110;&#116;&#97;&#105;&#110;&#101;&#114;&#115;&#64;&#101;&#105;&#110;&#115;&#116;&#101;&#105;&#110;&#116;&#111;&#111;&#108;&#107;&#105;&#116;&#46;&#111;&#114;&#103;</a>
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Kills a simulation if it hangs</p>
<ol>
<li>Usage</li>
</ol>
<p>Activate the WatchDog thorn.</p>
<p>Original author: David Radice</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>check_every</td>
<td>3600</td>
<td>Check that the run is progressing every so many seconds</td>
<td>1:* :: "Any positive integer"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="accelerator">Accelerator</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Output detailed information</td>
<td></td>
</tr>
<tr>
<td>veryverbose</td>
<td>"no"</td>
<td>Output even more detailed information</td>
<td></td>
</tr>
<tr>
<td>copy_back_all_timelevels</td>
<td>"no"</td>
<td>Copy all timelevels back to the host for output</td>
<td></td>
</tr>
<tr>
<td>copy_back_every</td>
<td>1</td>
<td>When to copy variables back to the host</td>
<td>0   :: "never"<em>OR</em>  1:* :: "every so many iterations"<em>OR</em></td>
</tr>
<tr>
<td>copy_back_vars</td>
<td>"all"</td>
<td>Which variables to copy back</td>
<td>.* :: "list of group or variable names; empty to copy nothing, 'all' to copy all variables"<em>OR</em></td>
</tr>
<tr>
<td>copy_back_all_written_variables_in_analysis</td>
<td>"yes"</td>
<td>Copy all variables that are written to in analysis back to the host</td>
<td></td>
</tr>
<tr>
<td>only_reads_current_timelevel</td>
<td>"no"</td>
<td>Assume that functions read only the current timelevel</td>
<td></td>
</tr>
<tr>
<td>only_writes_current_timelevel</td>
<td>"no"</td>
<td>Assume that functions write only the current timelevel</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="timerreport">TimerReport</h3>
<p>Cactus Code Thorn TimerReport
Author(s)    : Cactus team
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Simplistic additional timer information.  This thorn provides timer
details to screen at different iterations and before checkpoints
depending on parameter settings.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>out_every</td>
<td>0</td>
<td>How often to output timer report to screen</td>
<td>0   :: "No periodic output (default)"<em>OR</em>  1:* :: "Every so many iterations"<em>OR</em></td>
</tr>
<tr>
<td>out_at</td>
<td>-1</td>
<td>Output timer information at a given iteration</td>
<td>-1   :: "Do not output at specific iteration (default)"<em>OR</em>  0:*  :: "At this iteration"<em>OR</em></td>
</tr>
<tr>
<td>out_filename</td>
<td>""</td>
<td>File name for timer reports</td>
<td>"^<span><span class="MathJax_Preview">"   :: "empty filename: print to stdout"*OR*  "^.+</span><script type="math/tex">"   :: "empty filename: print to stdout"*OR*  "^.+</script></span>" :: "otherwise: print to that file"<em>OR</em></td>
</tr>
<tr>
<td>before_checkpoint</td>
<td>"no"</td>
<td>Before a checkpoint</td>
<td></td>
</tr>
<tr>
<td>next</td>
<td>"no"</td>
<td>On next iteration</td>
<td></td>
</tr>
<tr>
<td>output_schedule_timers</td>
<td>"yes"</td>
<td>Output the schedule timers in a formatted tabular format</td>
<td></td>
</tr>
<tr>
<td>output_all_timers</td>
<td>"no"</td>
<td>Output one file per processor containing all the Cactus timers</td>
<td></td>
</tr>
<tr>
<td>output_all_timers_together</td>
<td>"no"</td>
<td>Output three files (formats .txt, .csv, and .tsv), containing information about all the Cactus timers (average, minimum, and maximum over all processors)</td>
<td></td>
</tr>
<tr>
<td>output_all_timers_readable</td>
<td>"no"</td>
<td>Output one file containing information about all the Cactus timers (average, minimum, and maximum over all processors), in a format that is readable by humans</td>
<td></td>
</tr>
<tr>
<td>all_timers_clock</td>
<td>"gettimeofday"</td>
<td>Which clock to use for the all timers output</td>
<td>".<em>"   :: "any clock name allowed"*OR</em></td>
</tr>
<tr>
<td>n_top_timers</td>
<td>0</td>
<td>How many timers to include in the top timer report</td>
<td>0   :: "Do not print the report"<em>OR</em>  1:* :: "Any number of timers"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="terminationtrigger">TerminationTrigger</h3>
<p>Cactus Code Thorn TerminationTrigger
Author(s)    : Christian D. Ott
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn watches the elapsed walltime.  If only n minutes are left
before the some limit set by the user, it triggers termination of the
simulation.  Termination is also triggered if a special file with a
special content exists.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>on_remaining_walltime</td>
<td>0.0</td>
<td>When to trigger termination in MINUTES</td>
<td>0.0    :: "Don't trigger termination"<em>OR</em>  (0.0:* :: "So many minutes before your job walltime is over"<em>OR</em></td>
</tr>
<tr>
<td>max_walltime</td>
<td>0.0</td>
<td>Walltime in HOURS allocated for this job</td>
<td>0.0    :: "Don't trigger termination"<em>OR</em>  (0.0:* :: "Should be positive, right"<em>OR</em></td>
</tr>
<tr>
<td>termination_from_file</td>
<td>"no"</td>
<td>Use termination file; specified by termination_filename</td>
<td></td>
</tr>
<tr>
<td>create_termination_file</td>
<td>"no"</td>
<td>Create an empty termination file at startup</td>
<td></td>
</tr>
<tr>
<td>termination_file</td>
<td>"/tmp/cactus_terminate"</td>
<td>Termination file name (either full path or relative to IO::out_dir)</td>
<td>"" ::  "Termination file"<em>OR</em></td>
</tr>
<tr>
<td>check_file_every</td>
<td>1</td>
<td>Check termination file every n timesteps</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>output_remtime_every_minutes</td>
<td>60.0</td>
<td>Output remaining wall time every n minutes</td>
<td>0.0    :: "No output"<em>OR</em>  (0.0:* :: "Output"<em>OR</em></td>
</tr>
<tr>
<td>testsuite</td>
<td>"no"</td>
<td>manually trigger termination</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="memspeed">MemSpeed</h3>
<p>Cactus Code Thorn MemSpeed
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;">&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;">&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;</a>
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Determine the speed of the CPU, as well as latencies and bandwidths of
caches and main memory. These provides ideal, but real-world values
against which the performance of other routines can be compared.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Verbose output</td>
<td></td>
</tr>
<tr>
<td>skip_largemem_benchmarks</td>
<td>"no"</td>
<td>Skip benchmarks that require much memory</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="einsteinanalysis">EinsteinAnalysis</h2>
<h3 id="weylscal4">WeylScal4</h3>
<p>Cactus Code Thorn WeylScal4
Author(s)    : Tanja Bode
               Ian Hinder
               Roland Haas
               Erik Schnetter
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Calculate the Weyl Scalars for a given metric given the fiducial tetrad of
Baker, Campanelli, and Lousto. PRD 65,044001 (2002) without the final null
rotations.</p>
<ol>
<li>Implementation</li>
</ol>
<p>The code is generated automatically with Mathematica.  The Mathematica
scripts are in the subdirectory "m", and the Makefile in there
re-generates the code.  This requires Mathematica and Kranc to be installed.</p>
<p>The scripts look for a Kranc installation in the "m" directory, in the Cactus
root directory and in $HOME as well as in the location where they find the
kranc shell-script if it is in the $PATH. If your Kranc (or kranc) directory is
in neither of these places, then you can set the environment variable KRANCPATH
to the location of your Kranc installation.</p>
<p>This thorn was generated using Kranc from <a href="http://github.com/ianhinder/Kranc">http://github.com/ianhinder/Kranc</a></p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>0</td>
<td>verbose</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>other_timelevels</td>
<td>1</td>
<td>Number of active timelevels for non-evolved grid functions</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>offset</td>
<td>1.e-15</td>
<td>offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>xorig</td>
<td>0</td>
<td>xorig</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>yorig</td>
<td>0</td>
<td>yorig</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>zorig</td>
<td>0</td>
<td>zorig</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>fdOrder</td>
<td>2</td>
<td>fdOrder</td>
<td>2 :: ""<em>OR</em>  4 :: ""<em>OR</em>  6 :: ""<em>OR</em>  8 :: ""<em>OR</em></td>
</tr>
<tr>
<td>tile_size</td>
<td>-1</td>
<td>Loop tile size</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>fd_order</td>
<td>"Nth"</td>
<td>fd_order</td>
<td>"Nth" :: ""<em>OR</em>  "2<sup>nd</sup>" :: ""<em>OR</em>  "4<sup>th</sup>" :: ""<em>OR</em></td>
</tr>
<tr>
<td>calc_scalars</td>
<td>"psi4"</td>
<td>Which scalars to calculate</td>
<td>"psi4" :: ""<em>OR</em>  "psis" :: ""<em>OR</em></td>
</tr>
<tr>
<td>calc_invariants</td>
<td>"never"</td>
<td>Compute invariants</td>
<td>"always" :: ""<em>OR</em>  "never" :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_MaxNumEvolvedVars</td>
<td>0</td>
<td>Number of evolved variables used by this thorn</td>
<td>0:0 :: "Number of evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_MaxNumArrayEvolvedVars</td>
<td>0</td>
<td>Number of Array evolved variables used by this thorn</td>
<td>0:0 :: "Number of Array evolved variables used by this thorn"<em>OR</em></td>
</tr>
<tr>
<td>timelevels</td>
<td>3</td>
<td>Number of active timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>rhs_timelevels</td>
<td>1</td>
<td>Number of active RHS timelevels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_psi4_calc_Nth_calc_every</td>
<td>1</td>
<td>WeylScal4_psi4_calc_Nth_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_psi4_calc_2nd_calc_every</td>
<td>1</td>
<td>WeylScal4_psi4_calc_2nd_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_psi4_calc_4th_calc_every</td>
<td>1</td>
<td>WeylScal4_psi4_calc_4th_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_psis_calc_Nth_calc_every</td>
<td>1</td>
<td>WeylScal4_psis_calc_Nth_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_psis_calc_2nd_calc_every</td>
<td>1</td>
<td>WeylScal4_psis_calc_2nd_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_psis_calc_4th_calc_every</td>
<td>1</td>
<td>WeylScal4_psis_calc_4th_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_invars_calc_Nth_calc_every</td>
<td>1</td>
<td>WeylScal4_invars_calc_Nth_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_invars_calc_2nd_calc_every</td>
<td>1</td>
<td>WeylScal4_invars_calc_2nd_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_invars_calc_4th_calc_every</td>
<td>1</td>
<td>WeylScal4_invars_calc_4th_calc_every</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_psi4_calc_Nth_calc_offset</td>
<td>0</td>
<td>WeylScal4_psi4_calc_Nth_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_psi4_calc_2nd_calc_offset</td>
<td>0</td>
<td>WeylScal4_psi4_calc_2nd_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_psi4_calc_4th_calc_offset</td>
<td>0</td>
<td>WeylScal4_psi4_calc_4th_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_psis_calc_Nth_calc_offset</td>
<td>0</td>
<td>WeylScal4_psis_calc_Nth_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_psis_calc_2nd_calc_offset</td>
<td>0</td>
<td>WeylScal4_psis_calc_2nd_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_psis_calc_4th_calc_offset</td>
<td>0</td>
<td>WeylScal4_psis_calc_4th_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_invars_calc_Nth_calc_offset</td>
<td>0</td>
<td>WeylScal4_invars_calc_Nth_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_invars_calc_2nd_calc_offset</td>
<td>0</td>
<td>WeylScal4_invars_calc_2nd_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>WeylScal4_invars_calc_4th_calc_offset</td>
<td>0</td>
<td>WeylScal4_invars_calc_4th_calc_offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="ahfinderdirect">AHFinderDirect</h3>
<p>Cactus Code Thorn AHFinderDirect
Authors    : Jonathan Thornburg <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Maintainer : Jonathan Thornburg <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<hr />
<h1 id="purpose-of-this-thorn_1">Purpose of This Thorn</h1>
<p>This thorn finds an apparent horizon (or more generally, a closed
2-surface with S^2 topology having any desired constant expansion)
given the 3D xyz-grid metric and extrinsic curvature (and optionally
the StaticConformal conformal factor).  It uses a direct method,
writing the apparent horizon equation as an elliptic PDE on
angular-coordinate space.  This is very fast and accurate, but
it does require an intitial guess for the apparent horizon position.</p>
<h1 id="documentation_2">Documentation</h1>
<p>The doc/ directory contains detailed documentation for this thorn,
including a discussion of those parameters which you'll likely want
to set (or at least know about) in practice.  For full information
on all the parameters, see the comments in the  param.ccl  file.</p>
<p>The par/ directory contains some sample par files.</p>
<p>src/CODESTYLE documents the general programming conventions used in
this thorn.</p>
<p>src/PORTING.OUTSIDE.CACTUS has some general remarks on what it would
take to port this thorn to a non-Cactus numerical relativity code.</p>
<p>See below in this file for notes on compiling this thorn.</p>
<h1 id="publications">Publications</h1>
<p>The algorithms used in this thorn are described in the papers
@article{
    Thornburg2003:AH-finding,
    author = "Jonathan Thornburg",
    title  = "A Fast Apparent-Horizon Finder
          for 3-Dimensional {C}artesian Grids in Numerical Relativity",
    journal = "Classical and Quantum Gravity",
    volume = 21, number = 2,
    year   = "2004", month = "January 21",
    pages  = "743--766",
    doi    = "10.1088/0264-9381/21/2/026",
    url    = "<a href="http://stacks.iop.org/0264-9381/21/743">http://stacks.iop.org/0264-9381/21/743</a>",
    eprint = "gr-qc/0306056",
    note   = "gr-qc/0306056",
    }
and
@article{
    Thornburg-1996-horizon-finding,
    author = "Jonathan Thornburg",
    title = "Finding Apparent Horizons in Numerical Relativity",
    journal = "Physical Review D",
    pages = "4899--4918",
    volume = 54, number = 8,
    year = 1996, month = "October 15",
    eprint = "gr-qc/9508014",
    }
As a courtesy, I ask that these papers be cited in any published research
which uses this thorn, or which uses code from this thorn.</p>
<h1 id="copyright_3">Copyright</h1>
<p>This thorn is copyright (C) 2001-2004
by Jonathan Thornburg <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#106;&#116;&#104;&#111;&#114;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>.</p>
<p>This thorn is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.</p>
<p>This thorn is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this thorn (see the file COPYING in this directory);
if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA</p>
<h1 id="other-software-used-already-contained-within-ahfinderdirect">Other Software Used (Already Contained within AHFinderDirect)</h1>
<p>AHFinderDirect's  src/sparse-matrix/  directory contains various
sparse-matrix libraries, which have their own copyrights and licensing terms:</p>
<p>The src/sparse-matrix/umfpack/ directory contains a subset of the files
in UMFPACK version 4.0 (11.Apr.2002).  This code is copyright (C) 2002 by
Timothy A. Davis, and is subect to the UMFPACK License:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>Your use or distribution of UMFPACK or any modified version of
UMFPACK implies that you agree to this License.

THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.

Permission is hereby granted to use or copy this program, provided
that the Copyright, this License, and the Availability of the original
version is retained on all copies.  User documentation of any code that
uses UMFPACK or any modified version of UMFPACK code must cite the
Copyright, this License, the Availability note, and &quot;Used by permission.&quot;
Permission to modify the code and to distribute modified code is granted,
provided the Copyright, this License, and the Availability note are
retained, and a notice that the code was modified is included.  This
software was developed with support from the National Science Foundation,
and is provided to you free of charge.
</pre></div>
</td></tr></table>

<h1 id="other-software-required">Other Software Required</h1>
<p>This thorn inherits from Grid, ADMBase, StaticConformal, SpaceMask, IO
(all in the CactusBase or CactusEinstein arrangements), and
SphericalSurface (in the AEIThorns arrangement; you can get AEIThorns
by anonymous CVS checkout from <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#118;&#115;&#95;&#97;&#110;&#111;&#110;&#64;&#99;&#118;&#115;&#46;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#99;&#118;&#115;&#95;&#97;&#110;&#111;&#110;&#64;&#99;&#118;&#115;&#46;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>:/numrelcvs, CVS
path AEIThorns/SphericalSurface).</p>
<p>By default this thorn uses various Cactus APIs which are supplied by
other thorns:
* This thorn uses CCTK_InterpGridArrays() for interpolating grid arrays.
  This is supplied by a driver-specific thorn, such as PUGHInterp or
  CarpetInterp.
* This thorn uses CCTK_ReduceLocArrayToArray1D() for interprocessor
  communication in the multiprocessor Newton solver.
    [see src/driver/README.parallel for details]
  This is supplied by a driver-specific thorn; at present PUGHReduce
  it this for the PUGH driver.
* This thorn uses CCTK_InterpLocalUniform() for interpatch and surface
  interpolation, and it needs various interpolation options which at
  present are (only) supported by the AEIThorns/AEILocalInterp local
  interpolator.</p>
<p>This thorn is written in C++, so you'll need a C++ compiler -- in fact
a fairly modern one -- to compile this thorn.  See the "Compilation Notes"
section below for details.</p>
<p>Most of this thorn's relativity code is machine-generated using Maple
(version 7), but you don't need Maple unless you want to modify the
relativity code.</p>
<p>By default, this thorn doesn't use any external libraries.  However,
if HAVE_DENSE_JACOBIAN__LAPACK is defined in src/include/config.h,
then this thorn uses the LAPACK library (which in turn uses the BLAS
library), so you will need to configure your Cactus to use LAPACK.
Instructions on doing this are in the file README.library in this
directory.</p>
<h1 id="code-notes">Code Notes</h1>
<p>This thorn is written in C++, and requires a fairly modern C++ compiler.
In particular:
* Templates are used, but only rather simple ones for containers or other
  low-level stuff templated on the floating-point or integer datatype.
  These templates are always instantiated explicitly.
* bool, mutable, typename are used.
* The new-style casts static_cast&lt;...&gt; and const_cast&lt;...&gt; are used.
  reinterpret_cast&lt;...&gt; and dynamic_cast&lt;...&gt; are <em>not</em> used.
* The code will compile ok under either the archaic or the modern
  for-loop declaration scope rules.
* C header files are used in the pre-namespaces form (eg <stdio.h>).
  (In ISO-standard C++ this is deprecated (but still supported), but
  alas none of the more modern forms (<cstdio> and namespace std::)
  seem to be supported on as wide a range of systems as the pre-namespaces
  form.)
* <assert.h> is used fairly heavily for sanity checks.
* To avoid various portability problems, none of the C++ standard
  template library (STL) is used.</p>
<h1 id="compiler-notes">Compiler Notes</h1>
<p>This thorn should be fully portable across architectures and operating
systems, but C++ compilers may be a problem:</p>
<p>This thorn has been compiled and run successfully using</p>
<h1 id="x86">x86</h1>
<ul>
<li>gcc version 2.95.3 20010125 (prerelease)</li>
<li>g++ (GCC) 3.2 for x86</li>
<li>g++ (GCC) 3.2.2 for x86</li>
<li>g++ (GCC) 3.3 for x86</li>
<li>Intel(R) C++ Compiler for 32-bit applications, Version 5.0.1   Build 010730D0</li>
<li>Intel C++ Compiler for Linux, version 6.0</li>
<li>Intel(R) C++ Compiler for 32-bit applications, Version 7.0   Build 20021021Z
  On platinum.ncsa.uiuc.edu, Denis Pollney reports success configuring Cactus
  with
    LIBS="crypt F90 CEPCF90 intrins mkl mkl_lapack guide"
    LIBDIRS=/usr/local/intel/mkl/lib/32</li>
<li>Portland Group pgCC 3.3-2
  On platinum.ncsa.uiuc.edu, Denis Pollney reports success configuring Cactus
  with
    LAPACK=yes
    LAPACK_DIR=/usr/local/pgi/linux86</li>
</ul>
<h1 id="ia64-aka-itanium">ia64, a.k.a. Itanium</h1>
<ul>
<li>Intel(R) C++ Itanium(R) Compiler for Itanium(R)-based applications
  Version 7.0 Beta, Build 20020911
  On titan.ncsa.uiuc.edu, Denis Pollney reports success configuring Cactus
  with
    LIBS="crypt F90 CEPCF90 intrins mkl_lapack mkl_itp guide"
    LIBDIRS=/usr/local/intel/mkl/lib/64</li>
</ul>
<h1 id="alpha">Alpha</h1>
<ul>
<li>g++ (GCC) 3.0
  On lemieux.psc.edu, Denis Pollney reports success configuring Cactus
  with
    LIBS="m c_r dxml for"</li>
<li>Using the DEC/Compaq/HP/whatever-their-corporate-name-is-this-week
  compiler, you need to specify the  -nopt  compiler option to disable
  automatic template instantiation.</li>
</ul>
<h1 id="sgi">SGI</h1>
<ul>
<li>On modi4.ncsa.uiuc.edu (an old SGI Origin), using
  MIPSpro Compilers: Version 7.3.1.3m
  you need to specify the  -no_auto_include  compiler option to disable
  automatic template instantiation.  In fact, you should probably specify
  this option on any SGI system...</li>
</ul>
<h1 id="ibm-power4-aix">IBM Power4 (AIX)</h1>
<ul>
<li>C for AIX Compiler, Version 6
  On psi19.rzg.mpg.de, Denis Pollney reports success configuring Cactus
  with
    LIBS="f m lapack-essl essl"
    LIBDIRS="/afs/rzg/@sys/lib"</li>
</ul>
<p>Please let me (Jonathan) know of any other compilers which are ok.</p>
<p>This thorn compiles, but does <em>NOT</em> work, using the folloing
systems/compilers; the cure is to switch to a newer compiler version:
x86
===
* gcc version 2.96 20000731 (Red Hat Linux 7.1 2.96-98)
  (This is the system gcc on Red Hat GNU/Linux 7.2 systems)</p>
<p>The code will almost certainly <em>not</em> compile using
* any "egcs" version of gcc, or more generally, any version of gcc
  earlier than 2.95
* any version of Microsoft Visual C++ up to and including mid-2002</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="calck">CalcK</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<p>Cactus Code Thorn CalcK
Thorn Author(s)     : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Thorn Maintainer(s) : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>Calculate the extrinsic curvature K_ij from several time levels of the
three-metric gamma_ij, lapse alpha, and shift beta^i.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>copy_to_prev</td>
<td>"no"</td>
<td>Copy ADMBase::metric to CalcK::metric_prev</td>
<td></td>
</tr>
<tr>
<td>copy_to_prev2</td>
<td>"no"</td>
<td>Copy ADMBase::metric to CalcK::metric_prev2</td>
<td></td>
</tr>
<tr>
<td>copy_to_next</td>
<td>"no"</td>
<td>Copy ADMBase::metric to CalcK::metric_next</td>
<td></td>
</tr>
<tr>
<td>calc_extcurv</td>
<td>"no"</td>
<td>Calculate extrinsic curvature</td>
<td></td>
</tr>
<tr>
<td>extcurv_boundary</td>
<td>"Robin"</td>
<td>Boundary condition for the extrinsic curvature</td>
<td>".<em>" :: "must be a registered boundary condition"*OR</em></td>
</tr>
<tr>
<td>extcurv_boundary_options</td>
<td>"decay_power=2.0"</td>
<td>Options for the boundry condition for the extrinsic curvature</td>
<td>".<em>" :: "must have the options table syntax"*OR</em></td>
</tr>
</tbody>
</table>
<h3 id="puncturetracker">PunctureTracker</h3>
<p>Cactus Code Thorn PunctureTracker
Thorn Author(s)     : Michael Koppitz <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#107;&#111;&#112;&#112;&#105;&#116;&#122;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#107;&#111;&#112;&#112;&#105;&#116;&#122;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
                      Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
                      Peter Diener <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#100;&#105;&#101;&#110;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#100;&#105;&#101;&#110;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Thorn Maintainer(s) : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>Time integrate the shift at the location of the punctures to follow the
location of the punctures.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>speak up?</td>
<td></td>
</tr>
<tr>
<td>modify_distance</td>
<td>0.0</td>
<td>Modify levels when the distance is less than this</td>
<td>0.0:* :: "zero or positive"<em>OR</em></td>
</tr>
<tr>
<td>shift_limit</td>
<td>1.0e10</td>
<td>Shift components must be less than this in magnitude</td>
<td>0.0:* :: "zero or positive"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="ehfinder">EHFinder</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<p>Cactus Code Thorn EHFinder
Authors    : Peter Diener <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#100;&#105;&#101;&#110;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#100;&#105;&#101;&#110;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Maintainer : Peter Diener <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#100;&#105;&#101;&#110;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#100;&#105;&#101;&#110;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>To find the event horizon of a numerical spacetime by integrating a null
surface backwards in time.</p>
<p>The surface will be parametrized as the 0 value isosurface of a level
set function. This ensures that it is possible to handle cases when the
topology changes (when evolving backwards in time) from one common event
horizon to two (or more) individual event horizons.</p>
<p>Documentation:</p>
<p>The documentation can be found in the Thorn Guide provided with this
Thorn. For additional details see gr-qc/0305039.</p>
<p>History:</p>
<p>This event horizon finder was written by Peter Diener in 2002-2003.</p>
<p>Copyright &amp; Licensing:</p>
<p>This thorn is copyright (C) 2002-2003
by Peter Diener <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#100;&#105;&#101;&#110;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#100;&#105;&#101;&#110;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>.</p>
<p>This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this thorn (see the file COPYING in this directory);
if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>eh_number_level_sets</td>
<td>1</td>
<td>How many level set functions should we evolve</td>
<td>1:10        :: "Between 1 and 10"<em>OR</em></td>
</tr>
<tr>
<td>eh_metric_type</td>
<td>"numerical"</td>
<td>Do we use numerical or analytic metric information</td>
<td>"numerical" :: "Read in metric from numerical data"<em>OR</em>  "analytic"  :: "Use external analytic metric"<em>OR</em></td>
</tr>
<tr>
<td>eh_lapse_type</td>
<td>"numerical"</td>
<td>Do we use numerical or analytic metric information</td>
<td>"numerical" :: "Read in metric from numerical data"<em>OR</em>  "analytic"  :: "Use external analytic metric"<em>OR</em></td>
</tr>
<tr>
<td>eh_shift_type</td>
<td>"numerical"</td>
<td>Do we use numerical or analytic metric information</td>
<td>"numerical" :: "Read in metric from numerical data"<em>OR</em>  "analytic"  :: "Use external analytic metric"<em>OR</em></td>
</tr>
<tr>
<td>file_type</td>
<td>"one_file"</td>
<td>Are the timesteps in separate files or in one file?</td>
<td>"one_file" :: "All timesteps are in the same file"<em>OR</em>  "sep_time_files" :: "Timesteps are in separete files"<em>OR</em></td>
</tr>
<tr>
<td>read_conformal_factor_once</td>
<td>"yes"</td>
<td>Should the conformal factor only be read once</td>
<td></td>
</tr>
<tr>
<td>cheat</td>
<td>"no"</td>
<td>Should we cheat and evolve using the last data set for a while?</td>
<td></td>
</tr>
<tr>
<td>cheat_iterations</td>
<td>0</td>
<td>For how many iterations should we cheat</td>
<td>0:*            :: "If you really want to cheat this should be positive"<em>OR</em></td>
</tr>
<tr>
<td>shell_width</td>
<td>7.0</td>
<td>Width of the evolution region in units of the grid spacing</td>
<td>0.0:            :: "Positive please"<em>OR</em></td>
</tr>
<tr>
<td>use_inner_excision</td>
<td>"yes"</td>
<td>Should inner excision be used?</td>
<td></td>
</tr>
<tr>
<td>use_outer_excision</td>
<td>"yes"</td>
<td>Should outer excision be used?</td>
<td></td>
</tr>
<tr>
<td>mode</td>
<td>"normal"</td>
<td>Mode of operation</td>
<td>"normal"  :: "Find event horizons"<em>OR</em>  "analysis" :: "Provide storage for f without evolving"<em>OR</em>  "generator" :: "Provide storage for f and initialize without evolving"<em>OR</em></td>
</tr>
<tr>
<td>upwind_type</td>
<td>"characteristic"</td>
<td>Type of upwinding used in evolving the ehfinder equations</td>
<td>"intrinsic" :: "Use the values of f itself to determine upwind direction"<em>OR</em>  "shift"     :: "Use the shift to determine upwind direction"<em>OR</em>  "characteristic" :: "Use characteristic information"<em>OR</em></td>
</tr>
<tr>
<td>surface_direction</td>
<td>"outward"</td>
<td>Should we track outward or inward moving surfaces</td>
<td>"outward" :: "Track outward moving surfaces. Use for event horizon finding."<em>OR</em>  "inward"  :: "Track inward moving surfaces."<em>OR</em></td>
</tr>
<tr>
<td>re_init_verbose</td>
<td>"no"</td>
<td>Should re-initialization be verbose?</td>
<td></td>
</tr>
<tr>
<td>re_init_undo</td>
<td>"yes"</td>
<td>Should re-initialization be undone at pinch-off</td>
<td></td>
</tr>
<tr>
<td>re_init_int_method</td>
<td>"euler"</td>
<td>Integration method used in re-initialization</td>
<td>"euler"  :: "Standard euler scheme"<em>OR</em>  "rk2"    :: "Second order Runge-Kutta scheme"<em>OR</em></td>
</tr>
<tr>
<td>re_init_max_iter</td>
<td>800</td>
<td>maximum number of iterations in the re-initialization</td>
<td>0:        :: "Positive please"<em>OR</em></td>
</tr>
<tr>
<td>pde_differences</td>
<td>"upwind2"</td>
<td>Type of finite diffencing used in pde re-initialization</td>
<td>"centered" :: "Use 2<sup>nd</sup> order centered differences except at the boundaries"<em>OR</em>  "upwind"   :: "Use 1<sup>st</sup> order upwinded differences everywhere"<em>OR</em>  "upwind2"  :: "Use 2<sup>nd</sup> order upwinded differences everywhere"<em>OR</em></td>
</tr>
<tr>
<td>re_initialize_every</td>
<td>10</td>
<td>How often to re-initialize the level set function</td>
<td>0:               :: "If 0 don't re-initialize"<em>OR</em></td>
</tr>
<tr>
<td>last_iteration_number</td>
<td>0</td>
<td>The starting iteration number for the EH_Finder (last iteration number of the simulation)</td>
<td>0:              :: "Positive please"<em>OR</em></td>
</tr>
<tr>
<td>saved_iteration_every</td>
<td>1</td>
<td>How often was the numerical data saved</td>
<td>1:               :: "Positive please"<em>OR</em></td>
</tr>
<tr>
<td>ntheta</td>
<td>51</td>
<td>Number of points in the theta direction when finding points on the surface</td>
<td>1:<em>:2            :: "Positive and odd please"*OR</em></td>
</tr>
<tr>
<td>nphi</td>
<td>51</td>
<td>Number of points in the phi direction when finding points on the surface</td>
<td>1:<em>:2            :: "Positive and odd please"*OR</em></td>
</tr>
<tr>
<td>n_array_ghosts</td>
<td>1</td>
<td>Number of ghost points in the surface grid array</td>
<td>1:               :: "Positive please"<em>OR</em></td>
</tr>
<tr>
<td>maximum_surface_number</td>
<td>1</td>
<td>The maximum number of surfaces expected in the data</td>
<td>1:*            :: "Positive please"<em>OR</em></td>
</tr>
<tr>
<td>use_user_center</td>
<td>"no"</td>
<td>Should the user prescribed center be used</td>
<td></td>
</tr>
<tr>
<td>center_x</td>
<td>0.0</td>
<td>The x-coordinate of the center</td>
<td><em>:</em>            :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>center_y</td>
<td>0.0</td>
<td>The y-coordinate of the center</td>
<td><em>:</em>            :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>center_z</td>
<td>0.0</td>
<td>The z-coordinate of the center</td>
<td><em>:</em>            :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>evolve_generators</td>
<td>"no"</td>
<td>Should the generators be evolved</td>
<td></td>
</tr>
<tr>
<td>number_of_generators</td>
<td>1</td>
<td>How many generators should be evolved</td>
<td>1:*            :: "Postive please"<em>OR</em></td>
</tr>
<tr>
<td>number_of_generators_theta</td>
<td>1</td>
<td>How many generators in the theta direction</td>
<td>1:*           :: "Positive please"<em>OR</em></td>
</tr>
<tr>
<td>number_of_generators_phi</td>
<td>1</td>
<td>How many generators in the phi direction</td>
<td>1:*           :: "Positive please"<em>OR</em></td>
</tr>
<tr>
<td>generator_distribution</td>
<td>"line"</td>
<td>What initial distribution should be used</td>
<td>"line" :: "Put the generators on a line in the xz-plane"<em>OR</em>  "2D array"    :: "Put the generators on a surface with spherical topology"<em>OR</em></td>
</tr>
<tr>
<td>surface_interpolator</td>
<td>"Hermite</td>
<td>What interpolator should be used to locate the surface</td>
<td>".+"          :: "A valid interpolator name"<em>OR</em></td>
</tr>
<tr>
<td>surface_interpolation_order</td>
<td>2</td>
<td>What order should be used for the surface interpoation</td>
<td>1:*           :: "A valid positive interpolation order"<em>OR</em></td>
</tr>
<tr>
<td>area_interpolator</td>
<td>"Lagrange</td>
<td>What interpolator should be used for the area</td>
<td>".+"          :: "A valid interpolator name"<em>OR</em></td>
</tr>
<tr>
<td>area_interpolation_order</td>
<td>3</td>
<td>What order should be used for the area interpoation</td>
<td>1:*           :: "A valid positive interpolation order"<em>OR</em></td>
</tr>
<tr>
<td>area_calculation_method</td>
<td>"standard"</td>
<td>How should the areas be calculated</td>
<td>"standard"    :: "Using a angular coordinate system on the surface"<em>OR</em>  "isosurface"  :: "Using an isosurface triangulation"<em>OR</em></td>
</tr>
<tr>
<td>generator_interpolator</td>
<td>"Lagrange</td>
<td>What interpolator should be used for the generators</td>
<td>".+"          :: "A valid interpolator name"<em>OR</em></td>
</tr>
<tr>
<td>generator_interpolation_order</td>
<td>3</td>
<td>What order should be used for the generator interpoation</td>
<td>1:*           :: "A valid positive interpolation order"<em>OR</em></td>
</tr>
<tr>
<td>generator_tracking_method</td>
<td>"interpolate_before"</td>
<td>What method should be used for tracking the generators</td>
<td>"interpolate_before" :: "Interpolate first, then calculate"<em>OR</em>  "interpolate_after"  :: "Calculate first, then interpolate"<em>OR</em></td>
</tr>
<tr>
<td>EHFinder_MaxNumEvolvedVars</td>
<td>1</td>
<td>The maximum number of evolved variables used by EHFinder</td>
<td>1:10        :: "Only evolve the level set functions"<em>OR</em></td>
</tr>
<tr>
<td>EHFinder_Max_Evolved_Array_Size</td>
<td>1</td>
<td>The maximum size of evolved grid arrays used by EHFinder</td>
<td>1:*        :: "The size of the generator grid arrays"<em>OR</em></td>
</tr>
<tr>
<td>EHFinder_Num_ArrayEvolved_Vars</td>
<td>3</td>
<td>The maximum number of evolved grid arrays used by EHFinder</td>
<td>0:30      :: "Should be exactly zero or a multiple of three"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="ahfinder">AHFinder</h3>
<p>Cactus Code Thorn AHFinder
Author(s)    : Miguel Alcubierre
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn looks for apparent horizons (AH) in 3D.  An AH is defined
as a surface where the expansion of outgoing null geodesics is zero.</p>
<p>NOTE:  THIS FILE IS SOMEWHAT OUT OF DATE.  I WILL UPDATE IT WHEN
I HAVE MORE TIME.  PLEASE LOOK AT THE FILE `MinimumAHF_param.h'
FOR A MORE UP TO DATA DESCRIPTION OF THE PARAMETERS.</p>
<h2 id="brief-description">BRIEF DESCRIPTION</h2>
<p>This thorn looks for apparent horizons (AH) in 3D using two
different algorithms.  In the default mode, it uses a minimization
algorithm.  It can also use a flow algorithm if one sets the
parameter "ahf_flow" equal to "yes":</p>
<p>ahf_flow = "yes"</p>
<p>The minimization algorithm is VERY slow if one has a lot of terms
in the spherical harmonics expansion (see below), but it is quite
fast for a small number of terms.</p>
<p>The thorn is activated by adding the following line to the parameter
file:</p>
<p>ahfinder::ahf_active      = "yes"</p>
<p>Also, one needs to tell the routine how often we want to
look for AH by using the parameter `mahf_findevery' (its
default value is 1).</p>
<p>The routine defines the grid function `mahfgrid' as:</p>
<p>ahfgrid  =  r  -  f(theta,phi)</p>
<p>So that the surface being considered corresponds to the zero level of
`mahfgrid'.  The function f(theta,phi) is expanded in spherical
harmonics Y(l,m).  Notice, however, that I DO NOT use the standard
normalization factor:</p>
<p>sqrt( (2l + 1) (l - m)! / 4 pi (l + m)! )</p>
<p>I use instead:</p>
<p>sqrt( 2l + 1 )                           m = 0</p>
<p>sqrt( 2 (2l + 1) (l - m)! / (l + m)! )   m != 0</p>
<p>Notice first that I leave out the 4*pi.  This is because I want Y(0,0)
to be the real radius of a sphere.  Also, for M non-zero I have an
extra sqrt(2).  I need this because I use a real basis with sines and
cosines instead of complex exponentials.</p>
<p>The minimization algorithm has three main modes of operation:</p>
<ul>
<li>
<p>Default mode: In the default mode, the routine tries to
find a minimum of the integral of the square of the expansion.
At an AH, this integral should be zero, and for any other
surface it will be positive.  One must remember that the
routine can easily end up in a local minimum that is not
a horizon.  To try to prevent this, the routine first
looks through a subset of the parameter space to try
to find a good guess for the global minimum.  This, of
course can fail.</p>
</li>
<li>
<p>Area minimization mode:  This mode is activated by
setting the parameter:</p>
</li>
</ul>
<p>mahf_minarea = "yes"</p>
<p>In this mode, the routine looks for a local minimum of the surface
area.  For time-symmetric data (and only then), such a minimum will
correspond to an AH.</p>
<ul>
<li>Trapped surface finding mode:  This mode is activated by
setting the parameter:</li>
</ul>
<p>mahf_trapped_surface = "yes"</p>
<p>In this mode, the routine looks for a local minimum of the integral of
the square of the quantity (expansion + trapped_surface_delta).  If
trapped_surface_delta is positive, then the routine will try to find a
surface whose expansion is -(trapped_surface_delta) everywhere on the
surface.  One can monitor the number of interpolated points that have
a negative expansion by setting veryverbose = "yes", which indicates
whether or not a trapped surface has truly been found.</p>
<h2 id="output">OUTPUT</h2>
<p>The routine controls its own output.  It produces output of 2 grid
functions (mahfgrid, mahf_exp) on its own (so please don't add them to
the Cactus output).  The reason for this is that the finder might be
called at times that have nothing to do with when Cactus wants to do
output.</p>
<p>The grid function <code class="codehilite">mahfgrid&#39; was described above.  The grid function</code>mahf_exp' is the expansion of outgoing photons on the level sets of
`mahfgrid'.</p>
<p>The finder also produces a series of data files:</p>
<p>1) "mahf_coeff.alm"</p>
<p>This file contains the coefficients of the spherical
harmonics expansion of the surface found.  Notice
that the finder almost always finds a surface, but this
might not be a horizon, so be careful.</p>
<p>The format in which these coefficients are saved is the following:</p>
<ul>
<li>
<p>Lines beginning with # are comments. These include the time
  at which the finder was called, and a line stating if the
  surface found is a horizon or not.</p>
</li>
<li>
<p>Empty lines indicate different calls to the finder (used when
  the finder is called many times during an evolution).</p>
</li>
<li>
<p>The coefficients are saved using a loop of the form:</p>
</li>
</ul>
<p>do l=1,lmax
     do m=-l,l
        write(<em>,</em>) a(l,m),l,m
     end do
  end do</p>
<p>Notice that because our functions are real, I use an expansion
  in sines and cosines and I really only consider positive values
  of m. On output my convention is that coefficients with positive
  m represent the terms:</p>
<p>P_(l,m) cos(m theta)</p>
<p>and coefficients with negative m represent the terms:</p>
<p>P_(l,m) sin(m theta)</p>
<p>2) "mahf.gauss"</p>
<p>This file contains a map of the gaussian curvature on the surface.
  The format of this file might still change in the near future.
  I need to talk to Werner about this.</p>
<ul>
<li>
<p>Lines beginning with # are comments.</p>
</li>
<li>
<p>The data is written is a loop:</p>
</li>
</ul>
<p>do i=0,ntheta-1
     do j=0,nphi-1
        write gaussian(i,j)
     end do
  end do</p>
<p>theta and phi are subdivided uniformly
  (according to grid type) in the intervals:</p>
<p>octant:    theta=[0,pi/2]  phi=[0,pi/2]
  quadrant:  theta=[0,pi]    phi=[0,pi/2]
  full:      theta=[0,pi]    phi=[0,2 pi]</p>
<p>3) "mahf_area.tl"</p>
<p>Area of the surface for each time the finder was called.
   Again, remember that the surface might not be a horizon.</p>
<p>4) "mahf_mass.tl"</p>
<p>Mass of the surface for each time the finder was called.
   This is defined as:</p>
<p>M = sqrt(A/(16 pi))</p>
<p>Again, remember that the surface might not be a horizon.</p>
<p>5) "mahf_circ_eq.tl"</p>
<p>Equatorial circumference of the surface.
   Again, remember that the surface might not be a horizon.</p>
<p>6) "mahf_meri_p1.tl"</p>
<p>Length of meridian of surface for phi=0.
   Again, remember that the surface might not be a horizon.</p>
<p>7) "mahf_meri_p2.tl"</p>
<p>Length of meridian of surface surface for phi=pi/2.
   Again, remember that the surface might not be a horizon.</p>
<p>8) "mahf_logfile"</p>
<p>Log file for the last time the horizon was called.  The
   reason why only the last call is here is that this file
   is very long.</p>
<h2 id="parameters">PARAMETERS</h2>
<p>Other parameters for the thorn are (see also file MinimumAHF_param.h):</p>
<p>STRINGS:</p>
<p>mahf_logfile     = [yes,no]      Write a log file.  If yes, the
                                 thorn produces the file "mahf_logfile".
                                 (default = "no")</p>
<p>mahf_verbose     = [yes,no]      Write messages to screen.
                                 (default = "yes")</p>
<p>mahf_veryverbose = [yes,no]      Write lots of messages to the screen,
                                 essentially the whole log file.
                                 (default = "no")</p>
<p>mahf_guessverbose = [yes,no]     Write a little info for each trial point
                                 calculated in the guess process.
                                 (default = "no")</p>
<p>mahf_2Doutput    = [yes,no]      2D output of grid functions?
                                 (default = "no")</p>
<p>mahf_3Doutput    = [yes,no]      3D output of grid functions?
                                 (default = "no")</p>
<p>mahf_mask        = [yes,no]      Use mask for definite horizons?
                                 (default = "no")</p>
<p>mahf_weakmask    = [yes,no]      Use mask for possible horizons?
                                 (default = "no")</p>
<p>mahf_phi         = [yes,no]      Expand in phi.  It is useful to switch
                                 this off if one knows in advance that
                                 the horizon is really axisymmetric.
                                 (default = "yes")</p>
<p>mahf_offset      = [yes,no]      Is the center offset from origin?
                                 (default = "no")</p>
<p>mahf_wander      = [yes,no]      Do we allow the center to wander?
                                 (default = "no")</p>
<p>mahf_refx        = [yes,no]      Do we have reflection symmetry x -&gt; -x?
                                 (default = "no")</p>
<p>mahf_refy        = [yes,no]      Do we have reflection symmetry y -&gt; -y?
                                 (default = "no")</p>
<p>mahf_refz        = [yes,no]      Do we have reflection symmetry z -&gt; -z?
                                 (default = "no")</p>
<p>mahf_octant      = [yes,no,high] Does the surface have octant symmetry?
                                 The "high" option forces also reflection
                                 symmetry across the x-y diagonal.
                                 (default = "no")</p>
<p>mahf_areamap     = [yes,no]      Construct an area map?.
                                 (default = "no")</p>
<p>mahf_sloppyguess = [yes,no]      This considers only spheres for the
                                 initial guess. It is much faster.
                                 (default = "no")</p>
<p>mahf_guessold    = [yes,no]      Use horizon found in previous call as
                                 initial guess?  Only relevant for
                                 evolutions.
                                 (default = "no")</p>
<p>mahf_inner       = [yes,no]      Tries to look for inner horizon instead.
                                 (default = "no")</p>
<p>mahf_guess_absmin = [yes,no]     Use the absolute minimum of the surface
                                 integral of the square of the expansion
                                 as the place to start the minimization
                                 process.  This is useful if you have
                                 a very dynamical spacetime, with possibly
                                 many local minima and you don't have any
                                 idea where (or even if) you have an AH.
                                 (default = "no")</p>
<p>mahf_manual_guess = [yes,no]     Use a manually specified guess, via. the
                                 parameters mahf_l0_guess, mahf_l2_guess,
                                 etc. (works only in octant mode right now)
                                 (default = "no")</p>
<p>INTEGERS:</p>
<p>mahf_findafter                   After how many timesteps start looking
                                 for horizons (default 0).</p>
<p>mahf_findevery                   How often to look for horizons (iterations).
                                 (default 1)</p>
<p>mahf_maxiter                     Maximum number of iterations of
                                 Powell's minimization algorithm.
                                 (default 10)</p>
<p>mahf_flowiter                    Maximum number of iterations for flow
                                 (default 200)</p>
<p>mahf_lmax (&lt;20)                  Number of terms in theta expansion
                                 (default 2)</p>
<p>mahf_ntheta                      Number of subdivisions in theta for
                                 surface integrals (default 200).</p>
<p>mahf_nphi                        Number of subdivisions in phi for
                                 surface integrals (default 200).</p>
<p>mahf_nn0                         Number of subdivisions of c0(0) for
                                 initial guess (default 10)</p>
<p>mahf_nn2                         Number of subdivisions of c0(2) for
                                 initial guess (default 10)</p>
<p>REALS:</p>
<p>mahf_findaftertime               After what time start looking for horizons.
                                 A non-zero value of this parameter overrides
                                 the paramter `mahf_findafter' above.
                                 (default 0.0)</p>
<p>mahf_r0                          Radius of initial sphere (0 forces largest
                                 possible sphere)
                                 (default 0.0)</p>
<p>mahf_xc                          x coordinate of center of expansion
                                 (default 0.0)</p>
<p>mahf_yc                          y coordinate of center of expansion
                                 (default 0.0)</p>
<p>mahf_zc                          z coordinate of center of expansion
                                 (default 0.0)</p>
<p>mahf_tol                         Fractional tolerance for minimization
                                 algorithm.  If we decrease by less than
                                 this in one iteration we are done.
                                 (default = 0.1)</p>
<p>trapped_surface_delta            In 'mahf_trapped_surface' mode, this 
                                 determines the expansion of the surface
                                 that one is looking for. Notice that a
                                 positive value of 'mahf_trapped_surface'
                                 will cause the finder to look for a 
                                 surface with expansion equal to MINUS
                                 this value everywhere.
                                 (default = 0.0)</p>
<p>mahf_flowa                       Alpha parameter for flow (default 0.01).</p>
<p>mahf_flowb                       Beta parameter for flow (default 0.01).</p>
<p>mahf_flowh                       Weight of H flow (default 0.0).</p>
<p>mahf_flowc                       Weight of C flow (default 1.0).</p>
<p>mahf_flown                       Weight of N flow (default 0.0).</p>
<p>mahf_flowtol                     Tolerance for flow (default 0.0001).</p>
<p>mahf_maskshrink                  Shrink factor for mask (default 0.9).</p>
<p>IMPORTANT:  Notice that the symmetry parameters refer to the surface
itself, and not to the grid.</p>
<ol>
<li>Dependencies of the thorn</li>
</ol>
<p>This thorn additionally requires thorns:  GenericAHF, util.
For testing purposes, one also needs:     analyticBH, exact.</p>
<ol>
<li>Thorn distribution</li>
</ol>
<p>This thorn is available to everyone.</p>
<ol>
<li>Additional information</li>
</ol>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>ahf_active</td>
<td>"no"</td>
<td>Activate AHFinder?</td>
<td></td>
</tr>
<tr>
<td>ahf_persists</td>
<td>"no"</td>
<td>Do the finder grid functions stay around?</td>
<td></td>
</tr>
<tr>
<td>ahf_ReportAlways</td>
<td>"no"</td>
<td>Report for all surfaces found (yes) or just for apparent horizons (no)</td>
<td></td>
</tr>
<tr>
<td>ahf_find3</td>
<td>"no"</td>
<td>Searching for 3 surfaces?</td>
<td></td>
</tr>
<tr>
<td>ahf_trapped_surface</td>
<td>"no"</td>
<td>Minimize (expansion + delta) to find trapped surface?</td>
<td></td>
</tr>
<tr>
<td>ahf_findevery</td>
<td>1</td>
<td>How often to look for horizons</td>
<td>1: :: "Set to 1 for searching each iteration"<em>OR</em></td>
</tr>
<tr>
<td>ahf_findafter</td>
<td>0</td>
<td>After how many iterations look for horizons</td>
<td>0: :: "Any positive integer"<em>OR</em></td>
</tr>
<tr>
<td>ahf_findaftertime</td>
<td>0.0</td>
<td>After how much time look for horizons</td>
<td>0.0: :: "Any positive real number. If non-zero overides ahf_findafter"<em>OR</em></td>
</tr>
<tr>
<td>trapped_surface_delta</td>
<td>0.0</td>
<td>find (expansion = delta) surface</td>
<td>: :: "Just a real number"<em>OR</em></td>
</tr>
<tr>
<td>ahf_phi</td>
<td>"no"</td>
<td>Expand also in phi? (seach for non-axisymmetric surface)</td>
<td></td>
</tr>
<tr>
<td>ahf_offset</td>
<td>"no"</td>
<td>Center offset from origin?</td>
<td></td>
</tr>
<tr>
<td>ahf_wander</td>
<td>"no"</td>
<td>Allow the center to wander?</td>
<td></td>
</tr>
<tr>
<td>ahf_lmax</td>
<td>8</td>
<td>Maximum number of terms in theta expansion</td>
<td>0:19 :: "Range from 0 to 19"<em>OR</em></td>
</tr>
<tr>
<td>ahf_xc</td>
<td>0.0</td>
<td>x-coordinate of center of expansion</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_yc</td>
<td>0.0</td>
<td>y-coordinate of center of expansion</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_zc</td>
<td>0.0</td>
<td>z-coordinate of center of expansion</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_xc_0</td>
<td>0.0</td>
<td>x-coordinate of center of expansion for first surface with find3</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_yc_0</td>
<td>0.0</td>
<td>y-coordinate of center of expansion for first surface with find3</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_zc_0</td>
<td>0.0</td>
<td>z-coordinate of center of expansion for first surface with find3</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_xc_1</td>
<td>0.0</td>
<td>x-coordinate of center of expansion for second surface with find3</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_yc_1</td>
<td>0.0</td>
<td>y-coordinate of center of expansion for second surface with find3</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_zc_1</td>
<td>0.0</td>
<td>z-coordinate of center of expansion for second surface with find3</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_xc_2</td>
<td>0.0</td>
<td>x-coordinate of center of expansion for third surface with find3</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_yc_2</td>
<td>0.0</td>
<td>y-coordinate of center of expansion for third surface with find3</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_zc_2</td>
<td>0.0</td>
<td>z-coordinate of center of expansion for third surface with find3</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_ntheta</td>
<td>100</td>
<td>Number of subdivisions in theta</td>
<td>1: :: "Any sensible integer"<em>OR</em></td>
</tr>
<tr>
<td>ahf_nphi</td>
<td>100</td>
<td>Number of subdivisions in phi</td>
<td>1: :: "Any sensible integer"<em>OR</em></td>
</tr>
<tr>
<td>ahf_refx</td>
<td>"no"</td>
<td>Reflection symmetry x-&gt;-x?</td>
<td></td>
</tr>
<tr>
<td>ahf_refy</td>
<td>"no"</td>
<td>Reflection symmetry y-&gt;-y?</td>
<td></td>
</tr>
<tr>
<td>ahf_refz</td>
<td>"no"</td>
<td>Reflection symmetry z-&gt;-z?</td>
<td></td>
</tr>
<tr>
<td>ahf_cartoon</td>
<td>"no"</td>
<td>Cartoon mode?</td>
<td></td>
</tr>
<tr>
<td>ahf_octant</td>
<td>"no"</td>
<td>Octant symmetry?</td>
<td>"no"   :: "No octant symmetry"<em>OR</em>  "yes"  :: "Octant symmetry: reflection symmetry on all three coordinate planes"<em>OR</em>  "high" :: "Octant symmetry + symmetry of rotation of pi/2 around z axis"<em>OR</em></td>
</tr>
<tr>
<td>ahf_minarea</td>
<td>"no"</td>
<td>Minimize area instead of expansion?</td>
<td></td>
</tr>
<tr>
<td>ahf_maxiter</td>
<td>10</td>
<td>Maximum number of iterations of POWELL</td>
<td>: :: "Any sensible integer value"<em>OR</em></td>
</tr>
<tr>
<td>ahf_tol</td>
<td>0.1</td>
<td>Tolerance for minimization routines</td>
<td>0: :: "A sensible positive number"<em>OR</em></td>
</tr>
<tr>
<td>ahf_sloppyguess</td>
<td>"no"</td>
<td>Use sphere as initial guess?</td>
<td></td>
</tr>
<tr>
<td>ahf_guess_absmin</td>
<td>"no"</td>
<td>Use absolute min to start minimization?</td>
<td></td>
</tr>
<tr>
<td>ahf_guessold</td>
<td>"no"</td>
<td>Use old horizon as initial guess?</td>
<td></td>
</tr>
<tr>
<td>ahf_inner</td>
<td>"no"</td>
<td>Look for inner horizon?</td>
<td></td>
</tr>
<tr>
<td>ahf_manual_guess</td>
<td>"no"</td>
<td>Use specified coefficients for guess?</td>
<td></td>
</tr>
<tr>
<td>ahf_nn0</td>
<td>10</td>
<td>Number of subdivisions of c0(0) for initial guess</td>
<td>: :: "Some positive integer"<em>OR</em></td>
</tr>
<tr>
<td>ahf_nn2</td>
<td>10</td>
<td>Number of subdivisions of c0(2) for initial guess</td>
<td>: :: "Some positive integer"<em>OR</em></td>
</tr>
<tr>
<td>ahf_r0</td>
<td>0.0</td>
<td>Radius of initial sphere (0 forces largest sphere)</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_r0_0</td>
<td>0.0</td>
<td>Radius of first initial sphere for find3 (0 forces largest sphere)</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_r0_1</td>
<td>0.0</td>
<td>Radius of second initial sphere for find3 (0 forces largest sphere)</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_r0_2</td>
<td>0.0</td>
<td>Radius of third initial sphere for find3 (0 forces largest sphere)</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_flow</td>
<td>"no"</td>
<td>Use flow instead of minimization?</td>
<td></td>
</tr>
<tr>
<td>ahf_flowiter</td>
<td>200</td>
<td>Maximum number of iterations for flow</td>
<td>0: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_flowa</td>
<td>0.01</td>
<td>alpha parameter for flow</td>
<td>: ::  "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_flowb</td>
<td>0.5</td>
<td>beta parameter for flow</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_flowh</td>
<td>0.0</td>
<td>Weight of H flow</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_flowc</td>
<td>1.0</td>
<td>Weight of C flow</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_flowtol</td>
<td>0.0001</td>
<td>Tolerance for flow</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_maxchange</td>
<td>0.1</td>
<td>Maximum relative difference between 1 big and 2 small steps</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_minchange</td>
<td>0.01</td>
<td>Minimum relative difference between 1 big and 2 small steps</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ahf_logfile</td>
<td>"no"</td>
<td>Write log file?</td>
<td></td>
</tr>
<tr>
<td>ahf_verbose</td>
<td>"yes"</td>
<td>Print messages to screen?</td>
<td></td>
</tr>
<tr>
<td>ahf_veryverbose</td>
<td>"no"</td>
<td>Print messages at each iteration step to screen?</td>
<td></td>
</tr>
<tr>
<td>ahf_guessverbose</td>
<td>"no"</td>
<td>Print info on initial guess?</td>
<td></td>
</tr>
<tr>
<td>ahf_1Doutput</td>
<td>"no"</td>
<td>1D output of grid functions?</td>
<td></td>
</tr>
<tr>
<td>ahf_2Doutput</td>
<td>"no"</td>
<td>2D output of grid functions?</td>
<td></td>
</tr>
<tr>
<td>ahf_3Doutput</td>
<td>"no"</td>
<td>3D output of grid functions?</td>
<td></td>
</tr>
<tr>
<td>ahf_HDF5output</td>
<td>"no"</td>
<td>HDF5 output of AHFinder data?</td>
<td></td>
</tr>
<tr>
<td>ahf_areamap</td>
<td>"no"</td>
<td>Find area map?</td>
<td></td>
</tr>
<tr>
<td>ahf_gaussout</td>
<td>"yes"</td>
<td>Output gaussian curvature of horizon?</td>
<td></td>
</tr>
<tr>
<td>ahf_mask</td>
<td>"off"</td>
<td>Use mask?</td>
<td>"off"    :: "Mask is off"<em>OR</em>"strong" :: "Mask set only for definite horizons"<em>OR</em>"weak"   :: "Mask set for both definite and probable horizons"<em>OR</em></td>
</tr>
<tr>
<td>ahf_masktype</td>
<td>"cube"</td>
<td>Type of mask</td>
<td>"lego" :: "Mask is a lego sphere"<em>OR</em>"cube" :: "Mask is a cube"<em>OR</em>"poly" :: "Mask is a polyhedra"<em>OR</em></td>
</tr>
<tr>
<td>ahf_mask_time</td>
<td>-1.0</td>
<td>Time after which to start setting the mask</td>
<td>: :: "Anything goes. Negative number means setting the mask as soon as possible"<em>OR</em></td>
</tr>
<tr>
<td>ahf_mask_0</td>
<td>"yes"</td>
<td>Mask for first horizon with find3?</td>
<td></td>
</tr>
<tr>
<td>ahf_mask_1</td>
<td>"yes"</td>
<td>Mask for second horizon with find3?</td>
<td></td>
</tr>
<tr>
<td>ahf_mask_2</td>
<td>"yes"</td>
<td>Mask for third horizon with find3?</td>
<td></td>
</tr>
<tr>
<td>ahf_maskbuffer</td>
<td>5</td>
<td>Number of grid points in mask buffer zone</td>
<td>0 :: "Positive please"<em>OR</em></td>
</tr>
<tr>
<td>ahf_maskshrink</td>
<td>0.8</td>
<td>Shrink factor for mask</td>
<td>0.0:1.0 :: "Must be positive and not larger than 1"<em>OR</em></td>
</tr>
<tr>
<td>ahf_shiftcoeff</td>
<td>0.0</td>
<td>Coefficient for shift</td>
<td>: :: "Anything goes"<em>OR</em></td>
</tr>
<tr>
<td>interpolation_order</td>
<td>2</td>
<td>Order for interpolation</td>
<td>1:4 :: "Choose between first and fourth order interpolation"<em>OR</em></td>
</tr>
<tr>
<td>interpolation_operator</td>
<td>"uniform</td>
<td>Name of interpolation operator to use</td>
<td>".+" :: "A valid name for a registered interpolation operator"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="hydro_analysis">Hydro_Analysis</h3>
<p>Cactus Code Thorn Hydro_Analysis
Author(s)    : Frank Löffler
Maintainer(s): Einstein Toolkit maintainers
Licence      : LGPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides basic hydro analysis routines.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hydro_Analysis_comp_rho_max</td>
<td>"false"</td>
<td>Look for the value and location of the maximum of rho</td>
<td></td>
</tr>
<tr>
<td>Hydro_Analysis_comp_rho_max_every</td>
<td>1</td>
<td>How often to look  for the value and location of the maximum of rho</td>
<td>0:0 :: "Never"<em>OR</em>  1:* :: "every so often"<em>OR</em></td>
</tr>
<tr>
<td>Hydro_Analysis_average_multiple_maxima_locations</td>
<td>"false"</td>
<td>when finding more than one global maximum location, average position and use result</td>
<td></td>
</tr>
<tr>
<td>verbosity_level</td>
<td>1</td>
<td>how much information to ouptut to the logs</td>
<td>0 :: "Output nothing"<em>OR</em>  1 :: "warn when finding multiple maxima"<em>OR</em>  2 :: "also output location of maxima" <em>OR</em></td>
</tr>
<tr>
<td>Hydro_Analysis_rho_max_loc_only_positive_x</td>
<td>"false"</td>
<td>Restrict location search for density maximum to positive values of x</td>
<td></td>
</tr>
<tr>
<td>Hydro_Analysis_rho_max_loc_use_rotatingsymmetry180</td>
<td>"false"</td>
<td>Map found maxima into positive x half-plane assuming pi-symmetry</td>
<td></td>
</tr>
<tr>
<td>Hydro_Analysis_comp_vol_weighted_center_of_mass</td>
<td>"false"</td>
<td>Look for the location of the volume-weighted center of mass</td>
<td></td>
</tr>
<tr>
<td>Hydro_Analysis_comp_rho_max_origin_distance</td>
<td>"false"</td>
<td>Look for the proper distance between the maximum of the density and the origin (along a straight coordinate line)</td>
<td></td>
</tr>
<tr>
<td>Hydro_Analysis_rho_max_origin_distance_npoints</td>
<td>100</td>
<td>Number of points along the straight line for measuring proper distance</td>
<td>1:* :: "Any positive number"<em>OR</em></td>
</tr>
<tr>
<td>Hydro_Analysis_interpolator_name</td>
<td>"uniform</td>
<td>Name of the interpolator</td>
<td>"Lagrange polynomial interpolation (tensor product)" :: "from AEILocalInterp"<em>OR</em>  "Lagrange polynomial interpolation (maximum degree)" :: "from AEILocalInterp"<em>OR</em>  "Hermite polynomial interpolation" :: "from AEILocalInterp"<em>OR</em>  "uniform cartesian" :: "from LocalInterp"<em>OR</em>  ".<em>" :: "must be a registered interpolator"*OR</em></td>
</tr>
<tr>
<td>Hydro_Analysis_interpolator_options</td>
<td>"order=2"</td>
<td>Options for the interpolator</td>
<td>".<em>" :: "must be a valid option specification"*OR</em></td>
</tr>
<tr>
<td>Hydro_Analysis_interpolator_coordinates</td>
<td>"cart3d"</td>
<td>Coordinate system</td>
<td>".<em>" :: "must be a registered coordinate system"*OR</em></td>
</tr>
<tr>
<td>Hydro_Analysis_comp_core_rho_centroid</td>
<td>"no"</td>
<td>compute location of the centroid of rho*x in region r_core around densest point</td>
<td></td>
</tr>
<tr>
<td>Hydro_Analysis_r_core</td>
<td>4.0</td>
<td>size of region around densest point in which to compute the centroid of rho*x</td>
<td>0:* :: "any positive radius. suggested is &frac12; of stellar radius"<em>OR</em></td>
</tr>
<tr>
<td>Hydro_Analysis_core_rho_rel_min</td>
<td>0.01</td>
<td>only include points where rho&gt;rho_rel_min*rho_max when computing centroid of rho*x around densest point</td>
<td>0:* :: "any positive value. For best results should be such that the region selected is smaller than r_core. 1/10 of rho_max should be fine."<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="admanalysis">ADMAnalysis</h3>
<p>Cactus Code Thorn ADMAnalysis
Author(s)    : Tom Goodale
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn does basic analysis of the metric and extrinsic curvature 
tensors.</p>
<p>It calculates</p>
<p>the trace of the extrinsic curvature ({\bf trK})</p>
<p>the determinant of the metric ({\bf detg})</p>
<p>the components of the metric in spherical coordinates 
  (grr,grq,grp,gqq,gqp,gpp)</p>
<p>the components of the extrinsic curvature in spherical coordinates 
  (Krr,Krq,Krp,Kqq,Kqp,Kpp)</p>
<p>components of the Ricci tensor</p>
<p>the Ricci scalar</p>
<p>if output is requested for them.</p>
<p>(q refers to the theta coordinate and p to the phi coordinate.)</p>
<p>If the parameter 'normalize_dtheta_dphi' is true, the thorn 
projects the spherical components onto (r*dtheta, r*sin(theta)*dphi)
instead of the default vector (dtheta,dphi).</p>
<p>This thorn knows how to handle 'physical' and 'static conformal'
metric types.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>normalize_dtheta_dphi</td>
<td>"no"</td>
<td>Project angular components onto r*dtheta and r*sin(theta)*dphi?</td>
<td></td>
</tr>
<tr>
<td>ricci_persist</td>
<td>"no"</td>
<td>Keep storage of  the  Ricci tensor and scalar around?</td>
<td></td>
</tr>
<tr>
<td>ricci_timelevels</td>
<td>1</td>
<td>Number of time levels for the Ricci tensor and scalar</td>
<td>1:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>ricci_prolongation_type</td>
<td>"none"</td>
<td>The kind of boundary prolongation for the Ricci tensor and scalar</td>
<td>"Lagrange" :: "standard prolongation (requires several time levels)"<em>OR</em>  "copy"     :: "use data from the current time level (requires only one time level)"<em>OR</em>  "none"     :: "no prolongation (use this if you do not have enough time levels active)"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="quasilocalmeasures">QuasiLocalMeasures</h3>
<p>error| Key | Defaults | Describe | Option |
| ------------ | ------------- | ------------- | ------------- |
| verbose | "no" | Produce log output while running |  |
| veryverbose | "no" | Produce much log output while running |  |
| num_surfaces | 1 | Number of surfaces |   0:100 :: ""<em>OR</em> |
| coordsystem | "cart3d" | The coordinate system to use |   "" :: "must be a registered coordinate system"<em>OR</em> |
| interpolator | "Lagrange | The interpolator to use |   "" :: "must be a registered interpolator"<em>OR</em> |
| interpolator_options | "order=2" | Options for the interpolator |   "" :: "must be a valid options specification"<em>OR</em> |
| spatial_order | 2 | Order of spatial differencing |   2 :: "second order"<em>OR</em>  4 :: "fourth order"<em>OR</em> |
| killing_vector_method | "eigenvector" | Method for finding the Killing vector field |   "axial"       :: "Assume that d/dphi is a Killing vector"<em>OR</em>  "eigenvector" :: "Solve the Killing vector equation as eigenvector equation"<em>OR</em>  "gradient"    :: "Calculate the normal to the gradient of a scalar"<em>OR</em> |
| killing_vector_normalisation | "average" | Method for normalising the Killing vector field |   "average" :: "Average several integral lines"<em>OR</em>  "median"  :: "Use the median integral line"<em>OR</em> |
| output_vtk_every | 0 | Output a VTK file with the main 2D |   0   :: "don't output VTK file"<em>OR</em>  1:* :: "output every so many iterations"<em>OR</em> |</p>
<h3 id="admmass">ADMMass</h3>
<p>Cactus Code Thorn ADMMass
Author(s)    : Frank Löffler
Maintainer(s): Frank Löffler 
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn can be used to calculate different approximations of the ADM mass
on a finite grid.</p>
<p>It requires C99 to compile. For gcc or icc, add -std=c99 to the compiler
options.</p>
<h2 id="copyright_4">Copyright</h2>
<p>This thorn is copyright (C) 2005
by Frank Loeffler <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#102;&#114;&#97;&#110;&#107;&#46;&#108;&#111;&#101;&#102;&#102;&#108;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#102;&#114;&#97;&#110;&#107;&#46;&#108;&#111;&#101;&#102;&#102;&#108;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<p>This thorn is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.</p>
<p>This thorn is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this thorn (see the file COPYING in this directory);
if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>ADMMass_number</td>
<td>1</td>
<td>number of measurements</td>
<td>0: :: "0 or positive"<em>OR</em></td>
</tr>
<tr>
<td>ADMMass_use_surface_distance_as_volume_radius</td>
<td>"yes"</td>
<td>Use ADMMass_surface_distance instead of ADMMass_volume_radius</td>
<td></td>
</tr>
<tr>
<td>ADMMass_use_all_volume_as_volume_radius</td>
<td>"no"</td>
<td>Use the whole grid for volume integration</td>
<td></td>
</tr>
<tr>
<td>ADMMass_Excise_Horizons</td>
<td>"no"</td>
<td>Should we exclude the region inside the AH to the volume integral</td>
<td></td>
</tr>
<tr>
<td>ADMMass_Debug</td>
<td>"no"</td>
<td>Enable some info at runtime</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="multipole">Multipole</h3>
<p>=========
Multipole
=========</p>
<p>=============    ==============================================================================================
Authors          Ian Hinder and Andrew Knapp
Maintainer       Ian Hinder
Licence          GNU GPL version 2
Documentation    <a href="http://einsteintoolkit.org/documentation/ThornGuide/ThornGuidech133.html#x149-2383000O9">http://einsteintoolkit.org/documentation/ThornGuide/ThornGuidech133.html#x149-2383000O9</a>
Download         svn checkout <a href="https://svn.einsteintoolkit.org/cactus/EinsteinAnalysis/Multipole/trunk">https://svn.einsteintoolkit.org/cactus/EinsteinAnalysis/Multipole/trunk</a> Multipole
=============    ==============================================================================================</p>
<hr />
<h2 id="purpose-of-this-thorn_2">Purpose of This Thorn</h2>
<p>The Multipole thorn performs spherical harmonic mode decomposition of
Cactus grid functions on coordinate spheres.  It can decompose
multiple grid functions with any spin-weight on multiple spheres.
This thorn uses the interpolator interface to access grid functions,
so works with mesh-refinement and multi-patch.</p>
<hr />
<h2 id="required-thorns">Required thorns</h2>
<ul>
<li>An interpolator, e.g. AEILocalInterp</li>
</ul>
<hr />
<h2 id="related-thorns">Related thorns</h2>
<ul>
<li>WeylScal4 can be used to compute the Weyl scalars, which can then be
  decomposed into modes on coordinate spheres by Multipole.</li>
</ul>
<hr />
<h2 id="publications_1">Publications</h2>
<p>Multipole has been used in the following publications:</p>
<hr />
<h2 id="copyright_5">Copyright</h2>
<p>This thorn is copyright (C) 2007-2011 (C) by Ian Hinder and Andrew
Knapp.</p>
<p>This thorn is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.</p>
<p>This thorn is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License
along with this thorn (see the file COPYING in this directory);
if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>interpolator_name</td>
<td>"Hermite</td>
<td>Which interpolator should I use</td>
<td>".+" :: "Any nonempty string"<em>OR</em></td>
</tr>
<tr>
<td>interpolator_pars</td>
<td>"order=3</td>
<td>Parameters for the interpolator</td>
<td>".<em>" :: "Any string that Util_TableSetFromString() will take"*OR</em></td>
</tr>
<tr>
<td>coord_system</td>
<td>"cart3d"</td>
<td>What is the coord system?</td>
<td>".<em>" :: "Any smart string will do"*OR</em></td>
</tr>
<tr>
<td>integration_method</td>
<td>"midpoint"</td>
<td>How to do surface integrals</td>
<td>"midpoint"      :: "Midpoint rule (1<sup>st</sup> order)"<em>OR</em>  "Simpson"       :: "Simpson's rule (4<sup>th</sup> order) [requires even ntheta and nphi]"<em>OR</em>  "trapezoidal"   :: "Trapezoidal rule (2<sup>nd</sup> order)"<em>OR</em>  "DriscollHealy" :: "Driscoll &amp; Healy (exponentially convergent) [requires even ntheta]"<em>OR</em></td>
</tr>
<tr>
<td>out_dir</td>
<td>""</td>
<td>Output directory for Extract's files, overrides IO::out_dir</td>
<td>".+" :: "A valid directory name"<em>OR</em>  "^$" :: "An empty string to choose the default from IO::out_dir"<em>OR</em></td>
</tr>
<tr>
<td>out_every</td>
<td>1</td>
<td>How often to output</td>
<td>0   :: "no output"<em>OR</em>  1:* :: "output every to many iterations"<em>OR</em></td>
</tr>
<tr>
<td>out_1d_every</td>
<td>0</td>
<td>How often to output 1d data</td>
<td>0   :: "no output"<em>OR</em>  1:* :: "output every to many iterations"<em>OR</em></td>
</tr>
<tr>
<td>nradii</td>
<td>1</td>
<td>How many extraction radii?</td>
<td>0:100 :: ""<em>OR</em></td>
</tr>
<tr>
<td>ntheta</td>
<td>50</td>
<td>How many points in the theta direction?</td>
<td>0:* :: "Positive please"<em>OR</em></td>
</tr>
<tr>
<td>nphi</td>
<td>100</td>
<td>How many points in the phi direction?</td>
<td>1:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>variables</td>
<td>""</td>
<td>What variables to decompose</td>
<td>".<em>" :: "A list of variables"*OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Output detailed information about what is happening</td>
<td></td>
</tr>
<tr>
<td>l_max</td>
<td>2</td>
<td>The maximum l mode to extract</td>
<td>0:* :: "l &gt;= 0"<em>OR</em></td>
</tr>
<tr>
<td>enable_test</td>
<td>"no"</td>
<td>whether to set a spherical harmonic in the 'harmonic' grid functions</td>
<td></td>
</tr>
<tr>
<td>test_l</td>
<td>2</td>
<td>which mode to put into the test variables</td>
<td>* :: "Any integer"<em>OR</em></td>
</tr>
<tr>
<td>test_m</td>
<td>2</td>
<td>which mode to put into the test variables</td>
<td>* :: "Any integer"<em>OR</em></td>
</tr>
<tr>
<td>test_sw</td>
<td>-2</td>
<td>which spin weight to put into the test variables</td>
<td>* :: "Any integer"<em>OR</em></td>
</tr>
<tr>
<td>test_mode_proportional_to_r</td>
<td>"no"</td>
<td>whether the test spherical harmonic coefficient is proportional to the radial coordinate</td>
<td></td>
</tr>
<tr>
<td>mode_type</td>
<td>"deprecated"</td>
<td>Which type of mode extraction do we have</td>
<td>"all modes"     :: "Extract all modes up to (l_mode, m_mode)."<em>OR</em>  "specific mode" :: "Select one specific (l_mode, m_mode) mode"<em>OR</em>  "deprecated"    :: "Deprecated"<em>OR</em></td>
</tr>
<tr>
<td>l_min</td>
<td>-1</td>
<td>all modes: above which l mode to calculate/ specific mode: which l mode to extract</td>
<td>-1:* :: "Deprecated"<em>OR</em></td>
</tr>
<tr>
<td>l_mode</td>
<td>-1</td>
<td>The maximum l mode to extract</td>
<td>-1:* :: "Deprecated"<em>OR</em></td>
</tr>
<tr>
<td>m_mode</td>
<td>-100</td>
<td>all modes: Up to which m mode to calculate/ specific mode: which m mode to extract</td>
<td>-100:* :: "Deprecated"<em>OR</em></td>
</tr>
<tr>
<td>output_ascii</td>
<td>"yes"</td>
<td>Output a simple ASCII file for each mode at each radius</td>
<td></td>
</tr>
<tr>
<td>output_hdf5</td>
<td>"no"</td>
<td>Output an HDF5 file for each variable containing one dataset per mode at each radius</td>
<td></td>
</tr>
<tr>
<td>hdf5_chunk_size</td>
<td>200</td>
<td>How many iterations to preallocate in extensible HDF5 datasets</td>
<td>1:* :: "Any integer"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="extract">Extract</h3>
<p>Cactus Code Thorn Extract
Author(s)    : Gabrielle Allen<br />
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Calculate gauge invariant waveforms, using the Moncrief formalism,
for cases when the spacetime approximates spherical symmetry.</p>
<p>Calculate other quantities on a surface, such as ADM mass, momenta,
and spins.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>timecoord</td>
<td>"both"</td>
<td>Which time coordinate to use</td>
<td>"proper" :: ""<em>OR</em>  "coordinate" :: ""<em>OR</em>  "both" :: ""<em>OR</em></td>
</tr>
<tr>
<td>all_modes</td>
<td>"yes"</td>
<td>Extract: all l,m modes up to l</td>
<td></td>
</tr>
<tr>
<td>Cauchy</td>
<td>"no"</td>
<td>Do Cauchy data extraction at given timestep</td>
<td></td>
</tr>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Say what is happening</td>
<td></td>
</tr>
<tr>
<td>doADMmass</td>
<td>"no"</td>
<td>Calculate ADM mass at extraction radii</td>
<td></td>
</tr>
<tr>
<td>do_momentum</td>
<td>"no"</td>
<td>Calculate momentum at extraction radii</td>
<td></td>
</tr>
<tr>
<td>do_spin</td>
<td>"no"</td>
<td>Calculate spin at extraction radii</td>
<td></td>
</tr>
<tr>
<td>itout</td>
<td>1</td>
<td>How often to extract, in iterations</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>l_mode</td>
<td>2</td>
<td>l mode</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>m_mode</td>
<td>0</td>
<td>m mode (ignore if extracting all modes</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>Nt</td>
<td>100</td>
<td>Number of theta divisions</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>Np</td>
<td>100</td>
<td>Number of phi divisions</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>Cauchy_timestep</td>
<td>0</td>
<td>Timestep for Cauchy data extraction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>num_detectors</td>
<td>0</td>
<td>Number of detectors</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>detector1</td>
<td>5.0</td>
<td>Coordinate radius of detector 1</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>detector2</td>
<td>5.0</td>
<td>Coordinate radius of detector 2</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>detector3</td>
<td>5.0</td>
<td>Coordinate radius of detector 3</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>detector4</td>
<td>5.0</td>
<td>Coordinate radius of detector 4</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>detector5</td>
<td>5.0</td>
<td>Coordinate radius of detector 5</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>detector6</td>
<td>5.0</td>
<td>Coordinate radius of detector 6</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>detector7</td>
<td>5.0</td>
<td>Coordinate radius of detector 7</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>detector8</td>
<td>5.0</td>
<td>Coordinate radius of detector 8</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>detector9</td>
<td>5.0</td>
<td>Coordinate radius of detector 9</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>origin_x</td>
<td>0.0</td>
<td>x-origin to extract about</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>origin_y</td>
<td>0.0</td>
<td>y-origin to extract about</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>origin_z</td>
<td>0.0</td>
<td>z-origin to extract about</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Cauchy_r1</td>
<td>1.0</td>
<td>First radius for Cauchy data extraction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>Cauchy_dr</td>
<td>0.2</td>
<td>Gridspacing for Cauchy data extraction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>interpolation_operator</td>
<td>"uniform</td>
<td>Interpolation operator to use (check LocalInterp)</td>
<td>.+ :: ""<em>OR</em></td>
</tr>
<tr>
<td>interpolation_order</td>
<td>1</td>
<td>Order for interpolation</td>
<td>1:4 :: "Choose between first and forth order interpolation"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="outflow">Outflow</h3>
<p>Cactus Code Thorn Outflow
Thorn Author(s)     : Roland Haas <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#111;&#108;&#97;&#110;&#100;&#46;&#104;&#97;&#97;&#115;&#64;&#112;&#104;&#121;&#115;&#105;&#99;&#115;&#46;&#103;&#97;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#111;&#108;&#97;&#110;&#100;&#46;&#104;&#97;&#97;&#115;&#64;&#112;&#104;&#121;&#115;&#105;&#99;&#115;&#46;&#103;&#97;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
Thorn Maintainer(s) : Roland Haas <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#111;&#108;&#97;&#110;&#100;&#46;&#104;&#97;&#97;&#115;&#64;&#112;&#104;&#121;&#115;&#105;&#99;&#115;&#46;&#103;&#97;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#111;&#108;&#97;&#110;&#100;&#46;&#104;&#97;&#97;&#115;&#64;&#112;&#104;&#121;&#115;&#105;&#99;&#115;&#46;&#103;&#97;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>
                      Tanja Bode  <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#116;&#97;&#110;&#106;&#97;&#46;&#98;&#111;&#100;&#101;&#64;&#117;&#110;&#105;&#45;&#116;&#117;&#101;&#98;&#105;&#110;&#103;&#101;&#110;&#46;&#100;&#101;">&#116;&#97;&#110;&#106;&#97;&#46;&#98;&#111;&#100;&#101;&#64;&#117;&#110;&#105;&#45;&#116;&#117;&#101;&#98;&#105;&#110;&#103;&#101;&#110;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn:
Calculate the flux across a spherical surface.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>compute_every</td>
<td>1</td>
<td>How frequently to compute the outflow</td>
<td>1:* :: "number of iterations"<em>OR</em></td>
</tr>
<tr>
<td>num_detectors</td>
<td>0</td>
<td>how many detectors do we have</td>
<td>0:* :: "number of detectors"<em>OR</em></td>
</tr>
<tr>
<td>coord_system</td>
<td>"cart3d"</td>
<td>What is the coord system?</td>
<td>".<em>" :: "Any smart string will do"*OR</em></td>
</tr>
<tr>
<td>interpolator_name</td>
<td>"Hermite</td>
<td>Which interpolator should I use</td>
<td>".+" :: "Any nonempty string"<em>OR</em></td>
</tr>
<tr>
<td>interpolator_pars</td>
<td>"order=3"</td>
<td>Parameters for the interpolator</td>
<td>".<em>" :: "Any string that Util_TableSetFromString() will take"*OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>1</td>
<td>How verbose do you want it?</td>
<td>0:* :: "0 is nothing, 1 is interesting, &gt;1 is crazy"<em>OR</em></td>
</tr>
<tr>
<td>out_format</td>
<td>".19g"</td>
<td>Which format for Scalar floating-point number output</td>
<td>^(.[1]?[0-9])?[EGefg]$ :: "output with given precision in exponential / floating point notation"<em>OR</em></td>
</tr>
<tr>
<td>output_2d_data</td>
<td>"no"</td>
<td>output 2d data on spherical surface</td>
<td></td>
</tr>
<tr>
<td>output_relative_coordinates</td>
<td>"no"</td>
<td>output coordinates on spheroid relative to sf_centroid, absolute coordinates otherwise</td>
<td></td>
</tr>
<tr>
<td>extra_variables</td>
<td>""</td>
<td>extra (scalar) variables to project onto the spherical surface</td>
<td>".<em>" :: "Any Cactus variables"*OR</em></td>
</tr>
<tr>
<td>threshold_on_var</td>
<td>"w_lorentz"</td>
<td>Which variable to use as threshold</td>
<td>"eninf"     :: "(Approximate) specific energy at infinity, - u_t - 1"<em>OR</em>    "w_lorentz" :: "Lorentz factor"<em>OR</em></td>
</tr>
<tr>
<td>num_thresholds</td>
<td>0</td>
<td>how many thresholds to use</td>
<td>0    :: "ignore thresholds, output only one flux"<em>OR</em>  1:20 :: "how many to use"<em>OR</em></td>
</tr>
</tbody>
</table>
<h2 id="cactusexamples">CactusExamples</h2>
<h3 id="helloworld">HelloWorld</h3>
<p>Cactus Code Thorn HelloWorld
Author(s)    : Cactus team
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Hello World example for Cactus, possibly the simplest thorn ever.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="idwavemol">IDWaveMoL</h3>
<p>Cactus Code Thorn IDWaveMoL
Author(s)    : Ian Hawke
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Provides initial data for the WaveMoL thorn.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>initial_data</td>
<td>"gaussian"</td>
<td>Type of initial data</td>
<td>"gaussian"   :: "Gaussian wave"<em>OR</em>  "plane"      :: "plane wave"<em>OR</em></td>
</tr>
<tr>
<td>amplitude</td>
<td>1.0</td>
<td>The amplitude of the waves</td>
<td><em>:</em> :: "No restriction"<em>OR</em></td>
</tr>
<tr>
<td>radius</td>
<td>0.0</td>
<td>The radius of the gaussian wave</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>sigma</td>
<td>0.1</td>
<td>The sigma for the gaussian wave</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>centrex</td>
<td>0.0</td>
<td>The centre of the gaussian wave, x-direction</td>
<td><em>:</em> :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>centrey</td>
<td>0.0</td>
<td>The centre of the gaussian wave, y-direction</td>
<td><em>:</em> :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>centrez</td>
<td>0.0</td>
<td>The centre of the gaussian wave, z-direction</td>
<td><em>:</em> :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>kx</td>
<td>0.0</td>
<td>Wave number in the x-direction</td>
<td><em>:</em> :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ky</td>
<td>0.0</td>
<td>Wave number in the y-direction</td>
<td><em>:</em> :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>kz</td>
<td>0.0</td>
<td>Wave number in the z-direction</td>
<td><em>:</em> :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>offsett</td>
<td>0.0</td>
<td>Wave offset in the time-direction</td>
<td><em>:</em> :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>offsetx</td>
<td>0.0</td>
<td>Wave offset in the x-direction</td>
<td><em>:</em> :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>offsety</td>
<td>0.0</td>
<td>Wave offset in the y-direction</td>
<td><em>:</em> :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>offsetz</td>
<td>0.0</td>
<td>Wave offset in the z-direction</td>
<td><em>:</em> :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>slopet</td>
<td>0.0</td>
<td>Wave slope in the time-direction</td>
<td><em>:</em> :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>slopex</td>
<td>0.0</td>
<td>Wave slope in the x-direction</td>
<td><em>:</em> :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>slopey</td>
<td>0.0</td>
<td>Wave slope in the y-direction</td>
<td><em>:</em> :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>slopez</td>
<td>0.0</td>
<td>Wave slope in the z-direction</td>
<td><em>:</em> :: "Anything"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="helloworldcuda">HelloWorldCUDA</h3>
<p>Cactus Code Thorn HelloWorldCUDA
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;">&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;">&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;</a>
Licence      : GPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>"Hello, World!" implemented in CUDA.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="timerinfo">TimerInfo</h3>
<p>Cactus Code Thorn TimerInfo
Author(s)    : Cactus team
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>At the moment just prints out the value of all timers at chosen
iteration intervals. Will be worked into a more useful thorn to 
report of different kinds of timing information in different ways</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>every</td>
<td>0</td>
<td>How often to print information</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>clock</td>
<td>"all"</td>
<td>Which clock to use</td>
<td>.* :: "Anything"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="wavetoy2df77">WaveToy2DF77</h3>
<p>Cactus Code Thorn WaveToy2DF77
Author(s)    : Gabrielle Allen
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn illustrates the solution of the scalar wave equation in 2D using
centered explicit finite differencing. Included are routines to
NOTE: This thorn isn't working properly yet for multiple processors, it 
      will be fixed very soon in the development version.</p>
<ul>
<li>Set up and register the 2D spatial coordinate system</li>
<li>Calculate initial data</li>
<li>Evolve using a standard explicit method</li>
</ul>
<p>The Cactus infrastructure used includes</p>
<ul>
<li>Boundary conditions  (CactusBase/Boundary)</li>
<li>Timestep calculation (CactusBase/Time)</li>
<li>Parallel driver      (CactusPUGH/PUGH)</li>
<li>IO           (Standard IO thorns)</li>
</ul>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="wavetoy1df77">WaveToy1DF77</h3>
<p>Cactus Code Thorn WaveToy1DF77
Author(s)    : Gabrielle Allen
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn illustrates the solution of the scalar wave equation in 1D using
centered explicit finite differencing. Included are routines to</p>
<ul>
<li>Set up and register the 1D spatial coordinate system</li>
<li>Calculate initial data</li>
<li>Evolve using a standard explicit method</li>
</ul>
<p>The Cactus infrastructure used includes</p>
<ul>
<li>Boundary conditions  (CactusBase/Boundary)</li>
<li>Timestep calculation (CactusBase/Time)</li>
<li>Parallel driver      (CactusPUGH/PUGH)</li>
<li>IO           (Standard IO thorns)</li>
</ul>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="wavetoyopencl">WaveToyOpenCL</h3>
<p>Cactus Code Thorn WaveToyOpenCL
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;">&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;">&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;</a>
Licence      : GPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Scalar wave equation implemented in OpenCL.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Output progress information</td>
<td></td>
</tr>
<tr>
<td>wavelength</td>
<td>1.0</td>
<td>Wavelength of initial data</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="sampleio">SampleIO</h3>
<p>Cactus Code Thorn SampleIO
Author(s)    : Thomas Radke
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides a very simple I/O method which prints the values of
three-dimensional Cactus grid functions and arrays at a chosen location
(selected by parameters) to screen.</p>
<p>The I/O method makes use of the Cactus Hyperslabbing API to obtain the data
values to print.</p>
<p>The code in this thorn is well documented and can be used as an example to 
build your own I/O method.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>out_every</td>
<td>-1</td>
<td>How often to do SampleIO output, overrides IO::out_every</td>
<td>1:* :: "Every so many iterations"<em>OR</em>   0:  :: "Disable SampleIO output"<em>OR</em>  -1:  :: "Choose the default from IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>out_vars</td>
<td>""</td>
<td>Variables to output by SampleIO</td>
<td>".+" :: "Space-separated list of fully qualified variable/group names"<em>OR</em>  "^$" :: "An empty string to output nothing"<em>OR</em></td>
</tr>
<tr>
<td>point_x</td>
<td>0</td>
<td>x-index (starting from 0) locating the array element to output</td>
<td>0:* :: "An index between [0, nx)"<em>OR</em></td>
</tr>
<tr>
<td>point_y</td>
<td>0</td>
<td>y-index (starting from 0) locating the array element to output</td>
<td>0:* :: "An index between [0, ny)"<em>OR</em></td>
</tr>
<tr>
<td>point_z</td>
<td>0</td>
<td>z-index (starting from 0) locating the array element to output</td>
<td>0:* :: "An index between [0, nz)"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="poisson">Poisson</h3>
<p>Cactus Code Thorn Poisson
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
Licence      : GPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Solve the Poisson equation with the TATelliptic framework.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>solver</td>
<td>"TATJacobi"</td>
<td>Name of TATelliptic solver that should be used</td>
<td>.* :: "must be an activated TATelliptic solver"<em>OR</em></td>
</tr>
<tr>
<td>options</td>
<td>""</td>
<td>Options for the solver</td>
<td>.* :: "no restriction"<em>OR</em></td>
</tr>
<tr>
<td>radius</td>
<td>1.0</td>
<td>Radius of uniformly charged sphere</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>charge</td>
<td>1.0</td>
<td>Charge of uniformly charged sphere</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="wavemol">WaveMoL</h3>
<p>Cactus Code Thorn WaveMoL
Author(s)    : Ian Hawke
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This implements the wave equation in FOSH form for use with the Method
of Lines thorn. Intended as a basic test. </p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>WaveMoL_MaxNumEvolvedVars</td>
<td>5</td>
<td>The maximum number of evolved variables used by WaveMoL</td>
<td>5:5       :: "Just 5: phi and the four derivatives"<em>OR</em></td>
</tr>
<tr>
<td>WaveMoL_MaxNumConstrainedVars</td>
<td>1</td>
<td>The maximum number of constrained variables used by WaveMoL</td>
<td>1:1       :: "The energy"<em>OR</em></td>
</tr>
<tr>
<td>bound</td>
<td>"none"</td>
<td>Type of boundary condition to use</td>
<td>"none"      :: "No boundary condition"<em>OR</em>  "flat"      :: "Flat boundary condition"<em>OR</em>  "radiation" :: "Radiation boundary condition"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="demointerp">DemoInterp</h3>
<p>Cactus Code Thorn DemoInterp
Author(s)    : Thomas Radke
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn demonstrates the use of the Cactus interpolation API.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>interpolation_order</td>
<td>1</td>
<td>Order for interpolation</td>
<td>1:3 :: "Choose between first, second, and third-order"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="helloworldopencl">HelloWorldOpenCL</h3>
<p>Cactus Code Thorn HelloWorldOpenCL
Author(s)    : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;">&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;</a>
Maintainer(s): Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;">&#101;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#112;&#101;&#114;&#105;&#109;&#101;&#116;&#101;&#114;&#105;&#110;&#115;&#116;&#105;&#116;&#117;&#116;&#101;&#46;&#99;&#97;</a>
Licence      : GPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>"Hello, World!" implemented in OpenCL.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="sampleboundary">SampleBoundary</h3>
<p>Cactus Code Thorn SampleBoundary
Author(s)    : Carsten Gundlach
               David Rideout
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides a simple example of how to create and register a
physical boundary condition.  It implements a linear extrapolation
boundary condition in three dimensions.  </p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="fleshinfo">FleshInfo</h3>
<p>Cactus Code Thorn FleshInfo
Author(s)    : Cactus team
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Demonstrates obtaining information about computational infrastructure
from the flesh.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="einsteinbase">EinsteinBase</h2>
<h3 id="admmacros">ADMMacros</h3>
<p>Cactus Code Thorn ADMMacros
Author(s)    : Tom Goodale
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides nothing but a load of macros for other thorns to use</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>spatial_order</td>
<td>2</td>
<td>Order of spatial differencing</td>
<td>2 :: "2<sup>nd</sup> order finite differencing"<em>OR*4 :: "4<sup>th</sup> order finite differencing"*OR</em></td>
</tr>
</tbody>
</table>
<h3 id="coordgauge">CoordGauge</h3>
<p>Cactus Code Thorn CoordGauge
Author(s)    : Tom Goodale
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Base thorn to provide the infrastructure for dynamic gauge selection.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>lapse_list</td>
<td>""</td>
<td>List of allowed lapses to use</td>
<td>".<em>" :: "Any string"*OR</em></td>
</tr>
<tr>
<td>shift_list</td>
<td>""</td>
<td>List of allowed shifts to use</td>
<td>".<em>" :: "Any string"*OR</em></td>
</tr>
<tr>
<td>slicing_verbose</td>
<td>"no"</td>
<td>Print information on current slicing</td>
<td>"yes" :: "print slicing info"<em>OR</em>  "no"  :: "do not print slicing info"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="staticconformal">StaticConformal</h3>
<p>Cactus Code Thorn StaticConformal
Author(s)    : Tom Goodale
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides the variables defining a static conformal factor
which is used to transform the physical metric.  If this thorn is
active and the ADMBase::metric_type parameter is set to
`static conformal' then the ADMBase::g... variables are the
conformal values as opposed to the physical values.</p>
<p>The transformation is</p>
<div>
<div class="MathJax_Preview"> g_{ij}^{\mbox{physical}} = \psi^4 g_{ij}^{\mbox{conformal}} </div>
<script type="math/tex; mode=display"> g_{ij}^{\mbox{physical}} = \psi^4 g_{ij}^{\mbox{conformal}} </script>
</div>
<p>The extrinsic curvature is not transformed.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>conformal_storage</td>
<td>"factor+derivs+2<sup>nd</sup></td>
<td>How much conformal storage do we have ?</td>
<td>"factor"                   :: "Just the conformal factor"<em>OR</em>  "factor+derivs"            :: "Conformal factor plus first derivatives"<em>OR</em>  "factor+derivs+2<sup>nd</sup> derivs" :: "Conformal factor plus first and second derivatives"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="constants">Constants</h3>
<p>Cactus Code Thorn Constants
Author(s)    : Frank Löffler
Maintainer(s): Frank Löffler
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides some constants which are defines.
If you do not find the constant you do want to use, please feel free to
include that.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="tmunubase">TmunuBase</h3>
<p>Cactus Code Thorn TmunuBase
Author(s)    : Erik Schnetter
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides grid functions for the stress-energy tensor.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>stress_energy_storage</td>
<td>no</td>
<td>Should the stress-energy tensor have storage?</td>
<td></td>
</tr>
<tr>
<td>stress_energy_at_RHS</td>
<td>no</td>
<td>Should the stress-energy tensor be calculated for the RHS evaluation?</td>
<td></td>
</tr>
<tr>
<td>support_old_CalcTmunu_mechanism</td>
<td>no</td>
<td>Should the old CalcTmunu.inc mechanism be supported? This is deprecated.</td>
<td></td>
</tr>
<tr>
<td>timelevels</td>
<td>1</td>
<td>Number of time levels</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>prolongation_type</td>
<td>"Lagrange"</td>
<td>The kind of boundary prolongation for the stress-energy tensor</td>
<td>"^Lagrange<span><span class="MathJax_Preview">" :: "standard prolongation (requires several time levels)"*OR*  "^none</span><script type="math/tex">" :: "standard prolongation (requires several time levels)"*OR*  "^none</script></span>"     :: "no prolongation (use this if you do not have enough time levels active)"<em>OR</em>  ""           :: "any other supported prolongation type"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="admbase">ADMBase</h3>
<p>Cactus Code Thorn ADMBase
Author(s)    : Tom Goodale
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides the basic variables used to communicate between
thorns doing General Relativity in the 3+1 formalism.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>initial_data</td>
<td>"Cartesian</td>
<td>Initial metric and extrinsic curvature datasets</td>
<td>"Cartesian Minkowski" :: "Minkowski values in cartesian coordinates"<em>OR</em></td>
</tr>
<tr>
<td>initial_lapse</td>
<td>"one"</td>
<td>Initial lapse value</td>
<td>"one" :: "Uniform lapse"<em>OR</em></td>
</tr>
<tr>
<td>initial_shift</td>
<td>"zero"</td>
<td>Initial shift value</td>
<td>"none" :: "Shift is inactive"<em>OR</em>  "zero" :: "Shift is zero"<em>OR</em></td>
</tr>
<tr>
<td>initial_dtlapse</td>
<td>"none"</td>
<td>Initial dtlapse value</td>
<td>"none"   :: "Dtlapse is inactive"<em>OR</em>  "zero"   :: "Dtlapse is zero"<em>OR</em></td>
</tr>
<tr>
<td>initial_dtshift</td>
<td>"none"</td>
<td>Initial dtshift value</td>
<td>"none"   :: "Dtshift is inactive"<em>OR</em>  "zero"   :: "Dtshift is zero"<em>OR</em></td>
</tr>
<tr>
<td>evolution_method</td>
<td>"static"</td>
<td>The metric an extrinsic curvature evolution method</td>
<td>"none"       :: "The metric and extrinsic curvature are not evolved"<em>OR</em>  "static"     :: "The metric and extrinsic curvature are not evolved"<em>OR</em>  "ID-apply-regrid" :: "The metric and extrinsic curvature are not evolved and initial data is used to fill in new grid points after regridding"<em>OR</em>  "ID-apply-always" :: "The metric and extrinsic curvature are not evolved and initial data is used to fill in new grid points before each step and after grid changes"<em>OR</em></td>
</tr>
<tr>
<td>lapse_evolution_method</td>
<td>"static"</td>
<td>The lapse evolution method</td>
<td>"static"     :: "lapse is not evolved"<em>OR</em>  "ID-apply-regrid" :: "lapse is not evolved and initial data is used to fill in new grid points after regridding"<em>OR</em>  "ID-apply-always" :: "lapse is not evolved and initial data is used to fill in new grid points before each step and after grid changes"<em>OR</em></td>
</tr>
<tr>
<td>shift_evolution_method</td>
<td>"static"</td>
<td>The shift evolution method</td>
<td>"static"     :: "dtlapse is not evolved"<em>OR</em>  "ID-apply-regrid" :: "dtlapse is not evolved and initial data is used to fill in new grid points after regridding"<em>OR</em>  "ID-apply-always" :: "dtlapse is not evolved and initial data is used to fill in new grid points before each step and after grid changes"<em>OR</em></td>
</tr>
<tr>
<td>dtshift_evolution_method</td>
<td>"flat"</td>
<td>The dtshift evolution method</td>
<td>"" :: "must be a registered boundary condition"<em>OR</em></td>
</tr>
<tr>
<td>metric_type</td>
<td>"physical"</td>
<td>The semantics of the metric variables (physical, static conformal, etc)</td>
<td>"physical" :: "metric and extrinsic curvature are the physical ones"<em>OR</em></td>
</tr>
<tr>
<td>lapse_prolongation_type</td>
<td>"Lagrange"</td>
<td>The kind of boundary prolongation for the lapse</td>
<td>"Lagrange" :: "standard prolongation (requires several time levels)"<em>OR</em>  "none"     :: "no prolongation (use this if you do not have enough time levels active)"<em>OR</em></td>
</tr>
<tr>
<td>shift_prolongation_type</td>
<td>"Lagrange"</td>
<td>The kind of boundary prolongation for the shift</td>
<td>"Lagrange" :: "standard prolongation (requires several time levels)"<em>OR</em>  "none"     :: "no prolongation (use this if you do not have enough time levels active)"<em>OR</em></td>
</tr>
<tr>
<td>metric_prolongation_type</td>
<td>"Lagrange"</td>
<td>The kind of boundary prolongation for the metric and extrinsic curvature</td>
<td>"Lagrange" :: "standard prolongation (requires several time levels)"<em>OR</em>  "none"     :: "no prolongation (use this if you do not have enough time levels active)"<em>OR</em></td>
</tr>
<tr>
<td>lapse_timelevels</td>
<td>1</td>
<td>Number of time levels for the lapse</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>shift_timelevels</td>
<td>1</td>
<td>Number of time levels for the shift</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>metric_timelevels</td>
<td>1</td>
<td>Number of time levels for the metric and extrinsic curvature</td>
<td>0:3 :: ""<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="admcoupling">ADMCoupling</h3>
<p>Cactus Code Thorn ADMCoupling
Author(s)    : Ian Hawke
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>The "friend of a friend" thorn to help matter / spacetime coupling. Does nothing itself.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="eos_base">EOS_Base</h3>
<p>Cactus Code Thorn EOS_Base
Author(s)    : Tom Goodale
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides a registration mechanism for various EOS.</p>
<p>These EOS can then be used by hydrodynamical routines.</p>
<p>Usage:</p>
<p>Creation of EOS:</p>
<p>A thorn providing an EOS should register that it does so by creating
an EOS handle with</p>
<p>int EOS_RegisterMethod(const char *name)</p>
<p>which returns a handle by which this EOS is referenced.</p>
<p>This handle can also be obtained at any time by calling</p>
<p>int EOS_Handle(const char *name)</p>
<p>Once the handle is created it can be used to register individual EOS
functions.  There are five of these</p>
<p>EOS_RegisterPressure         (int handle, CCTK_REAL (*func)(CCTK_REAL, CCTK_REAL))</p>
<p>registers a function which returns pressure 
   as a function of rest mass density and specific internal energy</p>
<p>EOS_RegisterSpecificIntEnergy(int handle, CCTK_REAL (*func)(CCTK_REAL, CCTK_REAL))</p>
<p>registers a function which returns specific internal energy<br />
   as a function of rest mass density and pressure</p>
<p>EOS_RegisterRestMassDens     (int handle, CCTK_REAL (*func)(CCTK_REAL, CCTK_REAL))</p>
<p>registers a function which returns rest mass density<br />
   as a function of specific internal energy and pressure</p>
<p>EOS_RegisterDPressByDRho     (int handle, CCTK_REAL (*func)(CCTK_REAL, CCTK_REAL))</p>
<p>registers a function which returns the derivative of pressure by
   rest mass density
   as a function of rest mass density and specific internal energy</p>
<p>EOS_RegisterDPressByDEps     (int handle, CCTK_REAL (*func)(CCTK_REAL, CCTK_REAL))</p>
<p>registers a function which returns the derivative of pressure by
   specific internal energy
   as a function of rest mass density and specific internal energy</p>
<p>Usage from Fortran:</p>
<p>The Fortran usage is the same as the C usage.  If you register a
function from Fortran it is assumed to be a Fortran function.</p>
<p>Use of EOS by Hydrodynamics thorns:</p>
<p>There are five corresponding calling functions:</p>
<p>pressure = EOS_Pressure(handle, rho, eps)
eps      = EOS_SpecificIntEnergy(handle, rho, pressure)
rho      = EOS_RestMassDens(handle, eps, pressure)
dpdrho   = EOS_DPressByDRho(handle, rho, eps)
dpdeps   = EOS_DPressByDEps(handle, rho, eps)</p>
<p>each of these takes a handle as first argument, which should be
retrieved with</p>
<p>handle = EOS_Handle(name)</p>
<p>where 'name' is the name of the EOS.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="hydrobase">HydroBase</h3>
<p>Cactus Code Thorn HydroBase
Author(s)    : Tanja Bode
               Roland Haas
               Frank Löffler
               Erik Schnetter
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn should be the interface between all hydro codes and the
spacetime codes.</p>
<p>For more information see the documentation in the ThornGuide.</p>
<ol>
<li>Publications</li>
</ol>
<p>The variables provided by this thorn are those of the Valencia formulation of GRHD:
@ARTICLE{1997ApJ...476..221B,
   author = {{Banyuls}, F. and {Font}, J.~A. and {Ibanez}, J.<sub>M.</sub>A. and {Marti}, J.<sub>M.</sub>A. and 
    {Miralles}, J.~A.},
    title = "{Numerical <span><span class="MathJax_Preview">\{</span><script type="math/tex">\{</script></span>3+1<span><span class="MathJax_Preview">\}</span><script type="math/tex">\}</script></span> General Relativistic Hydrodynamics: A Local Characteristic Approach}",
  journal = {\apj},
 keywords = {HYDRODYNAMICS, METHODS: NUMERICAL, RELATIVITY, SHOCK WAVES},
     year = 1997,
    month = feb,
   volume = 476,
    pages = {221-+},
      doi = {10.1086/303604},
   adsurl = {<a href="http://adsabs.harvard.edu/abs/1997ApJ...476..221B">http://adsabs.harvard.edu/abs/1997ApJ...476..221B</a>},
  adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}</p>
<p>@ARTICLE{2006ApJ...637..296A,
   author = {{Ant{\'o}n}, L. and {Zanotti}, O. and {Miralles}, J.~A. and 
    {Mart{\'{\i}}}, J.~M. and {Ib{\'a}{~n}ez}, J.~M. and {Font}, J.~A. and 
    {Pons}, J.~A.},
    title = "{Numerical 3+1 General Relativistic Magnetohydrodynamics: A Local Characteristic Approach}",
  journal = {\apj},
   eprint = {arXiv:astro-ph/0506063},
 keywords = {Methods: Numerical, Magnetohydrodynamics: MHD, Relativity},
     year = 2006,
    month = jan,
   volume = 637,
    pages = {296-312},
      doi = {10.1086/498238},
   adsurl = {<a href="http://adsabs.harvard.edu/abs/2006ApJ...637..296A">http://adsabs.harvard.edu/abs/2006ApJ...637..296A</a>},
  adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>initial_hydro</td>
<td>"zero"</td>
<td>The hydro initial data</td>
<td>"zero" :: "hydro variables are set to vacuum (without atmosphere)"<em>OR</em>  "read from file" :: "Read the initial data using the IOUtil file reader.  Note that this only allows you to read the data from a file, it does not actually do it.  You still have to programme the IOUtil file reader accordingly."<em>OR</em></td>
</tr>
<tr>
<td>evolution_method</td>
<td>"none"</td>
<td>The hydro evolution method</td>
<td>"none" :: "hydro variables are not evolved"<em>OR</em></td>
</tr>
<tr>
<td>timelevels</td>
<td>1</td>
<td>Number of time levels in evolution scheme</td>
<td>1:3 :: ""<em>OR</em></td>
</tr>
<tr>
<td>prolongation_type</td>
<td>"ENO"</td>
<td>The prolongation operator used by Carpet for HydroBase variables</td>
<td>"ENO"  :: "Third order ENO operators; only third order is implemented"<em>OR</em>  "WENO" :: "Fifth order WENO operators; only fifth order is implemented"<em>OR</em>  ".<em>"   :: "Anything else"*OR</em></td>
</tr>
<tr>
<td>initial_Y_e</td>
<td>"none"</td>
<td>Initial value for Y_e</td>
<td>"none" :: "inactive"<em>OR</em>  "one"  :: "initially set to one"<em>OR</em>  "read from file" :: "Read the initial data using the IOUtil file reader.  Note that this only allows you to read the data from a file, it does not actually do it.  You still have to programme the IOUtil file reader accordingly."<em>OR</em></td>
</tr>
<tr>
<td>initial_Abar</td>
<td>"none"</td>
<td>Initial value for Abar</td>
<td>"none" :: "inactive"<em>OR</em>  "zero" :: "initially set to zero"<em>OR</em>  "read from file" :: "Read the initial data using the IOUtil file reader.  Note that this only allows you to read the data from a file, it does not actually do it.  You still have to programme the IOUtil file reader accordingly."<em>OR</em></td>
</tr>
<tr>
<td>Y_e_evolution_method</td>
<td>"none"</td>
<td>Evolution method for Y_e</td>
<td>"none" :: "Evolution for Y_e is disabled"<em>OR</em></td>
</tr>
<tr>
<td>Abar_evolution_method</td>
<td>"none"</td>
<td>Evolution method for Abar</td>
<td>"none" :: "Evolution for Abar is disabled"<em>OR</em></td>
</tr>
<tr>
<td>temperature_evolution_method</td>
<td>"none"</td>
<td>Evolution method for temperature</td>
<td>"none" :: "Evolution for temperature is disabled"<em>OR</em></td>
</tr>
<tr>
<td>entropy_evolution_method</td>
<td>"none"</td>
<td>Evolution method for entropy</td>
<td>"none" :: "Evolution for entropy is disabled"<em>OR</em></td>
</tr>
<tr>
<td>initial_Bvec</td>
<td>"none"</td>
<td>Initial value for Bvec</td>
<td>"none" :: "inactive"<em>OR</em>  "zero" :: "initially set to zero"<em>OR</em>  "read from file" :: "Read the initial data using the IOUtil file reader.  Note that this only allows you to read the data from a file, it does not actually do it.  You still have to programme the IOUtil file reader accordingly."<em>OR</em></td>
</tr>
<tr>
<td>initial_Avec</td>
<td>"none"</td>
<td>Initial value for Avec</td>
<td>"none" :: "inactive"<em>OR</em>  "zero" :: "initially set to zero"<em>OR</em>  "read from file" :: "Read the initial data using the IOUtil file reader.  Note that this only allows you to read the data from a file, it does not actually do it.  You still have to programme the IOUtil file reader accordingly."<em>OR</em></td>
</tr>
<tr>
<td>initial_Aphi</td>
<td>"none"</td>
<td>Initial value for Aphi</td>
<td>"none" :: "inactive"<em>OR</em>  "zero" :: "initially set to zero"<em>OR</em>  "read from file" :: "Read the initial data using the IOUtil file reader.  Note that this only allows you to read the data from a file, it does not actually do it.  You still have to programme the IOUtil file reader accordingly."<em>OR</em></td>
</tr>
<tr>
<td>Bvec_evolution_method</td>
<td>"none"</td>
<td>Evolution method for Bvec</td>
<td>"none" :: "Evolution for Bvec is disabled"<em>OR</em></td>
</tr>
<tr>
<td>hydro_excision</td>
<td>0</td>
<td>Turn on of off (default) storage for hydro excision</td>
<td>0:* :: "Anything else than 0 turns hydro_excision on, added to by other thorns"<em>OR</em></td>
</tr>
<tr>
<td>initial_temperature</td>
<td>"none"</td>
<td>Initial value for temperature</td>
<td>"none"  :: "inactive"<em>OR</em>  "zero"  :: "initially set to zero"<em>OR</em>  "read from file" :: "Read the initial data using the IOUtil file reader.  Note that this only allows you to read the data from a file, it does not actually do it.  You still have to programme the IOUtil file reader accordingly."<em>OR</em></td>
</tr>
<tr>
<td>initial_entropy</td>
<td>"none"</td>
<td>Initial value for entropy</td>
<td>"none"  :: "inactive"<em>OR</em>  "zero"  :: "initially set to zero"<em>OR</em>  "read from file" :: "Read the initial data using the IOUtil file reader.  Note that this only allows you to read the data from a file, it does not actually do it.  You still have to programme the IOUtil file reader accordingly."<em>OR</em></td>
</tr>
</tbody>
</table>
<h2 id="wvuthorns">WVUThorns</h2>
<h3 id="id_converter_giraffe">ID_converter_GiRaFFE</h3>
<p>Cactus Code Thorn ID_converter_GiRaFFE
Author(s)    : Zachariah B. Etienne
Note         : Convert HydroBase variables to 
               GiRaFFE-compatible variables. Used 
               for compatibility with HydroBase/ADMBase
               initial data thorns in the Einstein 
               Toolkit.             <br />
Maintainer(s): Zachariah B. Etienne
License      : FreeBSD License, AKA "2-Clause BSD License"</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>GiRaFFE and HydroBase variables are incompatible;
The former uses 3-velocity defined as v<sup>i = u</sup>i/u^0, and
the latter uses the Valencia formalism definition of v^i.</p>
<p>Define the Valencia formalism's definition of v^i to be 
"W^i", and GiRaFFE's definition "v^i"
Then</p>
<p>W<sup>i = (v</sup>i + \beta^i) / (\alpha). (Eq 11 in 
<a href="http://arxiv.org/pdf/1501.07276.pdf">http://arxiv.org/pdf/1501.07276.pdf</a>).</p>
<p>Similarly,</p>
<p>v_i = (\alpha) W^i  - \beta^i</p>
<p>In addition, GiRaFFE needs the A-fields to be 
defined on <em>staggered</em> grids, and HydroBase does not yet
support this option. The staggerings are defined in 
Table 1 of the IllinoisGRMHD code announcement paper:
<a href="http://arxiv.org/pdf/1501.07276.pdf">http://arxiv.org/pdf/1501.07276.pdf</a> (page 15).</p>
<p>The long-term goal should be to deprecate this thorn.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>random_seed</td>
<td>0</td>
<td>Random seed for random, generally roundoff-level perturbation on initial data. Seeds srand(), and rand() is used for the RNG.</td>
<td>0:99999999 :: "Anything unsigned goes."<em>OR</em></td>
</tr>
<tr>
<td>random_pert</td>
<td>0</td>
<td>Random perturbation atop data</td>
<td><em>:</em> :: "Anything goes."<em>OR</em></td>
</tr>
<tr>
<td>pure_hydro_run</td>
<td>"no"</td>
<td>Set the vector potential and corresponding EM gauge quantity to zero</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="shiftedkerrschild">ShiftedKerrSchild</h3>
<p>Cactus Code Thorn ShiftedKerrSchild
Author(s)    : Zach Etienne <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#122;&#97;&#99;&#104;&#101;&#116;&#105;&#101;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#122;&#97;&#99;&#104;&#101;&#116;&#105;&#101;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
             : 
Maintainer(s): Zach Etienne <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#122;&#97;&#99;&#104;&#101;&#116;&#105;&#101;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#122;&#97;&#99;&#104;&#101;&#116;&#105;&#101;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
             : 
License      : 2-clause BSD (a.k.a., "FreeBSD license"). See LICENSE file
             : for full license terms and conditions.</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>To set up Kerr-Schild initial data, with a shifted radial coordinate.
See Appendix of GiRaFFE code announcement paper for full description:
<a href="https://arxiv.org/abs/1704.00599">https://arxiv.org/abs/1704.00599</a></p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>KerrSchild_radial_shift</td>
<td>0.0</td>
<td>Radial shift for Kerr Schild initial data. Actual shift = KerrSchild_radial_shift*BH_mass</td>
<td>0.0:* ::  "Positive"<em>OR</em></td>
</tr>
<tr>
<td>BH_mass</td>
<td>1.0</td>
<td>The mass of the black hole. Let's keep this at 1!</td>
<td>0.0:* ::  "Positive"<em>OR</em></td>
</tr>
<tr>
<td>BH_spin</td>
<td>0.0</td>
<td>The z-axis <em>dimensionless</em> spin of the black hole</td>
<td>-1.0:1.0 ::  "Anything between -1 and +1"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="giraffefood">GiRaFFEfood</h3>
<p>Cactus Code Thorn GiRaFFEFood
Author(s)    : Zach Etienne <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#122;&#97;&#99;&#104;&#101;&#116;&#105;&#101;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#122;&#97;&#99;&#104;&#101;&#116;&#105;&#101;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
             : Mew-Bing Wan <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#98;&#119;&#97;&#110;&#55;&#56;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#109;&#98;&#119;&#97;&#110;&#55;&#56;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
             : Maria Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Zach Etienne <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#122;&#97;&#99;&#104;&#101;&#116;&#105;&#101;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#122;&#97;&#99;&#104;&#101;&#116;&#105;&#101;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
             : Mew-Bing Wan <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#98;&#119;&#97;&#110;&#55;&#56;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#109;&#98;&#119;&#97;&#110;&#55;&#56;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
             : Maria Babiuc <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;">&#98;&#97;&#98;&#105;&#117;&#99;&#64;&#109;&#97;&#114;&#115;&#104;&#97;&#108;&#108;&#46;&#101;&#100;&#117;</a>
License      : GNU General Public License, version 2 or higher. See GPLv2
             : for GPL version 2.0 license.</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>"GiRaFFEfood provides food for the GiRaFFE." 
I.e., it is an initial data and analysis thorn for all
code validation tests performed in the GiRaFFE code
announcement paper: <a href="https://arxiv.org/abs/1704.00599">https://arxiv.org/abs/1704.00599</a></p>
<ol>
<li>Usage</li>
</ol>
<p>a) Add this thorn, along with GiRaFFE, ShiftedKerrSchild, etc.
   to  your ThornList
b) Compile the Einstein Toolkit (ET), generating ET executable
c) Run the ET executable, reading in one of the parameter files
   in the par/ directory.</p>
<p>Here are the tests included in this thorn, and the corresponding
   parameter files:</p>
<p>1D tests in flat spacetime:
1) Fast Wave:              GiRaFFEfood_1D_FastWave.par
2) Alfven Wave:            GiRaFFEfood_1D_AlfvenWave.par
3) Degenerate Alfven Wave: GiRaFFEfood_1D_DegenAlfvenWave.par
4) Three Waves:            GiRaFFEfood_1D_ThreeWave.par
5) FFE Breakdown:          GiRaFFEfood_1D_FFEBreakdown.par</p>
<p>3D test in flat spacetime:
1) Aligned Rotator: GiRaFFEfood_AlignedRotator.par</p>
<p>3D tests in curved spacetime (black hole in Shifted Kerr-Schild coords):
1) Split Monopole:       GiRaFFEfood_SplitMonopole.par
2a) Exact Wald: Low-Res: GiRaFFEfood_ExactWald_LowRes.par
2b) Exact Wald: Med-Res: GiRaFFEfood_ExactWald_MedRes.par
2c) Exact Wald: Hig-Res: GiRaFFEfood_ExactWald_HigRes.par
3) Magnetospheric Wald:  GiRaFFEfood_MagnetoWald.par</p>
<p>ShiftedKerrSchild code AHFinderDirect validation thorn:
   (Use this to confirm that BH spin and radius are consistent
    with injected spin &amp; radius.)
1) GiRaFFEfood_ShiftedKerrSchild-AHFinderValidation.par</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>test_case</td>
<td>"FastWave"</td>
<td>Select the test case to be set as initial condition</td>
<td>"FastWave"        :: "Fast 1D force free wave travelling in Minkowski background"<em>OR</em>  "AlfvenWave"      :: "Alfven 2D force free wave" <em>OR</em>  "DegenAlfvenWave" :: "Degenerate Alfven 2D force free wave" <em>OR</em>  "ThreeAlfvenWave" :: "Three Alfven 2D force free waves"<em>OR</em>  "FFEBreakdown"    :: "Force free breakdown 2D test"<em>OR</em>  "SplitMonopole"   :: "Bandford-Znajek Split Monopole Test"<em>OR</em>  "ExactWald"       :: "Exact Wald Electrovacuum Solution"<em>OR</em>  "MagnetoWald"    :: "Magnetic Wald Force Free Solution"<em>OR</em>  "AlignedRotator"  :: "Aligned Rotator Solution"<em>OR</em></td>
</tr>
<tr>
<td>wave_speed</td>
<td>-0.5</td>
<td>What is the wave speed relative to the grid frame?</td>
<td>-1.0:1.0 :: "Anything between -1 and +1"<em>OR</em></td>
</tr>
<tr>
<td>split_C</td>
<td>1.0</td>
<td>The constant for the split monopole solution</td>
<td><em>:</em> ::  "Anything?"<em>OR</em></td>
</tr>
<tr>
<td>Wald_B0</td>
<td>1.0</td>
<td>The constant for the exact Wald solution</td>
<td><em>:</em> ::  "Anything?"<em>OR</em></td>
</tr>
<tr>
<td>drop_fr_SplitM</td>
<td>"yes"</td>
<td>Should we drop f&reg; and f'&reg; for the Split Monopole solution?</td>
<td></td>
</tr>
<tr>
<td>Compute_Exact_Every</td>
<td>1</td>
<td>How often do we compute difference between exact and numerical (delAi quantities)?</td>
<td>-1:* :: "-1 = disabled"<em>OR</em></td>
</tr>
<tr>
<td>B_p_aligned_rotator</td>
<td>1e-5</td>
<td>The magnitude of the poloidal magnetic field in the aligned rotator test.</td>
<td><em>:</em> :: "any real"<em>OR</em></td>
</tr>
<tr>
<td>Omega_aligned_rotator</td>
<td>1e3</td>
<td>The angular velocity for the aligned rotator solution test.</td>
<td><em>:0) :: "any negative value"*OR</em>  (0:* :: "any positive value"<em>OR</em></td>
</tr>
<tr>
<td>R_NS_aligned_rotator</td>
<td></td>
<td>The radius of the so-called neutron star (NS) set by hand for the aligned rotator solution test.</td>
<td>-1.  :: "disable the conservative-to-primitive solver modification"<em>OR</em>  (0:* :: "any positive value"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="giraffe">GiRaFFE</h3>
<p>Cactus Code Thorn GiRaFFE
Author(s)    : Maria Babiuc, Zachariah B. Etienne, Mew-Bing Wan
Note         : GiRaFFE is based on IllinoisGRMHD, and uses the algorithm of
               the Illinois Numerical Relativity group for incorporating
               force-free electrodynamics. 
Maintainer(s): Zachariah B. Etienne
License      : GNU General Public License, version 2 or higher.</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>GiRaFFE solves the equations of General Relativistic 
Force-Free Electrodynamics (GRFFE) using a high-resolution shock capturing scheme.
It is based on IllinoisGRMHD, which is a rewrite of the Illinois Numerical Relativity 
(ILNR) group's GRMHD code.</p>
<p>GiRaFFE is particularly good at modeling black hole magnetospheres. Its 
conservative-to-primitive solver has also been modified to check the 
physicality of conservative variables prior to primitive inversion, and move them 
into the physical range if they become unphysical.</p>
<p>Currently GiRaFFE consists of
1) the Piecewise Parabolic Method (PPM) for reconstruction, 
2) the Harten, Lax, van Leer (HLL/HLLE) approximate Riemann solver, and
3) a modified HARM Conservative-to-Primitive solver. </p>
<p>GiRaFFE evolves the vector potential A_{\mu} (on staggered grids) 
instead of the magnetic fields (B^i) directly, to guarantee that the 
magnetic fields will remain divergenceless even at AMR boundaries. On 
uniform resolution grids, this vector potential formulation produces 
results equivalent to those generated using the standard, staggered 
flux-CT scheme. This scheme is based on that of Del Zanna (2003, see
below OPTIONAL CITATION #1).</p>
<p>REQUIRED CITATIONS:</p>
<p>1) GiRaFFE code announcement paper: <a href="https://arxiv.org/abs/1704.00599">https://arxiv.org/abs/1704.00599</a></p>
<p>2) IllinoisGRMHD code announcement paper: 
Class. Quantum Grav. 32 (2015) 175009, (<a href="https://arxiv.org/abs/1501.07276">https://arxiv.org/abs/1501.07276</a>)</p>
<p>OPTIONAL CITATIONS:
1) Del Zanna, Bucciantini &amp; Londrillo A&amp;A 400, 397 (2003), Eq. (44)</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>current_sheet_null_v</td>
<td>"no"</td>
<td>Shall we null the velocity normal to the current sheet?</td>
<td></td>
</tr>
<tr>
<td>GAMMA_SPEED_LIMIT</td>
<td>2000.0</td>
<td>Maximum relativistic gamma factor. Note the default is much higher than IllinoisGRMHD. (GRFFE can handle higher Lorentz factors)</td>
<td>1:* :: "Positive &gt; 1, though you'll likely have troubles far above 2000."<em>OR</em></td>
</tr>
<tr>
<td>Velocity_BC</td>
<td>"outflow"</td>
<td>Chosen fluid velocity boundary condition</td>
<td>"outflow"        :: "Outflow boundary conditions"<em>OR</em>  "copy"           :: "Copy data from nearest boundary point"<em>OR</em>  "frozen"         :: "Frozen boundaries"<em>OR</em></td>
</tr>
<tr>
<td>EM_BC</td>
<td>"copy"</td>
<td>EM field boundary condition</td>
<td>"copy"           :: "Copy data from nearest boundary point"<em>OR</em>  "frozen"         :: "Frozen boundaries"<em>OR</em></td>
</tr>
<tr>
<td>Symmetry</td>
<td>"none"</td>
<td>Currently only no symmetry supported, though work has begun in adding equatorial-symmetry support. FIXME: Extend ET symmetry interface to support symmetries on staggered gridfunctions</td>
<td>"none"       :: "no symmetry, full 3d domain"<em>OR</em></td>
</tr>
<tr>
<td>Sym_Bz</td>
<td>1.0</td>
<td>In-progress equatorial symmetry support: Symmetry parameter across z axis for magnetic fields = &plusmn; 1</td>
<td>-1.0:1.0 :: "Set to +1 or -1."<em>OR</em></td>
</tr>
<tr>
<td>min_radius_inside_of_which_conserv_to_prims_FFE_and_FFE_evolution_is_DISABLED</td>
<td></td>
<td>As parameter suggests, this is the minimum radius inside of which the conservatives-to-primitives solver is disabled. In the Aligned Rotator test, this should be set equal to R_NS_aligned_rotator.</td>
<td>-1.  :: "disable the conservative-to-primitive solver modification"<em>OR</em>  (0:* :: "any positive value"<em>OR</em></td>
</tr>
<tr>
<td>damp_lorenz</td>
<td>0.0</td>
<td>Damping factor for the generalized Lorenz gauge. Has units of 1/length = 1/M. Typically set this parameter to 1.5/(maximum Delta t on AMR grids).</td>
<td><em>:</em> :: "any real"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="convert_to_hydrobase">Convert_to_HydroBase</h3>
<p>Cactus Code Thorn Convert_to_HydroBase
Author(s)    : Zachariah B. Etienne
Note         : Convert IllinoisGRMHD-compatible variables 
               to HydroBase-compatible variables. Used 
               for compatibility with HydroBase/ADMBase
               analysis thorns in the Einstein Toolkit.             <br />
Maintainer(s): Zachariah B. Etienne
License      : FreeBSD License, AKA "2-Clause BSD License"</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>IllinoisGRMHD and HydroBase variables are incompatible;
The former uses 3-velocity defined as v<sup>i = u</sup>i/u^0, and
the latter uses the Valencia formalism definition of v^i.</p>
<p>Define the Valencia formalism's definition of v^i to be 
"W^i", and IllinoisGRMHD's definition "v^i"
Then</p>
<p>W<sup>i = (v</sup>i + \beta^i) / (\alpha). (Eq 11 in 
<a href="http://arxiv.org/pdf/1501.07276.pdf">http://arxiv.org/pdf/1501.07276.pdf</a>).</p>
<p>Similarly,</p>
<p>v_i = (\alpha) W^i  - \beta^i</p>
<p>In addition, IllinoisGRMHD needs the A-fields to be 
defined on <em>staggered</em> grids, and HydroBase does not yet
support this option. The staggerings are defined in 
Table 1 of the IllinoisGRMHD code announcement paper:
<a href="http://arxiv.org/pdf/1501.07276.pdf">http://arxiv.org/pdf/1501.07276.pdf</a> (page 15).</p>
<p>The long-term goal should be to deprecate this thorn.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>Convert_to_HydroBase_every</td>
<td>0</td>
<td>How often to convert IllinoisGRMHD primitive variables to HydroBase (Valencia formulation) primitive variables? Needed for some ET-based diagnostics. NOT needed for pure IllinoisGRMHD runs.</td>
<td>0:* :: "zero (disable) or positive (every N iterations)"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="illinoisgrmhd">IllinoisGRMHD</h3>
<p>Cactus Code Thorn IllinoisGRMHD
Author(s)    : Zachariah B. Etienne
Note         : IllinoisGRMHD is based on the GRMHD code of the
               Illinois Numerical Relativity group, written by Matt Duez, Yuk 
               Tung Liu, and Branson Stephens (original version), and then 
               developed primarily by Zachariah Etienne, Yuk Tung Liu, 
               and Vasileios Paschalidis. 
Maintainer(s): Zachariah B. Etienne
License      : GPLv2 for HARM Conservative-to-Primitive solver (src/harm_*)
               GPLv2+ for all other code</p>
<hr />
<p>==========
1. Purpose
==========</p>
<p>IllinoisGRMHD solves the equations of General Relativistic 
MagnetoHydroDynamics (GRMHD) using a high-resolution shock capturing scheme.
It is a rewrite of the Illinois Numerical Relativity (ILNR) group's GRMHD 
code, and generates results that agree to roundoff error with that original
code. Its feature set coincides with the features of the ILNR group's 
recent code (ca. 2009--2014), which was used in their modeling of the
following systems:
1) Magnetized circumbinary disk accretion onto binary black holes
2) Magnetized black hole--neutron star mergers
3) Magnetized Bondi flow, Bondi-Hoyle-Littleton accretion
4) White dwarf--neutron star mergers</p>
<p>IllinoisGRMHD is particularly good at modeling GRMHD flows into black holes
without the need for excision. Its HARM-based conservative-to-primitive solver 
has also been modified to check the physicality of conservative variables 
prior to primitive inversion, and move them into the physical range if they 
become unphysical.</p>
<p>Currently IllinoisGRMHD consists of
1) the Piecewise Parabolic Method (PPM) for reconstruction, 
2) the Harten, Lax, van Leer (HLL/HLLE) approximate Riemann solver, and
3) a modified HARM Conservative-to-Primitive solver. </p>
<p>IllinoisGRMHD evolves the vector potential A_{\mu} (on staggered grids) 
instead of the magnetic fields (B^i) directly, to guarantee that the 
magnetic fields will remain divergenceless even at AMR boundaries. On 
uniform resolution grids, this vector potential formulation produces 
results equivalent to those generated using the standard, staggered 
flux-CT scheme. This scheme is based on that of Del Zanna (2003, see
below OPTIONAL CITATION #1).</p>
<p>=======================================================
2. Instructions for committing patches to IllinoisGRMHD
=======================================================</p>
<p>Before committing a patch to IllinoisGRMHD that might <em>conceivably</em> 
affect IllinoisGRMHD's roundoff-level agreement with previous versions,
you must first perform a correctness test. Here are the instructions:</p>
<p>Definitions:
a) EXE/ is the folder containing the executable built from your new,
patched version of IllinoisGRMHD
b) TEST/ is arrangements/WVUThorns/IllinoisGRMHD/test/
c) ./ is arrangements/WVUThorns/IllinoisGRMHD/</p>
<p>Instructions:
1) Copy TEST/magnetizedTOV.par and ./code_validation.txt to EXE/.</p>
<p>2) Go to the EXE/ directory</p>
<p>3) Edit magnetizedTOV.par, replacing the line
cactus::cctk_itlast = 2
with
cactus::cctk_itlast = 240</p>
<p>4) Perform the run on at least 8 MPI processes. If your computer has
16 cores, then use the command:
OMP_NUM_THREADS=2 mpirun -n 8 -x OMP_NUM_THREADS ./cactus_[configname] magnetizedTOV.par</p>
<p>5) Make sure the run completes without error. If there are errors, 
you must backtrace what is wrong before committing the patch.</p>
<p>6) The central density is extremely sensitive to beyond-truncation-error
changes, so we'll focus on that quantity exclusively. Parse the output 
file as follows:</p>
<p>awk '{if(NF==3 &amp;&amp; NR%3==0) print $0}' magnetizedTOV/rho_b.maximum.asc &gt; myoutput.txt</p>
<p>7) Next compare the results:</p>
<p>paste code_validation.txt myoutput.txt | awk '{printf("%.3f %.3f\t%e\t%e\n",<span><span class="MathJax_Preview">1,</span><script type="math/tex">1,</script></span>2,sqrt(<span><span class="MathJax_Preview">4^2),sqrt(((</span><script type="math/tex">4^2),sqrt(((</script></span>3-<span><span class="MathJax_Preview">7)/</span><script type="math/tex">7)/</script></span>3)^2));}'</p>
<p>Column definitions:</p>
<p>Column 1: cctk_iteration
Column 2: cctk_time 
Column 3: The relative difference between the trusted version of the 
code and itself, but with a 15<sup>th</sup> significant digit perturbation at t=0.
Column 4: The relative difference between the trusted version of the 
code and your updated code.</p>
<p>If Columns 3 and 4 are within 1.5 orders of magnitude through iteration 240, 
and the relative difference at iteration 240 is 3e-7 or less, then your change 
is accepted. Please push to the git repository.</p>
<p>===================
REQUIRED CITATIONS:
===================</p>
<p>1) IllinoisGRMHD code announcement paper: 
Class. Quantum Grav. 32 (2015) 175009, (<a href="http://arxiv.org/abs/1501.07276">http://arxiv.org/abs/1501.07276</a>)</p>
<p>2) Noble, S. C., Gammie, C. F., McKinney, J. C., \&amp; Del Zanna, L.  2006, 
        Astrophysical Journal, 641, 626.</p>
<p>OPTIONAL CITATIONS:
1) Del Zanna, Bucciantini &amp; Londrillo A&amp;A 400, 397 (2003), Eq. (44)</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"essential+iteration</td>
<td>Determines how much evolution information is output</td>
<td>"no"        :: "Complete silence"<em>OR</em>  "essential" :: "Essential health monitoring of the GRMHD evolution: Information about conservative-to-primitive fixes, etc."<em>OR</em>  "essential+iteration output" :: "Outputs health monitoring information, plus a record of which RK iteration. Very useful for backtracing a crash."<em>OR</em></td>
</tr>
<tr>
<td>GAMMA_SPEED_LIMIT</td>
<td>10.0</td>
<td>Maximum relativistic gamma factor.</td>
<td>1:* :: "Positive &gt; 1, though you'll likely have troubles far above 10."<em>OR</em></td>
</tr>
<tr>
<td>tau_stildefix_enable</td>
<td>0</td>
<td>tau&lt;0 fix in primitive_vars_hybrid2 to reduce number of Font fixes, especially in puncture+matter evolutions</td>
<td># 0:3 :: "zero (disable), one (enable everywhere), or two (enable only where Psi6 &gt; Psi6threshold [i.e., inside the horizon, where B's are set to zero], or three (kludge: set B=0 if tau&lt;0 inside horizon))"<em>OR</em>#</td>
</tr>
<tr>
<td>update_Tmunu</td>
<td>"yes"</td>
<td>Update Tmunu, for RHS of Einstein's equations?</td>
<td></td>
</tr>
<tr>
<td>tau_atm</td>
<td>1e100</td>
<td>Floor value on the energy variable tau (cf. tau_stildefix_enable). Given the variety of systems this code may encounter, there <em>is no reasonable default</em>. Effectively the current (enormous) value should disable the tau_atm floor. Please set this in your initial data thorn, and reset at will during evolutions.</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>rho_b_atm</td>
<td>1e200</td>
<td>Floor value on the baryonic rest mass density rho_b (atmosphere). Given the variety of systems this code may encounter, there <em>is no reasonable default</em>. Your run will die unless you override this default value in your initial data thorn.</td>
<td><em>:</em> :: "Allow for negative values.  This enables us to debug the code and verify if rho_b_atm is properly set."<em>OR</em></td>
</tr>
<tr>
<td>rho_b_max</td>
<td>1e300</td>
<td>Ceiling value on the baryonic rest mass density rho_b. The enormous value effectively disables this ceiling by default. It can be quite useful after a black hole has accreted a lot of mass, leading to enormous densities inside the BH. To enable this trick, set rho_b_max in your initial data thorn! You are welcome to change this parameter mid-run (after restarting from a checkpoint).</td>
<td>0:* :: "Note that you will have problems unless rho_b_atm&lt;rho_b_max"<em>OR</em></td>
</tr>
<tr>
<td>conserv_to_prims_debug</td>
<td>0</td>
<td>0: no, 1: yes</td>
<td>0:1 :: "zero (no) or one (yes)"<em>OR</em></td>
</tr>
<tr>
<td>Psi6threshold</td>
<td>1e100</td>
<td>Where Psi^6 &gt; Psi6threshold, we assume we're inside the horizon in the primitives solver, and certain limits are relaxed or imposed</td>
<td><em>:</em> :: "Can set to anything"<em>OR</em></td>
</tr>
<tr>
<td>neos</td>
<td>1</td>
<td>number of parameters in EOS table. If you want to increase from the default max value, you MUST also set eos_params_arrays1 and eos_params_arrays2 in interface.ccl to be consistent!</td>
<td>1:10 :: "Any integer between 1 and 10"<em>OR</em></td>
</tr>
<tr>
<td>gamma_th</td>
<td>-1</td>
<td>thermal gamma parameter</td>
<td>0:* :: "Physical values"<em>OR</em>-1   :: "forbidden value to make sure it is explicitly set in the parfile"<em>OR</em></td>
</tr>
<tr>
<td>K_poly</td>
<td>1.0</td>
<td>initial polytropic constant</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>Matter_BC</td>
<td>"outflow"</td>
<td>Chosen Matter boundary condition</td>
<td>"outflow" :: "Outflow boundary conditions"<em>OR</em>  "frozen"  :: "Frozen boundaries"<em>OR</em></td>
</tr>
<tr>
<td>EM_BC</td>
<td>"copy"</td>
<td>EM field boundary condition</td>
<td>"copy"    :: "Copy data from nearest boundary point"<em>OR</em>  "frozen"  :: "Frozen boundaries"<em>OR</em></td>
</tr>
<tr>
<td>Symmetry</td>
<td>"none"</td>
<td>Currently only no symmetry supported, though work has begun in adding equatorial-symmetry support. FIXME: Extend ET symmetry interface to support symmetries on staggered gridfunctions</td>
<td>"none"       :: "no symmetry, full 3d domain"<em>OR</em></td>
</tr>
<tr>
<td>Sym_Bz</td>
<td>1.0</td>
<td>In-progress equatorial symmetry support: Symmetry parameter across z axis for magnetic fields = &plusmn; 1</td>
<td>-1.0:1.0 :: "Set to +1 or -1."<em>OR</em></td>
</tr>
<tr>
<td>damp_lorenz</td>
<td>0.0</td>
<td>Damping factor for the generalized Lorenz gauge. Has units of 1/length = 1/M. Typically set this parameter to 1.5/(maximum Delta t on AMR grids).</td>
<td><em>:</em> :: "any real"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="giraffe_to_hydrobase">GiRaFFE_to_HydroBase</h3>
<p>Cactus Code Thorn Convert_GiRaFFE_to_HydroBase
Author(s)    : Zachariah B. Etienne
Note         : Convert GiRaFFE-compatible variables 
               to HydroBase-compatible variables. Used 
               for compatibility with HydroBase/ADMBase
               analysis thorns in the Einstein Toolkit.             <br />
Maintainer(s): Zachariah B. Etienne
License      : FreeBSD License, AKA "2-Clause BSD License"</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>GiRaFFE and HydroBase variables are incompatible;
The former uses 3-velocity defined as v<sup>i = u</sup>i/u^0, and
the latter uses the Valencia formalism definition of v^i.</p>
<p>Define the Valencia formalism's definition of v^i to be 
"W^i", and GiRaFFE's definition "v^i"
Then</p>
<p>W<sup>i = (v</sup>i + \beta^i) / (\alpha). (Eq 11 in 
<a href="http://arxiv.org/pdf/1501.07276.pdf">http://arxiv.org/pdf/1501.07276.pdf</a>).</p>
<p>Similarly,</p>
<p>v_i = (\alpha) W^i  - \beta^i</p>
<p>In addition, GiRaFFE needs the A-fields to be 
defined on <em>staggered</em> grids, and HydroBase does not yet
support this option. The staggerings are defined in 
Table 1 of the IllinoisGRMHD code announcement paper:
<a href="http://arxiv.org/pdf/1501.07276.pdf">http://arxiv.org/pdf/1501.07276.pdf</a> (page 15).</p>
<p>The long-term goal should be to deprecate this thorn.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>Convert_GiRaFFE_to_HydroBase_every</td>
<td>0</td>
<td>How often to convert GiRaFFE primitive variables to HydroBase (Valencia formulation) primitive variables? Needed for some ET-based diagnostics. NOT needed for pure GiRaFFE runs.</td>
<td>0:* :: "zero (disable) or positive (every N iterations)"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="id_converter_ilgrmhd">ID_converter_ILGRMHD</h3>
<p>Cactus Code Thorn ID_conerter_ILGRMHD
Author(s)    : Zachariah B. Etienne
Note         : Convert HydroBase variables to 
               IllinoisGRMHD-compatible variables. Used 
               for compatibility with HydroBase/ADMBase
               initial data thorns in the Einstein 
               Toolkit.             <br />
Maintainer(s): Zachariah B. Etienne
License      : FreeBSD License, AKA "2-Clause BSD License"</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>IllinoisGRMHD and HydroBase variables are incompatible;
The former uses 3-velocity defined as v<sup>i = u</sup>i/u^0, and
the latter uses the Valencia formalism definition of v^i.</p>
<p>Define the Valencia formalism's definition of v^i to be 
"W^i", and IllinoisGRMHD's definition "v^i"
Then</p>
<p>W<sup>i = (v</sup>i + \beta^i) / (\alpha). (Eq 11 in 
<a href="http://arxiv.org/pdf/1501.07276.pdf">http://arxiv.org/pdf/1501.07276.pdf</a>).</p>
<p>Similarly,</p>
<p>v_i = (\alpha) W^i  - \beta^i</p>
<p>In addition, IllinoisGRMHD needs the A-fields to be 
defined on <em>staggered</em> grids, and HydroBase does not yet
support this option. The staggerings are defined in 
Table 1 of the IllinoisGRMHD code announcement paper:
<a href="http://arxiv.org/pdf/1501.07276.pdf">http://arxiv.org/pdf/1501.07276.pdf</a> (page 15).</p>
<p>The long-term goal should be to deprecate this thorn.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>Gamma_Initial</td>
<td>1.3</td>
<td>Single Gamma-law EOS: Gamma</td>
<td>0:* :: "Positive or zero"<em>OR</em></td>
</tr>
<tr>
<td>K_Initial</td>
<td>1.0</td>
<td>Single Gamma-law EOS: K</td>
<td>0:* :: "Positive or zero"<em>OR</em></td>
</tr>
<tr>
<td>random_seed</td>
<td>0</td>
<td>Random seed for random, generally roundoff-level perturbation on initial data. Seeds srand(), and rand() is used for the RNG.</td>
<td>0:99999999 :: "Anything unsigned goes."<em>OR</em></td>
</tr>
<tr>
<td>random_pert</td>
<td>0</td>
<td>Random perturbation atop data</td>
<td><em>:</em> :: "Anything goes."<em>OR</em></td>
</tr>
<tr>
<td>pure_hydro_run</td>
<td>"no"</td>
<td>Set the vector potential and corresponding EM gauge quantity to zero</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="seed_magnetic_fields">Seed_Magnetic_Fields</h3>
<p>Cactus Code Thorn Seed_Magnetic_Fields
Author(s)    : Zachariah B. Etienne
Note         : This thorn is designed to seed magnetic 
               fields into initial data. Generally, these
               magnetic fields are sufficiently weak that
               there is no significant dynamical impact
               initially.
Maintainer(s): Zachariah B. Etienne
License      : FreeBSD License, AKA "2-Clause BSD License"</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Seed magnetic fields into an initial matter configuration.
Currently seeding into TOV stars is supported, according
to the poloidal magnetic field prescription:
A_x = -y*A_b*pow(MAX(P-P_cut,0.0),n_s)
A_y =  x*A_b*pow(MAX(P-P_cut,0.0),n_s)
A_z = 0
Phi = 0</p>
<p>as specified in Appendix B of the IllinoisGRMHD code
announcement paper:
<a href="http://arxiv.org/pdf/1501.07276.pdf">http://arxiv.org/pdf/1501.07276.pdf</a></p>
<p>Note that we must be careful if A_i's are staggered. In this
case, the pressure must be interpolated to the staggered
point, and the values of x and y must also be shifted.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>enable_IllinoisGRMHD_staggered_A_fields</td>
<td>"yes"</td>
<td>Define A fields on an IllinoisGRMHD staggered grid</td>
<td></td>
</tr>
<tr>
<td>Afield_type</td>
<td>"Pressure_prescription"</td>
<td>A-field prescription</td>
<td>"Pressure_prescription"     :: "A_phi propto (P - P_cut)^n_s"<em>OR</em>"Density_prescription"      :: "A_phi propto rho"<em>OR</em></td>
</tr>
<tr>
<td>enable_varpi_squared_multiplication</td>
<td>"yes"</td>
<td>Multiply A_phi by varpi^2?</td>
<td></td>
</tr>
<tr>
<td>A_b</td>
<td>1e-3</td>
<td>Magnetic field strength parameter.</td>
<td><em>:</em> :: "Any real"<em>OR</em></td>
</tr>
<tr>
<td>P_cut</td>
<td>1e-5</td>
<td>Cutoff pressure, below which vector potential is set to zero. Typically set to 4% of the maximum initial pressure.</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>n_s</td>
<td>1.0</td>
<td>Magnetic field strength pressure exponent.</td>
<td><em>:</em> :: "Any real"<em>OR</em></td>
</tr>
<tr>
<td>rho_cut</td>
<td>0.2</td>
<td>Cutoff density, below which vector potential is set to zero. Typically set to 20% of the maximum initial density.</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
</tbody>
</table>
<h2 id="llama">Llama</h2>
<h3 id="coordinates">Coordinates</h3>
<p>Cactus Code Thorn Coordinates
Author(s)    : Denis Pollney
               Christian Reisswig
               Erik Schnetter
               Peter Diener
               Nils Dorband
               many others
Maintainer(s): Denis Pollney, Christian Reisswig
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Llama is a multipatch infrastructure for Cactus.</p>
<p>This thorn provides definition of patch systems and coordinates.</p>
<p>For more information see the documentation in the ThornGuide.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="waveextractl">WaveExtractL</h3>
<p>Cactus Code Thorn WaveExtract
Thorn Author(s)     : Frank Herrmann <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#104;&#101;&#114;&#114;&#109;&#97;&#110;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#104;&#101;&#114;&#114;&#109;&#97;&#110;&#110;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Thorn Maintainer(s) : Christian Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>Does Wave extraction and only wave extraction using the Zerilli formalism.
This thorn was formerly Extract, but that got overloaded with lots of stuff.</p>
<p>NOTE:</p>
<p>This thorn is a modification to the original WaveExtract as found in
AEIDevelopment and has been extended to be OMP parallel and to use
CarpetInterp2.  Some features as working with corotating coordinates
have been removed.</p>
<p>IMPORTANT: The old version in AEIDevelopment/WaveExtract is NOT
           working with general coordinates (especially radial
           stretching)!!  Use this thorn instead!</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>active</td>
<td>"yes"</td>
<td>Should we run at all?</td>
<td></td>
</tr>
<tr>
<td>start_iteration</td>
<td>0</td>
<td>First iteration when we should be called</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>start_time</td>
<td>-1</td>
<td>First time when we should be called</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>calc_when_necessary</td>
<td>no</td>
<td>Start calculation at T = R_detector - 50 and stop after T_merger+Ringdown_margin+R_detector</td>
<td></td>
</tr>
<tr>
<td>ringdown_margin</td>
<td>150.0</td>
<td>The expected length of ringdown. If calc_when_necessary=yes, then T_merger+ringdown_margin+R_detector is the time when calculations are switched off</td>
<td>0:* :: "Any positive number"<em>OR</em></td>
</tr>
<tr>
<td>out_every</td>
<td>1</td>
<td>At which iterations should we be called</td>
<td><em>:</em> :: "negative means set via out_every_det"<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>1</td>
<td>how verbose should the output be?</td>
<td>0:10 :: "higher number means more output"<em>OR</em></td>
</tr>
<tr>
<td>origin_x</td>
<td>0</td>
<td>origin in x direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>origin_y</td>
<td>0</td>
<td>origin in y direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>origin_z</td>
<td>0</td>
<td>origin in z direction</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>mode_type</td>
<td>"all</td>
<td>Which type of mode extraction do we have</td>
<td>"all modes"     :: "Extract all modes up to (l_mode, m_mode)."<em>OR</em>  "specific mode" :: "Select one specific (l_mode, m_mode) mode"<em>OR</em></td>
</tr>
<tr>
<td>l_mode</td>
<td>2</td>
<td>all modes: Up to which l mode to calculate/ spefic mode: which l mode to extract</td>
<td>2:* :: "Positive Please, note that l=0,1 are gauge dependent and not implemented"<em>OR</em></td>
</tr>
<tr>
<td>m_mode</td>
<td>0</td>
<td>all modes: Up to which m mode to calculate/ specific mode: which m mode to extract</td>
<td>0:* :: "Positive Please"<em>OR</em></td>
</tr>
<tr>
<td>maxntheta</td>
<td>100</td>
<td>how many points in theta direction at most</td>
<td>0:* :: "Positive Please - even or odd depends on integration scheme used"<em>OR</em></td>
</tr>
<tr>
<td>maxnphi</td>
<td>100</td>
<td>how many points in phi direction at most</td>
<td>0:* :: "Positive Please - even or odd depends on integration scheme used"<em>OR</em></td>
</tr>
<tr>
<td>subtract_spherical_background</td>
<td>"yes"</td>
<td>Subtract spherical background before calculation of Extraction quantities</td>
<td></td>
</tr>
<tr>
<td>interpolation_operator</td>
<td>"Hermite</td>
<td>What interpolator should be used to interpolate onto the surface</td>
<td>".+" :: "A valid interpolator name, see Thorn AEILocalInterp"<em>OR</em></td>
</tr>
<tr>
<td>interpolation_order</td>
<td>2</td>
<td>interpolation order for projection onto the sphere</td>
<td>1:* :: "Positive Please"<em>OR</em></td>
</tr>
<tr>
<td>interpolation_stencil</td>
<td>4</td>
<td>interpolation stencil, this is needed to work out how far out you can place the detectors. It depends on the interpolator and the interpolation order used.</td>
<td>1:* :: "Positive Please"<em>OR</em></td>
</tr>
<tr>
<td>integration_method</td>
<td>"Gauss"</td>
<td>which method to use for the integration</td>
<td>"Gauss" :: "error is O(1/e^N)"<em>OR</em>  "extended midpoint rule" :: "weight is one for all points, error is O(1/N^2)"<em>OR</em>  "open extended" :: "weight is 23/12,13/12,4/3,2/4,...0,27/12, error O(1/N^4)"<em>OR</em></td>
</tr>
<tr>
<td>maximum_detector_number</td>
<td>9</td>
<td>How many detectors do you want. NOTE: This also fixes the number of detectors in Cauchy mode!</td>
<td>0:100 :: "Positive Please, less than hard limit FIXME"<em>OR</em></td>
</tr>
<tr>
<td>check_rmax</td>
<td>no</td>
<td>Whether to check for rmax or not (must be set to no for Llama</td>
<td></td>
</tr>
<tr>
<td>rsch2_computation</td>
<td>"aerial</td>
<td>How to calculate (Schwarzschild_Radius)^2</td>
<td>"aerial radius" :: "calculate invariant aerial radius: r<sup>2=int(sqrt(gtt*gpp-gtp</sup>2))"<em>OR</em>  "average Schwarzschild metric" :: "assume Schwarzschild coordinates: r^2=int(&frac12; (gtt+gpp/sin^2(theta))"<em>OR</em>  "Schwarzschild gtt" :: "assume Schwarzschild coordinates: r^2=int(gtt)"<em>OR</em>  "Schwarzschild gpp" :: "assume Schwarzschild coordinates: r<sup>2=int(gpp/sin</sup>2(theta))"<em>OR</em></td>
</tr>
<tr>
<td>drsch_dri_computation</td>
<td>"average</td>
<td>How to calculate dr_Schwarzschild/dr_isotropic</td>
<td>"average dr_gtt dr_gpp" :: "average using drsch_dri=int(&frac12;(dr_gtt+dr_gpp/sin^2(theta)))"<em>OR</em>  "dr_gtt" :: "drsch_dri=int(dr_gtt)"<em>OR</em>  "dr_gpp" :: "drsch_dri=int(dr_gpp/sin^2(theta))"<em>OR</em></td>
</tr>
<tr>
<td>detection_mode</td>
<td>"specific</td>
<td>Give Specific locations or let the code place the detectors</td>
<td>"Cauchy extraction"  :: "a lot of detectors in some specified range"<em>OR</em>  "specific detectors" :: "give some values"<em>OR</em></td>
</tr>
<tr>
<td>Cauchy_radius_start_coord</td>
<td>-2</td>
<td>where to start Cauchy line in coordinates</td>
<td>-2:* :: "-2 means deactive (ie use percentage), -1 means start from first grid point"<em>OR</em></td>
</tr>
<tr>
<td>Cauchy_radius_end_coord</td>
<td>-2</td>
<td>where to end Cauchy line in coordinates</td>
<td>-2:* :: "-2 means deactive (ie use percentage), -1 means go up to maximum"<em>OR</em></td>
</tr>
<tr>
<td>Cauchy_radius_start_factor</td>
<td>0</td>
<td>where to start Cauchy line as factor of grid size</td>
<td>-1:1 :: "-1 means deactive (ie use coordinate), 0 means first grid point"<em>OR</em></td>
</tr>
<tr>
<td>Cauchy_radius_end_factor</td>
<td>1</td>
<td>where to end Cauchy line as factor of grid size</td>
<td>-1:1 :: "-1 means deactive (ie use coordinate), 1 means go up to maximum"<em>OR</em></td>
</tr>
<tr>
<td>Cauchy_radius_dr</td>
<td>-1</td>
<td>seperation of 2 detectors for the extraction</td>
<td>-1:* :: "-1 means: let the code figure it out"<em>OR</em></td>
</tr>
<tr>
<td>cauchy_radius_extreme</td>
<td>0</td>
<td>use min. radius along axis, dr=dx</td>
<td></td>
</tr>
<tr>
<td>Cauchy_time_ID</td>
<td>0</td>
<td>compute initial data (ID) for dt_Zerilli?</td>
<td></td>
</tr>
<tr>
<td>cartoon</td>
<td>"no"</td>
<td>use cartoon</td>
<td></td>
</tr>
<tr>
<td>cartoon_grid_acc</td>
<td>1e-2</td>
<td>accuracy to use for dx=dy=dz check</td>
<td>0:: ""<em>OR</em></td>
</tr>
<tr>
<td>observers</td>
<td>"no"</td>
<td>do we use the observer thorn</td>
<td></td>
</tr>
<tr>
<td>rotation_omega</td>
<td>0.0</td>
<td>omega from driftcorrect</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>corotate</td>
<td>"no"</td>
<td>do we corotate? give omega if so</td>
<td></td>
</tr>
<tr>
<td>phicorotate</td>
<td>"no"</td>
<td>undo corotation on phi itself</td>
<td></td>
</tr>
<tr>
<td>corotate3d</td>
<td>"no"</td>
<td>do we corotate in 3D (easy slow way)? give omega if so</td>
<td></td>
</tr>
<tr>
<td>switch_output_format</td>
<td>10</td>
<td>How many output files do you suffer in your directory, when you have more detectors than this number, the file format is switched</td>
<td>1:* :: "positive"<em>OR</em></td>
</tr>
<tr>
<td>out_dir</td>
<td>""</td>
<td>Output directory for Extract's files, overrides IO::out_dir</td>
<td>".+" :: "A valid directory name"<em>OR</em>  "^$" :: "An empty string to choose the default from IO::out_dir"<em>OR</em></td>
</tr>
<tr>
<td>out_style</td>
<td>"gnuplot"</td>
<td>Which style for Scalar output</td>
<td>"gnuplot" :: "1D output readable by gnuplot"<em>OR</em>  "xgraph"  :: "1D output readable by xgraph"<em>OR</em></td>
</tr>
<tr>
<td>out_format</td>
<td>".13f"</td>
<td>Which format for Scalar floating-point number output</td>
<td>^(.[1]?[0-9])?[EGefg]$ :: "output with given precision in exponential / floating point notation"<em>OR</em></td>
</tr>
<tr>
<td>write_timer_info</td>
<td>"no"</td>
<td>write timing information to stdout</td>
<td></td>
</tr>
<tr>
<td>use_spherical_surface</td>
<td>"no"</td>
<td>use spherical surface thorn provided spheres</td>
<td></td>
</tr>
<tr>
<td>make_interpolator_warnings_fatal</td>
<td>"no"</td>
<td>Report interpolator warnings as level-0 error messages (and abort the run) ?</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="admderivatives">ADMDerivatives</h3>
<p>Cactus Code Thorn ADMDerivatives
Author(s)    : Christian Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Maintainer(s): Christian Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Licence      : GNU</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn calculates and stores derivatives of the ADMBase variables.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>store_radial_derivatives</td>
<td>yes</td>
<td>Switch calculation of radial derivatives of ADM lapse, shift, 3-metric on/off</td>
<td></td>
</tr>
<tr>
<td>store_cartesian_derivatives</td>
<td>no</td>
<td>Switch calculation of cartesian derivatives of ADM lapse, shift, 3-metric on/off</td>
<td></td>
</tr>
<tr>
<td>store_time_derivatives</td>
<td>yes</td>
<td>Switch calculation of time derivatives of ADM lapse, shift, 3-metric on/off</td>
<td></td>
</tr>
<tr>
<td>spatial_deriv_order</td>
<td>-1</td>
<td>Order of spatial derivatives</td>
<td>-1   :: "Use whatever is specified by SummationByParts"<em>OR</em>  2:8  :: "Use this order"<em>OR</em></td>
</tr>
<tr>
<td>timelevels</td>
<td>1</td>
<td>Number of timelevels for all variables</td>
<td>1 :: "Only one active level"<em>OR</em>  3 :: "Useful for time interpolation"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="globalderivative">GlobalDerivative</h3>
<p>CVS info   : <span><span class="MathJax_Preview">Header</span><script type="math/tex">Header</script></span></p>
<p>Cactus Code Thorn GlobalDerivative
Thorn Author(s)     : Christian Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Thorn Maintainer(s) : Christian Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>This thorn is ment to provide derivative operators in a global coordinate frame
for variables that are defined on local grid coordinates.</p>
<p>\hat{partial_i} = J^j_i \partial_j</p>
<p>It can also apply dissipation in the same way.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>fd_order_on_non_Cart_maps</td>
<td>-1</td>
<td>Order of accuracy of spatial derivatives on non-Cartesian patches.</td>
<td>-1   :: "use same FD order everywhere"<em>OR</em>   2:* :: "use different FD order on non-Cartesian patches"<em>OR</em></td>
</tr>
<tr>
<td>use_dissipation</td>
<td>no</td>
<td>Use global dissipation</td>
<td></td>
</tr>
<tr>
<td>force_diss_order</td>
<td>-1</td>
<td>Force this order of accuracy for dissipation operator</td>
<td>-1  :: "Use default as specified in SBP::order"<em>OR</em>  2:8 :: "2<sup>nd</sup>, 4<sup>th</sup>, 6<sup>th</sup> and 8<sup>th</sup> order"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="llamawavetoy">LlamaWaveToy</h3>
<p>Cactus Code Thorn LlamaWaveToy
Thorn Author(s)     : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Thorn Maintainer(s) : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>A solver for the scalar wave equation on a non-trivial, static
background.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>rhsbound</td>
<td>"none"</td>
<td>Boundary condition during RHS evaluation</td>
<td>".<em>" :: "any registered boundary condition"*OR</em></td>
</tr>
<tr>
<td>bound</td>
<td>"static"</td>
<td>Boundary condition</td>
<td>".<em>" :: "any registered boundary condition"*OR</em></td>
</tr>
<tr>
<td>outer_penalty_bound</td>
<td>"zero"</td>
<td>outer penalty boundary</td>
<td>"zero"     :: "set all characteristics to zero"<em>OR</em>  "solution" :: "use the same analytic solution as for the initial data"<em>OR</em></td>
</tr>
<tr>
<td>outer_bound</td>
<td>"solution"</td>
<td>outer boundary</td>
<td>"zero"      :: "set all characteristics to zero"<em>OR</em>  "solution"  :: "use the same analytic solution as for the initial data"<em>OR</em>  "dirichlet" :: "set all fields to zero"<em>OR</em>  "radiative" :: "radiative boundary"<em>OR</em>  "none"      :: "no boundary condition"<em>OR</em></td>
</tr>
<tr>
<td>metric</td>
<td>"Minkowski"</td>
<td>Global metric</td>
<td>"Minkowski"   :: "Minkowski"<em>OR</em>  "Kerr-Schild" :: "Kerr-Schild"<em>OR</em>  "Kerr" :: "Kerr Black Hole"<em>OR</em></td>
</tr>
<tr>
<td>mass</td>
<td>1.0</td>
<td>Mass M</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>spin</td>
<td>0.0</td>
<td>Spin a=J/M^2</td>
<td>-1:+1 :: ""<em>OR</em></td>
</tr>
<tr>
<td>lapse</td>
<td>1.0</td>
<td>Lapse function multiplier</td>
<td><em>:</em> :: "must not be zero"<em>OR</em></td>
</tr>
<tr>
<td>shift_omega</td>
<td>0.0</td>
<td>Rotational shift vector addition about z axis</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>initial_data</td>
<td>"plane"</td>
<td>Type of initial data</td>
<td>"linear"             :: "x and y coordinates"<em>OR</em>  "plane"              :: "Plane wave"<em>OR</em>  "Gaussian"           :: "Gaussian wave packet"<em>OR</em>  "GaussianNonLinear"  :: "Gaussian wave packet for the non-linear RHS"<em>OR</em>  "GeneralMultipole"   :: "Multipole with arbitrary l and m"<em>OR</em>  "multipole"          :: "L=1 initial data, Gaussian in r"<em>OR</em>  "multipole l=1, m=0" :: "L=1 m=0 initial data, Gaussian in r, u=0"<em>OR</em>  "multipole l=1, m=1" :: "L=1 m=1 initial data, Gaussian in r, u=0"<em>OR</em>  "multipole l=1, m=-1" :: "L=1 m=-1 initial data, Gaussian in r, u=0"<em>OR</em>  "multipole l=2"      :: "L=2 initial data, Gaussian in r"<em>OR</em>  "multipole l=2, u=0" :: "L=2 initial data, Gaussian in r, u=0"<em>OR</em>  "multipole l=2, m=1" :: "L=2 m=1 initial data, Gaussian in r, u=0"<em>OR</em>  "multipole l=2, m=-1" :: "L=2 m=-1 initial data, Gaussian in r, u=0"<em>OR</em>  "multipole l=2, m=2" :: "L=2 m=2 initial data, Gaussian in r, u=0"<em>OR</em>  "multipole l=2, m=-2" :: "L=2 m=-2 initial data, Gaussian in r, u=0"<em>OR</em>  "multipole l=2, m=-2" :: "L=2 m=-2 initial data, Gaussian in r, u=0"<em>OR</em>  "multipole l=4, m=0" :: "L=4 m=0 initial data, Gaussian in r, u=0"<em>OR</em>  "multipole l=4, m=1" :: "L=4 m=1 initial data, Gaussian in r, u=0"<em>OR</em>  "multipole l=4, m=-1" :: "L=4 m=-1 initial data, Gaussian in r, u=0"<em>OR</em>  "multipole l=4, m=2" :: "L=4 m=-2 initial data, Gaussian in r, u=0"<em>OR</em>  "multipole l=4, m=-2" :: "L=4 m=-2 initial data, Gaussian in r, u=0"<em>OR</em>  "multipole l=4, m=3" :: "L=4 m=3 initial data, Gaussian in r, u=0"<em>OR</em>  "multipole l=4, m=-3" :: "L=4 m=-3 initial data, Gaussian in r, u=0"<em>OR</em>  "multipole l=4, m=4" :: "L=4 m=4 initial data, Gaussian in r, u=0"<em>OR</em>  "multipole l=4, m=-4" :: "L=4 m=-4 initial data, Gaussian in r, u=0"<em>OR</em>  "noise"              :: "Random noise"<em>OR</em>  "debug"              :: "number of current patch and grid point index"<em>OR</em></td>
</tr>
<tr>
<td>initial_data_analytic_derivatives</td>
<td>"no"</td>
<td>Calculate spatial derivatives of the initial data analytically?</td>
<td></td>
</tr>
<tr>
<td>eps</td>
<td>1.0e-10</td>
<td>A small number</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>amplitude</td>
<td>1.0</td>
<td>Amplitude</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>width</td>
<td>1.0</td>
<td>Width of the Gaussian</td>
<td>(0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>radius</td>
<td>0.0</td>
<td>Radius of the Gaussian</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>multipole_l</td>
<td>2</td>
<td>For GeneralMultipole initial data: degree of spherical harmonic function</td>
<td>0:* :: "A positive integer"<em>OR</em></td>
</tr>
<tr>
<td>multipole_m</td>
<td>2</td>
<td>For GeneralMultipole initial data: order of spherical harmonic function</td>
<td><em>:</em> :: "An integer -l&lt;=m&lt;=l"<em>OR</em></td>
</tr>
<tr>
<td>multipole_s</td>
<td>0</td>
<td>For GeneralMultipole initial data: spin weight spherical harmonic function</td>
<td><em>:</em> :: "A positive integer"<em>OR</em></td>
</tr>
<tr>
<td>time_offset</td>
<td>0.0</td>
<td>Time offset</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>epsx</td>
<td>0.0</td>
<td>eps in x-direction of the non-linear Gaussian</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>epsy</td>
<td>0.0</td>
<td>eps in y-direction of the non-linear Gaussian</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>RNL</td>
<td>0.0</td>
<td>How fat the non-linear Gaussian is (r-R)</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>ANL</td>
<td>0.0</td>
<td>Amplitude of the non-linear Gaussian</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>deltaNL</td>
<td>0.0</td>
<td>sigma of the non-linear Gaussian</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>muNL</td>
<td>0.0</td>
<td>Speed of the non-linear Gaussian</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>omeNL</td>
<td>0.0</td>
<td>Omega of the non-linear Gaussian</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>formulation</td>
<td>"dt"</td>
<td>Formulation of the wave equation</td>
<td>#   "dt" :: "rho = d_t u"<em>OR</em>#</td>
</tr>
<tr>
<td>shift_interpolation_type</td>
<td>"shift"</td>
<td>Setting for the interpolating vector field b^i (only used for the db formulation)</td>
<td>"shift" :: "Set b<sup>i = beta</sup>i (corresponds to d0 formulation)"<em>OR</em>  "zero"  :: "Set b^i = 0 (corresponds to dk formulation)"<em>OR</em></td>
</tr>
<tr>
<td>nonlinearrhs</td>
<td>"no"</td>
<td>Add a non-linear term to the RHS?</td>
<td></td>
</tr>
<tr>
<td>powerrhs</td>
<td>5.0</td>
<td>Exponent in the non-linear RHS term</td>
<td>3.0:13.0 :: ""<em>OR</em></td>
</tr>
<tr>
<td>compute_second_derivative_from_first_derivative</td>
<td>"no"</td>
<td>Take first derivative twice to compute second derivate</td>
<td></td>
</tr>
<tr>
<td>NumEvolvedVars</td>
<td>5</td>
<td>The number of evolved variables in this thorn</td>
<td>5:5 :: "five"<em>OR</em></td>
</tr>
<tr>
<td>recalculate_rhs</td>
<td>"yes"</td>
<td>Recalculate the RHSs in the ANALYSIS timebin</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="coordinatessymmetry">CoordinatesSymmetry</h3>
<p>Cactus Code Thorn CoordinatesSymmetry
Author(s)    : Christian Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>, Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Maintainer(s): Christian Reisswig <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;">&#114;&#101;&#105;&#115;&#115;&#119;&#105;&#103;&#64;&#116;&#97;&#112;&#105;&#114;&#46;&#99;&#97;&#108;&#116;&#101;&#99;&#104;&#46;&#101;&#100;&#117;</a>, Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#99;&#99;&#116;&#46;&#108;&#115;&#117;&#46;&#101;&#100;&#117;</a>
Licence      : GPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Provide various symmetries, i.e., bitant, quadrant, and octant mode.</p>
<p>This thorn is adapted from Cactus to work with Llama symmetries.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Produce screen output while applying boundary conditions</td>
<td></td>
</tr>
<tr>
<td>reflection_x</td>
<td>"no"</td>
<td>Reflection symmetry at the lower x boundary</td>
<td></td>
</tr>
<tr>
<td>reflection_y</td>
<td>"no"</td>
<td>Reflection symmetry at the lower y boundary</td>
<td></td>
</tr>
<tr>
<td>reflection_z</td>
<td>"no"</td>
<td>Reflection symmetry at the lower z boundary</td>
<td></td>
</tr>
<tr>
<td>rotating_90</td>
<td>"no"</td>
<td>Apply an octant 90 degree rotating symmetry condition</td>
<td></td>
</tr>
<tr>
<td>stagger</td>
<td>"yes"</td>
<td>Stagger symmetry boundaries?</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="interpolate2">Interpolate2</h3>
<p>Cactus Code Thorn Interpolate2
Author(s)    : Denis Pollney
               Christian Reisswig
               Erik Schnetter
               Peter Diener
               Nils Dorband
               many others
Maintainer(s): Denis Pollney, Christian Reisswig
Licence      : GPLv2+</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Llama is a multipatch infrastructure for Cactus.</p>
<p>This thorn provides the interpatch interpolation setup.</p>
<p>For more information see the documentation in the ThornGuide.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>coordsystem</td>
<td>"cart3d"</td>
<td>The coordinate system to use</td>
<td>#  "" :: "must be a registered coordinate system"<em>OR</em>#</td>
</tr>
<tr>
<td>interpolator</td>
<td>"Lagrange</td>
<td>The interpolator to use</td>
<td>#  "" :: "must be a registered interpolator"<em>OR</em>#</td>
</tr>
<tr>
<td>interpolator_options</td>
<td>"order=4"</td>
<td>Options for the interpolator</td>
<td>#  "" :: "must be a valid options specification"<em>OR</em>#</td>
</tr>
<tr>
<td>interpolator_order</td>
<td>4</td>
<td>Interpolation order</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>interpolator_order_matter</td>
<td>-1</td>
<td>Interpolation order for those variables having an 'interpolator=matter' tag</td>
<td>-1  :: "Don't use special matter interpolator"<em>OR</em>   1  :: "1<sup>st</sup>-order Lagrange"<em>OR</em>   2  :: "2<sup>nd</sup> order ENO"<em>OR</em></td>
</tr>
<tr>
<td>fill_patch0_radius_min</td>
<td>1e+30</td>
<td>Interpolate to patch 0 from this radius on</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>fill_patch0_radius_max</td>
<td>1e+30</td>
<td>Interpolate to patch 0 up to this radius</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>fill_patch0_xyradius_min</td>
<td>1e+30</td>
<td>Interpolate to patch 0 from this cylindrical radius in the x-y plane on</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>fill_patch0_xyradius_max</td>
<td>1e+30</td>
<td>Interpolate to patch 0 up to this cylindrical radius in the x-y plane</td>
<td>0.0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>poison</td>
<td>-4.2e+20</td>
<td>Poison value to detect uninitialised variables</td>
<td><em>:</em> :: ""<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Produce debug output</td>
<td></td>
</tr>
<tr>
<td>continue_if_selftest_fails</td>
<td>"no"</td>
<td>Continue if the self test fails -- this is only for debugging</td>
<td></td>
</tr>
<tr>
<td>interpolate_zero</td>
<td>"no"</td>
<td>Set interpolation result to zero -- this is only for debugging</td>
<td></td>
</tr>
<tr>
<td>shift_edges</td>
<td>"no"</td>
<td>Artificially shift coordinates of grid function edges (use this for DGFE)</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="cactusbase">CactusBase</h2>
<h3 id="ioutil">IOUtil</h3>
<p>Cactus Code Thorn IOUtil
Author(s)    : Gabrielle Allen
               Tom Goodale
               Thomas Radke
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn is the flesh for IO - it always needs to be activated
if you want to do some IO in Cactus.</p>
<p>The thorn just provides basic IO parameters.
These are used in other IO thorns which do the real work.</p>
<p>It also provides a method for registration of recovery routines.</p>
<ol>
<li>Additional information</li>
</ol>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>out_dir</td>
<td>"."</td>
<td>Default output directory</td>
<td>".+" :: "A valid directory name"<em>OR</em></td>
</tr>
<tr>
<td>max_entries_per_subdir</td>
<td>0</td>
<td>Number of processes that can access the same directory</td>
<td>0 :: "unlimited"<em>OR</em>  2:* :: "at most that many processes"<em>OR</em></td>
</tr>
<tr>
<td>out_criterion</td>
<td>"iteration"</td>
<td>Criterion to select output intervals</td>
<td>"never"     :: "Never output"<em>OR</em>  "iteration" :: "Output every so many iterations"<em>OR</em>  "time"      :: "Output every that much coordinate time"<em>OR</em></td>
</tr>
<tr>
<td>out_every</td>
<td>-1</td>
<td>How often to do output by default</td>
<td>1:* :: "Every so many iterations"<em>OR</em>  -1:0 :: "Disable output"<em>OR</em></td>
</tr>
<tr>
<td>out_dt</td>
<td>-2</td>
<td>How often to do output by default</td>
<td>(0:* :: "In intervals of that much coordinate time"<em>OR</em>   0   :: "As often as possible"<em>OR</em>  -1   :: "Disable output"<em>OR</em>  -2   :: "Disable output"<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>"standard"</td>
<td>Level of screen output for I/O</td>
<td>"none"     :: "No output"<em>OR</em>  "standard" :: "Initial description for each I/O method"<em>OR</em>  "full"     :: "Maximal output"<em>OR</em></td>
</tr>
<tr>
<td>print_timing_info</td>
<td>"no"</td>
<td>Print timing information on I/O operations.</td>
<td></td>
</tr>
<tr>
<td>new_filename_scheme</td>
<td>"yes"</td>
<td>Use the new filename scheme for output files ?</td>
<td></td>
</tr>
<tr>
<td>require_empty_output_directory</td>
<td>"no"</td>
<td>Require that IO::out_dir is empty at startup ?</td>
<td></td>
</tr>
<tr>
<td>strict_io_parameter_check</td>
<td>"yes"</td>
<td>Stop on errors while parsing I/O parameters from parameter file ?</td>
<td></td>
</tr>
<tr>
<td>abort_on_io_errors</td>
<td>"no"</td>
<td>Abort on I/O errors (rather than just print a warning) ?</td>
<td></td>
</tr>
<tr>
<td>out_fileinfo</td>
<td>"all"</td>
<td>Add some useful file information to output files ?</td>
<td>"none"               :: "no file information"<em>OR</em>  "creation date"      :: "add creation date"<em>OR</em>  "parameter filename" :: "add parameter filename"<em>OR</em>  "axis labels"        :: "add axis labels information to output files"<em>OR</em>  "all"                :: "add all available file information"<em>OR</em></td>
</tr>
<tr>
<td>out_group_separator</td>
<td>"-"</td>
<td>String to separate group name from variable name in file name</td>
<td>"" :: "Note: The old default was'::'"<em>OR</em></td>
</tr>
<tr>
<td>out_mode</td>
<td>"proc"</td>
<td>Which mode to use for output</td>
<td>"proc"    :: "Every processor writes its share of data into a separate file"<em>OR</em>  "np"      :: "Data is collected and written by every N'th processor into a separate file, where N is specified by the parameter IO::out_proc_every"<em>OR</em>  "onefile" :: "All output is written into a single file by processor 0"<em>OR</em></td>
</tr>
<tr>
<td>out_proc_every</td>
<td>8</td>
<td>Do output on every N processors</td>
<td>1:* :: "A number between [1, nprocs)"<em>OR</em></td>
</tr>
<tr>
<td>out_timesteps_per_file</td>
<td>-1</td>
<td>How many timesteps to write to a single file</td>
<td>#   1:* :: "Number of timesteps per file"<em>OR</em>   1:1 :: "Number of timesteps per file (can only be 1 so far)"<em>OR</em>  -1:  :: "All timesteps in a single file"<em>OR</em></td>
</tr>
<tr>
<td>out3D_septimefiles</td>
<td>"no"</td>
<td>Write one file per time slice, as opposed to all data in one file</td>
<td></td>
</tr>
<tr>
<td>out_unchunked</td>
<td>"no"</td>
<td>Don't write data in chunks. This parameter is ignored for single-processor runs where output is always done in unchunked mode.</td>
<td></td>
</tr>
<tr>
<td>out_save_parameters</td>
<td>"only</td>
<td>Save current parameter settings in output files ?</td>
<td>"all"      :: "Save all parameter settings"<em>OR</em>  "only set" :: "Only save parameters which have been set before"<em>OR</em>  "no"       :: "Don't save parameter settings"<em>OR</em></td>
</tr>
<tr>
<td>out_downsample_x</td>
<td>1</td>
<td>Factor by which to downsample output in x direction. Point (0,0,0) is always included.</td>
<td>1:* :: "A positive integer"<em>OR</em></td>
</tr>
<tr>
<td>out_downsample_y</td>
<td>1</td>
<td>Factor by which to downsample output in y direction. Point (0,0,0) is always included.</td>
<td>1:* :: "A positive integer"<em>OR</em></td>
</tr>
<tr>
<td>out_downsample_z</td>
<td>1</td>
<td>Factor by which to downsample output in z direction. Point (0,0,0) is always included.</td>
<td>1:* :: "A positive integer"<em>OR</em></td>
</tr>
<tr>
<td>out_single_precision</td>
<td>"no"</td>
<td>Output data in single precision ?</td>
<td></td>
</tr>
<tr>
<td>checkpoint_ID</td>
<td>"no"</td>
<td>Checkpoint initial data ?</td>
<td></td>
</tr>
<tr>
<td>recover</td>
<td>"no"</td>
<td>Recover from a checkpoint file ?</td>
<td>"no"        :: "Don't recover"<em>OR</em>  "manual"    :: "Recover from the checkpoint file as given in IO::recover_dir and IO::recover_file"<em>OR</em>  "auto"      :: "Automatically recover from the latest checkpoint file found in <recover_dir>"<em>OR</em>  "autoprobe" :: "Probe for checkpoint files and automatically recover, continue as usual if nothing was found"<em>OR</em></td>
</tr>
<tr>
<td>checkpoint_every</td>
<td>-1</td>
<td>How often to checkpoint</td>
<td>1:* :: "Every so many iterations"<em>OR</em>  -1:0 :: "Disable periodic checkpointing"<em>OR</em></td>
</tr>
<tr>
<td>checkpoint_every_walltime_hours</td>
<td>-1</td>
<td>How often to checkpoint</td>
<td>(0:* :: "After so much walltime has passed"<em>OR</em>  -1   :: "Disable periodic walltime checkpointing"<em>OR</em></td>
</tr>
<tr>
<td>checkpoint_on_terminate</td>
<td>"no"</td>
<td>Checkpoint after last iteration</td>
<td></td>
</tr>
<tr>
<td>checkpoint_keep</td>
<td>1</td>
<td>How many checkpoint files to keep</td>
<td>1:* :: "1 overwrites the latest checkpoint file"<em>OR</em>  -1:  :: "Keep all checkpoint files"<em>OR</em></td>
</tr>
<tr>
<td>checkpoint_file</td>
<td>"checkpoint.chkpt"</td>
<td>File name for regular checkpoint</td>
<td>".+" :: "A valid filename"<em>OR</em></td>
</tr>
<tr>
<td>checkpoint_ID_file</td>
<td>"checkpoint.chkpt"</td>
<td>File name for initial data checkpoint</td>
<td>".+" :: "A valid filename"<em>OR</em></td>
</tr>
<tr>
<td>recover_file</td>
<td>"checkpoint.chkpt"</td>
<td>Basename of recovery file</td>
<td>".+" :: "A valid filename"<em>OR</em></td>
</tr>
<tr>
<td>checkpoint_dir</td>
<td>"."</td>
<td>Output directory for checkpoint files</td>
<td>".+" :: "A valid directory name"<em>OR</em></td>
</tr>
<tr>
<td>recover_dir</td>
<td>"."</td>
<td>Directory to look for recovery files</td>
<td>".+" :: "A valid directory name"<em>OR</em></td>
</tr>
<tr>
<td>filereader_ID_dir</td>
<td>"."</td>
<td>Directory to look for input files</td>
<td>".+" :: "A valid directory name"<em>OR</em></td>
</tr>
<tr>
<td>filereader_ID_files</td>
<td>""</td>
<td>List of basenames of files to read in as initial data (e.g. omit the filename extention here)</td>
<td>".+" :: "Space-separated list of initial data filenames (basenames, e.g. excluding the file name extention)"<em>OR</em>  "^$" :: "An empty string for not recovering initial data"<em>OR</em></td>
</tr>
<tr>
<td>filereader_ID_vars</td>
<td>"all"</td>
<td>List of variables to read in from the given initial data files</td>
<td>"all" :: "Read all variables contained in the initial data files"<em>OR</em>  ".+"  :: "Space-separated list of fully qualified variable/group names"<em>OR</em>  "^$"  :: "An empty string for not recovering initial data"<em>OR</em></td>
</tr>
<tr>
<td>recover_and_remove</td>
<td>"no"</td>
<td>Remove checkpoint file after successful recovery ?</td>
<td></td>
</tr>
<tr>
<td>parfile_write</td>
<td>"copy"</td>
<td>Write a parameter file to 'IO::out_dir'</td>
<td>"no"               :: "Do not write a parameter file"<em>OR</em>  "copy"             :: "Copy the original parameter file"<em>OR</em>  "generate"         :: "Generate a parameter file from the current settings"<em>OR</em>#  "verbose generate" :: "Like \"generate\" but describe all parameters in detail"<em>OR</em></td>
</tr>
<tr>
<td>parfile_name</td>
<td>""</td>
<td>Filename for the parameter file to be written</td>
<td>".+" :: "A valid filename"<em>OR</em>  "^$" :: "An empty string to choose the original parameter filename"<em>OR</em></td>
</tr>
<tr>
<td>parfile_update_every</td>
<td>0</td>
<td>How often to update the parameter file for steered parameters</td>
<td>1:* :: "Every so many iterations"<em>OR</em>  0:  :: "Disable updating"<em>OR</em></td>
</tr>
<tr>
<td>out_xline_y</td>
<td>0.0</td>
<td>y-coord for 1D lines in x-direction</td>
<td><em>:</em> :: "A value between [ymin, ymax]"<em>OR</em></td>
</tr>
<tr>
<td>out_xline_z</td>
<td>0.0</td>
<td>z-coord for 1D lines in x-direction</td>
<td><em>:</em> :: "A value between [zmin, zmax]"<em>OR</em></td>
</tr>
<tr>
<td>out_yline_x</td>
<td>0.0</td>
<td>x-coord for 1D lines in y-direction</td>
<td><em>:</em> :: "A value between [xmin, xmax]"<em>OR</em></td>
</tr>
<tr>
<td>out_yline_z</td>
<td>0.0</td>
<td>z-coord for 1D lines in y-direction</td>
<td><em>:</em> :: "A value between [zmin, zmax]"<em>OR</em></td>
</tr>
<tr>
<td>out_zline_x</td>
<td>0.0</td>
<td>x-coord for 1D lines in z-direction</td>
<td><em>:</em> :: "A value between [xmin, xmax]"<em>OR</em></td>
</tr>
<tr>
<td>out_zline_y</td>
<td>0.0</td>
<td>y-coord for 1D lines in z-direction</td>
<td><em>:</em> :: "A value between [ymin, ymax]"<em>OR</em></td>
</tr>
<tr>
<td>out_xline_yi</td>
<td>-2</td>
<td>y-index (from 0) for 1D lines in x-direction, overrides IO::out_xline_y</td>
<td>0:* :: "An index between [0, ny)"<em>OR</em>  -1:  :: "Default to physical coordinate IO::out_xline_y if it is within grid bounds, otherwise revert to using 0"<em>OR</em>  -2:  :: "Default to physical coordinate IO::out_xline_y if it is within grid bounds, otherwise revert to using the y-center of the box"<em>OR</em></td>
</tr>
<tr>
<td>out_xline_zi</td>
<td>-2</td>
<td>z-index (from 0) for 1D lines in x-direction, overrides IO::out_xline_z</td>
<td>0:* :: "An index between [0, nz)"<em>OR</em>  -1:  :: "Default to physical coordinate IO::out_xline_z if it is within grid bounds, otherwise revert to using 0"<em>OR</em>  -2:  :: "Default to physical coordinate IO::out_xline_z if it is within grid bounds, otherwise revert to using the z-center of the box"<em>OR</em></td>
</tr>
<tr>
<td>out_yline_xi</td>
<td>-2</td>
<td>x-index (from 0) for 1D lines in y-direction, overrides IO::out_yline_x</td>
<td>0:* :: "An index between [0, nx)"<em>OR</em>  -1:  :: "Default to physical coordinate IO::out_yline_x if it is within grid bounds, otherwise revert to using 0"<em>OR</em>  -2:  :: "Default to physical coordinate IO::out_yline_x if it is within grid bounds, otherwise revert to using the x-center of the box"<em>OR</em></td>
</tr>
<tr>
<td>out_yline_zi</td>
<td>-2</td>
<td>z-index (from 0) for 1D lines in y-direction, overrides IO::out_yline_z</td>
<td>0:* :: "An index between [0, nz)"<em>OR</em>  -1:  :: "Default to physical coordinate IO::out_yline_z if it is within grid bounds, otherwise revert to using 0"<em>OR</em>  -2:  :: "Default to physical coordinate IO::out_yline_z if it is within grid bounds, otherwise revert to using the z-center of the box"<em>OR</em></td>
</tr>
<tr>
<td>out_zline_xi</td>
<td>-2</td>
<td>x-index (from 0) for 1D lines in z-direction, overrides IO::out_zline_x</td>
<td>0:* :: "An index between [0, nx)"<em>OR</em>  -1:  :: "Default to physical coordinate IO::out_zline_x if it is within grid bounds, otherwise revert to using 0"<em>OR</em>  -2:  :: "Default to physical coordinate IO::out_zline_x if it is within grid bounds, otherwise revert to using the x-center of the box"<em>OR</em></td>
</tr>
<tr>
<td>out_zline_yi</td>
<td>-2</td>
<td>y-index (from 0) for 1D lines in z-direction, overrides IO::out_zline_y</td>
<td>0:* :: "An index between [0, ny)"<em>OR</em>  -1:  :: "Default to physical coordinate IO::out_zline_y if it is within grid bounds, otherwise revert to using 0"<em>OR</em>  -2:  :: "Default to physical coordinate IO::out_zline_y if it is within grid bounds, otherwise revert to using the y-center of the box"<em>OR</em></td>
</tr>
<tr>
<td>out_yzplane_x</td>
<td>0.0</td>
<td>x-coord for 2D planes in yz</td>
<td><em>:</em> :: "A value between [xmin, xmax]"<em>OR</em></td>
</tr>
<tr>
<td>out_xzplane_y</td>
<td>0.0</td>
<td>y-coord for 2D planes in xz</td>
<td><em>:</em> :: "A value between [ymin, ymax]"<em>OR</em></td>
</tr>
<tr>
<td>out_xyplane_z</td>
<td>0.0</td>
<td>z-coord for 2D planes in xy</td>
<td><em>:</em> :: "A value between [zmin, zmax]"<em>OR</em></td>
</tr>
<tr>
<td>out_yzplane_xi</td>
<td>-2</td>
<td>x-index (from 0) for 2D planes in yz, overrrides IO::out_yzplane_x</td>
<td>0:* :: "An index between [0, nx)"<em>OR</em>  -1:  :: "Default to physical coordinate IO::out_yzplane_x if it is within grid bounds, otherwise revert to using 0"<em>OR</em>  -2:  :: "Default to physical coordinate IO::out_yzplane_x if it is within grid bounds, otherwise revert to using the x-center of the box"<em>OR</em></td>
</tr>
<tr>
<td>out_xzplane_yi</td>
<td>-2</td>
<td>y-index (from 0) for 2D planes in xz, overrrides IO::out_xzplane_y</td>
<td>0:* :: "An index between [0, ny)"<em>OR</em>  -1:  :: "Default to physical coordinate IO::out_xzplane_y if it is within grid bounds, otherwise revert to using 0"<em>OR</em>  -2:  :: "Default to physical coordinate IO::out_xzplane_y if it is within grid bounds, otherwise revert to using the y-center of the box"<em>OR</em></td>
</tr>
<tr>
<td>out_xyplane_zi</td>
<td>-2</td>
<td>z-index (from 0) for 2D planes in xy, overrrides IO::out_xyplane_z</td>
<td>0:* :: "An index between [0, nz)"<em>OR</em>  -1:  :: "Default to physical coordinate IO::out_xyplane_z if it is within grid bounds, otherwise revert to using 0"<em>OR</em>  -2:  :: "Default to physical coordinate IO::out_xyplane_z if it is within grid bounds, otherwise revert to using the z-center of the box"<em>OR</em></td>
</tr>
<tr>
<td>truncate_files</td>
<td>"yes"</td>
<td>Truncate existing output files from previous runs (except when recovering) ?</td>
<td></td>
</tr>
<tr>
<td>truncate_files_after_recovering</td>
<td>"no"</td>
<td>Truncate existing output files after recovering ?</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="iobasic">IOBasic</h3>
<p>Cactus Code Thorn IOBasic
Author(s)    : Gabrielle Allen
               Thomas Radke
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn provides two I/O methods "Info" and "Scalar" which output grid
variables as scalars as a function on time.</p>
<p>Grid scalars:
 - Output the value of the scalar straight forwardly</p>
<p>Grid functions:
 - Output the reduction value of the grid function versus time.
   For this you also need to activate a thorn which implements reduction
   operators (eg. PUGHReduce which provides the standard reductions
   "minimum", "maximum", "sum", "norm1", "norm2", and "norm_inf").</p>
<p>The "Info" method would print the values, along with the current iteration
number and the physical time, in a formatted table to stdout.</p>
<p>The "Scalar" methods outputs to ASCII files which can be processed with
gnuplot or xgraph.</p>
<ol>
<li>Additional information</li>
</ol>
<p>There is more comprehensive documention available in this thorn's
doc/documentation.tex file which is included in the Cactus Thorn Guide.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>out_dir</td>
<td>""</td>
<td>Output directory for IOBasic's scalar files, overrides IO::out_dir</td>
<td>".+" :: "A valid directory name"<em>OR</em>  "^$" :: "An empty string to choose the default from IO::out_dir"<em>OR</em></td>
</tr>
<tr>
<td>outInfo_vars</td>
<td>""</td>
<td>Variables to output as Info to screen</td>
<td>".+" :: "Space-separated list of fully qualified variable/group names"<em>OR</em>  "^$" :: "An empty string to output nothing"<em>OR</em></td>
</tr>
<tr>
<td>outScalar_vars</td>
<td>""</td>
<td>Variables to output into files</td>
<td>".+" :: "Space-separated list of fully qualified variable/group names"<em>OR</em>  "^$" :: "An empty string to output nothing"<em>OR</em></td>
</tr>
<tr>
<td>outInfo_reductions</td>
<td>"minimum</td>
<td>List of reductions to output as Info to screen</td>
<td>".+" :: "Space-separated list of reduction operators"<em>OR</em></td>
</tr>
<tr>
<td>outScalar_reductions</td>
<td>"minimum</td>
<td>List of reductions to output into files</td>
<td>".+" :: "Space-separated list of reduction operators"<em>OR</em></td>
</tr>
<tr>
<td>outInfo_criterion</td>
<td>"iteration"</td>
<td>Criterion to select Info output intervals</td>
<td>"never"     :: "Never output"<em>OR</em>  "iteration" :: "Output every so many iterations"<em>OR</em>  "time"      :: "Output every that much coordinate time"<em>OR</em></td>
</tr>
<tr>
<td>outInfo_every</td>
<td>-1</td>
<td>How often to do Info output</td>
<td>1:* :: "Every so many iterations"<em>OR</em>   0:  :: "Disable Info output"<em>OR</em>  -1:  :: "Default to IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>outInfo_dt</td>
<td>-2</td>
<td>How often to do Info output</td>
<td>(0:* :: "In intervals of that much coordinate time"<em>OR</em>   0   :: "As often as possible"<em>OR</em>  -1   :: "Disable output"<em>OR</em>  -2   :: "Default to IO::out_dt"<em>OR</em></td>
</tr>
<tr>
<td>outScalar_criterion</td>
<td>"iteration"</td>
<td>Criterion to select Scalar output intervals</td>
<td>"never"     :: "Never output"<em>OR</em>  "iteration" :: "Output every so many iterations"<em>OR</em>  "time"      :: "Output every that much coordinate time"<em>OR</em></td>
</tr>
<tr>
<td>outScalar_every</td>
<td>-1</td>
<td>How often to do Scalar output</td>
<td>1:* :: "Every so many iterations"<em>OR</em>   0:  :: "Disable Scalar output"<em>OR</em>  -1:  :: "Default to IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>outScalar_dt</td>
<td>-2</td>
<td>How often to do Scalar output</td>
<td>(0:* :: "In intervals of that much coordinate time"<em>OR</em>   0   :: "As often as possible"<em>OR</em>  -1   :: "Disable output"<em>OR</em>  -2   :: "Default to IO::out_dt"<em>OR</em></td>
</tr>
<tr>
<td>outScalar_style</td>
<td>"xgraph"</td>
<td>Which style for Scalar output</td>
<td>"gnuplot" :: "1D output readable by gnuplot"<em>OR</em>  "xgraph"  :: "1D output readable by xgraph"<em>OR</em></td>
</tr>
<tr>
<td>out_format</td>
<td>".13f"</td>
<td>Which format for Scalar floating-point number output</td>
<td>"^(.[1]?[0-9])?[EGefg]$" :: "output with given precision in exponential / floating point notation"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="ioascii">IOASCII</h3>
<p>Cactus Code Thorn IOASCII
Author(s)    : Gabrielle Allen
               Tom Goodale
               Thomas Radke
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn does 1D, 2D, and 3D output of 3D variables in ASCII format.</p>
<p>1D output slices through the edge (in octant mode) or center
(in all origin-centered modes) of the grid in the x,y, and z directions.
If the grid is cubed it will also slice in the diagonal direction.
Ouput files can be processed with either gnuplot or xgraph.</p>
<p>2D output is done for the xy, xz, and yz plane.
Ouput files can be processed with the splot command in gnuplot.</p>
<p>3D output is simply done for the full 3D grid variables.
Ouput files can be processed with the splot command in gnuplot.</p>
<p>The IO methods "IOASCII_1D", "IOASCII_2D", and "IOASCII_3D" are registered 
which can be called by other thorns via CCTK_OutputVarAsByMethod()
to output a variable without specifying it in the parameter file.</p>
<ol>
<li>Additional information</li>
</ol>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>out1D_dir</td>
<td>""</td>
<td>Output directory for 1D IOASCII files, overrides IO::out_dir</td>
<td>".+" :: "A valid directory name"<em>OR</em>  "^$" :: "An empty string to choose the default from IO::out_dir"<em>OR</em></td>
</tr>
<tr>
<td>out2D_dir</td>
<td>""</td>
<td>Output directory for 2D IOASCII files, overrides out_dir</td>
<td>".+" :: "A valid directory name"<em>OR</em>  "^$" :: "An empty string to choose the default from IO::out_dir"<em>OR</em></td>
</tr>
<tr>
<td>out3D_dir</td>
<td>""</td>
<td>Output directory for 3D IOASCII files, overrides IO::out_dir</td>
<td>".+" :: "A valid directory name"<em>OR</em>  "^$" :: "An empty string to choose the default from IO::out_dir"<em>OR</em></td>
</tr>
<tr>
<td>out1D_vars</td>
<td>""</td>
<td>Variables to output in 1D IOASCII file format</td>
<td>".+" :: "Space-separated list of fully qualified variable/group names"<em>OR</em>  "^$" :: "An empty string to output nothing"<em>OR</em></td>
</tr>
<tr>
<td>out2D_vars</td>
<td>""</td>
<td>Variables to output in 2D IOASCII file format</td>
<td>".+" :: "Space-separated list of fully qualified variable/group names"<em>OR</em>  "^$" :: "An empty string to output nothing"<em>OR</em></td>
</tr>
<tr>
<td>out3D_vars</td>
<td>""</td>
<td>Variables to output in 3D IOASCII file format</td>
<td>".+" :: "Space-separated list of fully qualified variable/group names"<em>OR</em>  "^$" :: "An empty string to output nothing"<em>OR</em></td>
</tr>
<tr>
<td>out1D_every</td>
<td>-1</td>
<td>How often to do 1D IOASCII output, overrides IO::out_every</td>
<td>1:* :: "Every so many iterations"<em>OR</em>   0:  :: "Disable 1D IOASCII output"<em>OR</em>  -1:  :: "Default to IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>out2D_every</td>
<td>-1</td>
<td>How often to do 2D IOASCII output, overrides IO::out_every</td>
<td>1:* :: "Every so many iterations"<em>OR</em>   0:  :: "Disable 2D IOASCII output"<em>OR</em>  -1:  :: "Default to IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>out3D_every</td>
<td>-1</td>
<td>How often to do 3D IOASCII output, overrides IO::out_every</td>
<td>1:* :: "Every so many iterations"<em>OR</em>   0:  :: "Disable 3D IOASCII output"<em>OR</em>  -1:  :: "Default to IO::out_every"<em>OR</em></td>
</tr>
<tr>
<td>out1D_style</td>
<td>"xgraph"</td>
<td>Which style for 1D lines IOASCII output</td>
<td>"xgraph"         :: "f over x plots suitable for xgraph"<em>OR</em>  "gnuplot f(x)"   :: "f over x plots suitable for gnuplot"<em>OR</em>  "gnuplot f(t,x)" :: "f over t,x plots suitable for gnuplot"<em>OR</em></td>
</tr>
<tr>
<td>out2D_style</td>
<td>"gnuplot</td>
<td>Which style for 2D slices IOASCII output</td>
<td>"gnuplot f(x,y)"   :: "f over x,y plots suitable for gnuplot"<em>OR</em>  "gnuplot f(t,x,y)" :: "f over t,x,y plots suitable for gnuplot"<em>OR</em></td>
</tr>
<tr>
<td>out3D_style</td>
<td>"gnuplot</td>
<td>Which style for 3D volume IOASCII output</td>
<td>"gnuplot f(x,y,z)"   :: "f over x,y,z plots suitable for gnuplot"<em>OR</em>  "gnuplot f(t,x,y,z)" :: "f over t,x,y,z plots suitable for gnuplot"<em>OR</em></td>
</tr>
<tr>
<td>out_format</td>
<td>".13f"</td>
<td>Which format for IOASCII floating-point number output</td>
<td>"^(.[1]?[0-9])?[EGefg]$" :: "output with given precision in exponential / floating point notation"<em>OR</em></td>
</tr>
<tr>
<td>out1D_x</td>
<td>"yes"</td>
<td>Do 1D IOASCII output in the x-direction</td>
<td></td>
</tr>
<tr>
<td>out1D_y</td>
<td>"yes"</td>
<td>Do 1D IOASCII output in the y-direction</td>
<td></td>
</tr>
<tr>
<td>out1D_z</td>
<td>"yes"</td>
<td>Do 1D IOASCII output in the z-direction</td>
<td></td>
</tr>
<tr>
<td>out1D_d</td>
<td>"yes"</td>
<td>Do 1D IOASCII output in the diagonal-direction</td>
<td></td>
</tr>
<tr>
<td>out1D_xline_y</td>
<td>-424242</td>
<td>y-coord for 1D lines in x-direction</td>
<td><em>:</em>      :: "A value between [ymin, ymax]"<em>OR</em>  -424242: :: "Default to IO::out_xline_y"<em>OR</em></td>
</tr>
<tr>
<td>out1D_xline_z</td>
<td>-424242</td>
<td>z-coord for 1D lines in x-direction</td>
<td><em>:</em>      :: "A value between [zmin, zmax]"<em>OR</em>  -424242: :: "Default to IO::out_xline_z"<em>OR</em></td>
</tr>
<tr>
<td>out1D_yline_x</td>
<td>-424242</td>
<td>x-coord for 1D lines in y-direction</td>
<td><em>:</em>      :: "A value between [xmin, xmax]"<em>OR</em>  -424242: :: "Default to IO::out_yline_x"<em>OR</em></td>
</tr>
<tr>
<td>out1D_yline_z</td>
<td>-424242</td>
<td>z-coord for 1D lines in y-direction</td>
<td><em>:</em>      :: "A value between [zmin, zmax]"<em>OR</em>  -424242: :: "Default to IO::out_yline_z"<em>OR</em></td>
</tr>
<tr>
<td>out1D_zline_x</td>
<td>-424242</td>
<td>x-coord for 1D lines in z-direction</td>
<td><em>:</em>      :: "A value between [xmin, xmax]"<em>OR</em>  -424242: :: "Default to IO::out_zline_x"<em>OR</em></td>
</tr>
<tr>
<td>out1D_zline_y</td>
<td>-424242</td>
<td>y-coord for 1D lines in z-direction</td>
<td><em>:</em>      :: "A value between [ymin, ymax]"<em>OR</em>  -424242: :: "Default to IO::out_zline_y"<em>OR</em></td>
</tr>
<tr>
<td>out1D_xline_yi</td>
<td>-1</td>
<td>y-index (from 0) for 1D lines in x-direction</td>
<td>0:* :: "An index between [0, ny)"<em>OR</em>  -1:  :: "Choose the default from IO::out_xline_yi"<em>OR</em></td>
</tr>
<tr>
<td>out1D_xline_zi</td>
<td>-1</td>
<td>z-index (from 0) for 1D lines in x-direction</td>
<td>0:* :: "An index between [0, nz)"<em>OR</em>  -1:  :: "Choose the default from IO::out_xline_zi"<em>OR</em></td>
</tr>
<tr>
<td>out1D_yline_xi</td>
<td>-1</td>
<td>x-index (from 0) for 1D lines in y-direction</td>
<td>0:* :: "An index between [0, nx)"<em>OR</em>  -1:  :: "Choose the default from IO::out_yline_xi"<em>OR</em></td>
</tr>
<tr>
<td>out1D_yline_zi</td>
<td>-1</td>
<td>z-index (from 0) for 1D lines in y-direction</td>
<td>0:* :: "An index between [0, nz)"<em>OR</em>  -1:  :: "Choose the default from IO::out_yline_zi"<em>OR</em></td>
</tr>
<tr>
<td>out1D_zline_xi</td>
<td>-1</td>
<td>x-index (from 0) for 1D lines in z-direction</td>
<td>0:* :: "An index between [0, nx)"<em>OR</em>  -1:  :: "Choose the default from IO::out_zline_xi"<em>OR</em></td>
</tr>
<tr>
<td>out1D_zline_yi</td>
<td>-1</td>
<td>y-index (from 0) for 1D lines in z-direction</td>
<td>0:* :: "An index between [0, ny)"<em>OR</em>  -1:  :: "Choose the default from IO::out_zline_yi"<em>OR</em></td>
</tr>
<tr>
<td>out2D_yzplane_x</td>
<td>-424242</td>
<td>x-coord for 2D planes in yz</td>
<td><em>:</em>      :: "A value between [xmin, xmax]"<em>OR</em>  -424242: :: "Default to IO::out_yzplane_x"<em>OR</em></td>
</tr>
<tr>
<td>out2D_xzplane_y</td>
<td>-424242</td>
<td>y-coord for 2D planes in xz</td>
<td><em>:</em>      :: "A value between [ymin, ymax]"<em>OR</em>  -424242: :: "Default to IO::out_xzplane_y"<em>OR</em></td>
</tr>
<tr>
<td>out2D_xyplane_z</td>
<td>-424242</td>
<td>z-coord for 2D planes in xy</td>
<td><em>:</em>      :: "A value between [zmin, zmax]"<em>OR</em>  -424242: :: "Default to IO::out_xyplane_z"<em>OR</em></td>
</tr>
<tr>
<td>out2D_yzplane_xi</td>
<td>-1</td>
<td>x-index (from 0) for 2D planes in yz</td>
<td>0:* :: "An index between [0, nx)"<em>OR</em>  -1:  :: "Choose the default from IO::out_yzplane_xi"<em>OR</em></td>
</tr>
<tr>
<td>out2D_xzplane_yi</td>
<td>-1</td>
<td>y-index (from 0) for 2D planes in xz</td>
<td>0:* :: "An index between [0, ny)"<em>OR</em>  -1:  :: "Choose the default from IO::out_xzplane_yi"<em>OR</em></td>
</tr>
<tr>
<td>out2D_xyplane_zi</td>
<td>-1</td>
<td>z-index (from 0) for 2D planes in xy</td>
<td>0:* :: "An index between [0, nz)"<em>OR</em>  -1:  :: "Choose the default from IO::out_xyplane_zi"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="boundary">Boundary</h3>
<p>Cactus Code Thorn Boundary
Author(s)    : Gabrielle Allen
               Gerd Lanfermann
               Miguel Alcubierre
               David Rideout
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn defines a generic interface for boundary conditions, which
allows, among other things, symmetry boundary conditions associated
with the grid to be applied without other thorns having knowledge of
them.</p>
<p>This thorn also provides some standard outer boundary conditions.</p>
<p>Currently:</p>
<ul>
<li>
<p>scalar boundary conditions</p>
</li>
<li>
<p>flat boundary conditions (a copy of the point just inside the
    boundary)</p>
</li>
<li>
<p>radiation boundary conditions</p>
</li>
<li>
<p>copy boundary conditions </p>
</li>
<li>
<p>Robin boundary conditions</p>
</li>
<li>
<p>static boundary conditions</p>
</li>
<li>
<p>Additional information</p>
</li>
</ul>
<p>Each of the boundary conditions mentioned above work only on grid
variables with less than four dimensions.</p>
<p>All the boundary conditions work with an arbitrarily size stencil
width, except for the Robin boundary condition which currently only
works with a stencil width of one.</p>
<p>The Robin boundary condition is only implemented for 3D grid functions
at the moment.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>radpower</td>
<td>-1</td>
<td>Power of decay rate in extrapolation used in radiative boundaries</td>
<td>: :: "A negative value switches off this feature"<em>OR</em></td>
</tr>
<tr>
<td>register_scalar</td>
<td>"yes"</td>
<td>Register routine to handle the 'Scalar' boundary condition</td>
<td></td>
</tr>
<tr>
<td>register_flat</td>
<td>"yes"</td>
<td>Register routine to handle the 'Flat' boundary condition</td>
<td></td>
</tr>
<tr>
<td>register_radiation</td>
<td>"yes"</td>
<td>Register routine to handle the 'Radiation' boundary condition</td>
<td></td>
</tr>
<tr>
<td>register_copy</td>
<td>"yes"</td>
<td>Register routine to handle the 'Copy' boundary condition</td>
<td></td>
</tr>
<tr>
<td>register_robin</td>
<td>"yes"</td>
<td>Register routine to handle the 'Robin' boundary condition</td>
<td></td>
</tr>
<tr>
<td>register_static</td>
<td>"yes"</td>
<td>Register routine to handle the 'Static' boundary condition</td>
<td></td>
</tr>
<tr>
<td>register_none</td>
<td>"yes"</td>
<td>Register routine to handle the 'None' boundary condition</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="symbase">SymBase</h3>
<p>Cactus Code Thorn SymBase
Author(s)    : Erik Schnetter
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Provide generic handling of symmetries for grids and grid arrays.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>verbose</td>
<td>"yes"</td>
<td>Output symmetry boundary face descriptions after registration</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="time">Time</h3>
<p>Cactus Code Thorn Time
Author(s)    : Gabrielle Allen
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Thorn Time sets the timestep for the simulation by either</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>- setting the timestep directly from a parameter value

- using a Courant-type condition to set the timestep based
  on the grid-spacing used.
</pre></div>
</td></tr></table>

<p>The Courant condition can be applied either once at the start of the
simulation, or the timestep can be calculated dynamically before each timestep.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>timestep_method</td>
<td>"courant_static"</td>
<td>Method for calculating timestep</td>
<td>"given"          :: "Use given timestep"<em>OR</em> "courant_static" :: "Courant condition at BASEGRID (using dtfac)"<em>OR</em> "courant_speed"  :: "Courant condition at POSTSTEP (using wavespeed and courant_fac)"<em>OR</em> "courant_time"   :: "Courant condition at POSTSTEP (using min time and courant_fac)"<em>OR</em></td>
</tr>
<tr>
<td>timestep_outonly</td>
<td>"no"</td>
<td>Don't set a dynamic timestep, just output what it would be</td>
<td></td>
</tr>
<tr>
<td>timestep</td>
<td>0.0</td>
<td>Absolute value for timestep</td>
<td><em>:</em> :: "Could be anything"<em>OR</em></td>
</tr>
<tr>
<td>dtfac</td>
<td>0.5</td>
<td>The standard timestep condition dt = dtfac*max(delta_space)</td>
<td>0:* :: "For positive timestep"<em>OR</em> <em>:0 :: "For negative timestep"*OR</em></td>
</tr>
<tr>
<td>courant_fac</td>
<td>0.9</td>
<td>The courant timestep condition dt = courant_fac*max(delta_space)/speed/sqrt(dim)</td>
<td>0:* :: "For positive timestep"<em>OR</em> <em>:0 :: "For negative timestep"*OR</em></td>
</tr>
<tr>
<td>timestep_outevery</td>
<td>1</td>
<td>How often to output courant timestep</td>
<td>1:* :: "Zero means no output"<em>OR</em></td>
</tr>
<tr>
<td>verbose</td>
<td>"no"</td>
<td>Give selective information about timestep setting</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="initbase">InitBase</h3>
<p>Cactus Code Thorn InitBase
Author(s)    : Erik Schnetter
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Thorn InitBase specifies how initial data are to be set up.  It does
not set up any initial data by itself, nor does it contain any
routines which are to be called.  It is merely a convenient repository
remembering how initial data are to be set up, so that other thorns
can check their actions against this thorn.</p>
<p>There are several possibilities:</p>
<ol>
<li>
<p>The initial data thorn sets up data on one time level, while other
   time levels are scratch space.  The time evolution method must
   start up from a single time level.  (This is the default.)</p>
</li>
<li>
<p>The initial data thorn sets up data on exactly one time level, and
   is called once for each active time level.  (This means that the
   initial data thorn can only access the current time level.)</p>
</li>
<li>
<p>The initial data thorn sets up data on exactly two time levels, and
   is called once for each active time level.  (This means that the
   initial data thorn can only access the current and the first past
   time level.)</p>
</li>
<li>
<p>The initial data thorn sets up data on all active time levels.
   (This makes it necessary that the initial data thorn checks the
   number of active time levels.)</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>initial_data_setup_method</td>
<td>"init_some_levels"</td>
<td>Procedure for setting up initial data</td>
<td>"init_some_levels"  :: "Set up at least one time level; other time levels are scratch space"<em>OR</em>  "init_single_level" :: "Set up exactly one time level; other time levels are not accessed"<em>OR</em>  "init_two_levels"   :: "Set up exactly two time levels; other time levels are not accessed"<em>OR</em>  "init_all_levels"   :: "Set up all active time levels"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="fortran">Fortran</h3>
<p>Cactus Code Thorn Fortran
Thorn Author(s)     : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a>
Thorn Maintainer(s) : Erik Schnetter <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;">&#115;&#99;&#104;&#110;&#101;&#116;&#116;&#101;&#114;&#64;&#97;&#101;&#105;&#46;&#109;&#112;&#103;&#46;&#100;&#101;</a></p>
<hr />
<p>Purpose of the thorn:</p>
<p>Provide Fortran interfaces for the flesh functions.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>one</td>
<td>1</td>
<td>This parameter has the value one</td>
<td>1:1 :: "1"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="coordbase">CoordBase</h3>
<p>Cactus Code Thorn CoordBase
Author(s)    : Cactus team
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>Provides generic handling of coordinates for grid variables.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>domainsize</td>
<td>"minmax"</td>
<td>Domain size specification</td>
<td>"minmax"      :: "lower and upper boundary locations"<em>OR</em>  "extent"      :: "coordinate extent"<em>OR</em>  "spacing"     :: "grid spacing and number of grid cells"<em>OR</em></td>
</tr>
<tr>
<td>spacing</td>
<td>"gridspacing"</td>
<td>Grid spacing specification</td>
<td>"gridspacing" :: "grid spacing"<em>OR</em>  "numcells"    :: "number of grid cells"<em>OR</em></td>
</tr>
<tr>
<td>zero_origin_x</td>
<td>"no"</td>
<td>Is the lower boundary located at x=0?</td>
<td></td>
</tr>
<tr>
<td>xmin</td>
<td>0.0</td>
<td>Location of lower x boundary</td>
<td>(<em>:</em>) :: ""<em>OR</em></td>
</tr>
<tr>
<td>xmax</td>
<td>1.0</td>
<td>Location of upper x boundary</td>
<td>(<em>:</em>) :: ""<em>OR</em></td>
</tr>
<tr>
<td>xextent</td>
<td>1.0</td>
<td>Domain extent in x direction</td>
<td>(0:<em>) :: ""*OR</em></td>
</tr>
<tr>
<td>dx</td>
<td>1.0</td>
<td>Grid spacing in x direction</td>
<td>(0:<em>) :: ""*OR</em></td>
</tr>
<tr>
<td>ncells_x</td>
<td>1</td>
<td>Number of grid cells in x direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>zero_origin_y</td>
<td>"no"</td>
<td>Is the lower boundary located at y=0?</td>
<td></td>
</tr>
<tr>
<td>ymin</td>
<td>0.0</td>
<td>Location of lower y boundary</td>
<td>(<em>:</em>) :: ""<em>OR</em></td>
</tr>
<tr>
<td>ymax</td>
<td>1.0</td>
<td>Location of upper y boundary</td>
<td>(<em>:</em>) :: ""<em>OR</em></td>
</tr>
<tr>
<td>yextent</td>
<td>1.0</td>
<td>Domain extent in y direction</td>
<td>(0:<em>) :: ""*OR</em></td>
</tr>
<tr>
<td>dy</td>
<td>1.0</td>
<td>Grid spacing in y direction</td>
<td>(0:<em>) :: ""*OR</em></td>
</tr>
<tr>
<td>ncells_y</td>
<td>1</td>
<td>Number of grid cells in y direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>zero_origin_z</td>
<td>"no"</td>
<td>Is the lower boundary located at z=0?</td>
<td></td>
</tr>
<tr>
<td>zmin</td>
<td>0.0</td>
<td>Location of lower z boundary</td>
<td>(<em>:</em>) :: ""<em>OR</em></td>
</tr>
<tr>
<td>zmax</td>
<td>1.0</td>
<td>Location of upper z boundary</td>
<td>(<em>:</em>) :: ""<em>OR</em></td>
</tr>
<tr>
<td>zextent</td>
<td>1.0</td>
<td>Domain extent in z direction</td>
<td>(0:<em>) :: ""*OR</em></td>
</tr>
<tr>
<td>dz</td>
<td>1.0</td>
<td>Grid spacing in z direction</td>
<td>(0:<em>) :: ""*OR</em></td>
</tr>
<tr>
<td>ncells_z</td>
<td>1</td>
<td>Number of grid cells in z direction</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>boundary_size_x_lower</td>
<td>1</td>
<td>Boundary zones at the lower x face</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>boundary_internal_x_lower</td>
<td>"no"</td>
<td>Do the boundary points extend inwards at the lower x face?</td>
<td></td>
</tr>
<tr>
<td>boundary_staggered_x_lower</td>
<td>"no"</td>
<td>Is the boundary is staggered about the grid points at the lower x face?</td>
<td></td>
</tr>
<tr>
<td>boundary_shiftout_x_lower</td>
<td>0</td>
<td>Offset between the boundary location and the first boundary point at the lower x face</td>
<td><em>:</em> :: "when not staggered: use 0 for an open, 1 for a closed manifold"<em>OR</em></td>
</tr>
<tr>
<td>boundary_size_x_upper</td>
<td>1</td>
<td>Boundary zones at the upper x face</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>boundary_internal_x_upper</td>
<td>"no"</td>
<td>Do the boundary points extend inwards at the upper x face?</td>
<td></td>
</tr>
<tr>
<td>boundary_staggered_x_upper</td>
<td>"no"</td>
<td>Is the boundary is staggered about the grid points at the upper x face?</td>
<td></td>
</tr>
<tr>
<td>boundary_shiftout_x_upper</td>
<td>0</td>
<td>Offset between the boundary location and the first boundary point at the upper x face</td>
<td><em>:</em> :: "when not staggered: use 0 for an open, 1 for a closed manifold"<em>OR</em></td>
</tr>
<tr>
<td>boundary_size_y_lower</td>
<td>1</td>
<td>Boundary zones at the lower y face</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>boundary_internal_y_lower</td>
<td>"no"</td>
<td>Do the boundary points extend inwards at the lower y face?</td>
<td></td>
</tr>
<tr>
<td>boundary_staggered_y_lower</td>
<td>"no"</td>
<td>Is the boundary is staggered about the grid points at the lower y face?</td>
<td></td>
</tr>
<tr>
<td>boundary_shiftout_y_lower</td>
<td>0</td>
<td>Offset between the boundary location and the first boundary point at the lower y face</td>
<td><em>:</em> :: "when not staggered: use 0 for an open, 1 for a closed manifold"<em>OR</em></td>
</tr>
<tr>
<td>boundary_size_y_upper</td>
<td>1</td>
<td>Boundary zones at the upper y face</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>boundary_internal_y_upper</td>
<td>"no"</td>
<td>Do the boundary points extend inwards at the upper y face?</td>
<td></td>
</tr>
<tr>
<td>boundary_staggered_y_upper</td>
<td>"no"</td>
<td>Is the boundary is staggered about the grid points at the upper y face?</td>
<td></td>
</tr>
<tr>
<td>boundary_shiftout_y_upper</td>
<td>0</td>
<td>Offset between the boundary location and the first boundary point at the upper y face</td>
<td><em>:</em> :: "when not staggered: use 0 for an open, 1 for a closed manifold"<em>OR</em></td>
</tr>
<tr>
<td>boundary_size_z_lower</td>
<td>1</td>
<td>Boundary zones at the lower z face</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>boundary_internal_z_lower</td>
<td>"no"</td>
<td>Do the boundary points extend inwards at the lower z face?</td>
<td></td>
</tr>
<tr>
<td>boundary_staggered_z_lower</td>
<td>"no"</td>
<td>Is the boundary is staggered about the grid points at the lower z face?</td>
<td></td>
</tr>
<tr>
<td>boundary_shiftout_z_lower</td>
<td>0</td>
<td>Offset between the boundary location and the first boundary point at the lower z face</td>
<td><em>:</em> :: "when not staggered: use 0 for an open, 1 for a closed manifold"<em>OR</em></td>
</tr>
<tr>
<td>boundary_size_z_upper</td>
<td>1</td>
<td>Boundary zones at the upper z face</td>
<td>0:* :: ""<em>OR</em></td>
</tr>
<tr>
<td>boundary_internal_z_upper</td>
<td>"no"</td>
<td>Do the boundary points extend inwards at the upper z face?</td>
<td></td>
</tr>
<tr>
<td>boundary_staggered_z_upper</td>
<td>"no"</td>
<td>Is the boundary is staggered about the grid points at the upper z face?</td>
<td></td>
</tr>
<tr>
<td>boundary_shiftout_z_upper</td>
<td>0</td>
<td>Offset between the boundary location and the first boundary point at the upper z face</td>
<td><em>:</em> :: "when not staggered: use 0 for an open, 1 for a closed manifold"<em>OR</em></td>
</tr>
</tbody>
</table>
<h3 id="cartgrid3d">CartGrid3D</h3>
<p>Cactus Code Thorn CartGrid3D
Author(s)    : Gabrielle Allen
               Gerd Lanfermann
               Joan Masso
Maintainer(s): Cactus team
Licence      : LGPL</p>
<hr />
<ol>
<li>Purpose</li>
</ol>
<p>This thorn sets up a Cartesian grid, for a given domain. It also
provides a method for registering symmetries of Grid Functions
across the grid axes, and a call for applying symmetry boundary
conditions.</p>
<p>CartGrid3d also registers a coordinate system spher3d, under the old
API, but this is deprecated.  Spherical coordinate systems will be
provided by another thorn in the future.</p>
<ol>
<li>Additional information</li>
</ol>
<p>This thorn currently only works in 3D, in that it creates 3D grid functions.
It registers Cartesian coordinate systems of 1, 2, and 3 dimensions.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Defaults</th>
<th>Describe</th>
<th>Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>no_origin</td>
<td>"yes"</td>
<td>DEPRECATED: Don't place grid points on the coordinate origin/axes</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>no_originx</td>
<td>"yes"</td>
<td>DEPRECATED: Don't place grid points on the x-coordinate origin/axes</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>no_originy</td>
<td>"yes"</td>
<td>DEPRECATED: Don't place grid points on the y-coordinate origin/axes</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>no_originz</td>
<td>"yes"</td>
<td>DEPRECATED: Don't place grid points on the z-coordinate origin/axes</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>avoid_originx</td>
<td>"yes"</td>
<td>Don't place grid points on the x-coordinate origin/axes</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>avoid_originy</td>
<td>"yes"</td>
<td>Don't place grid points on the y-coordinate origin/axes</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>avoid_originz</td>
<td>"yes"</td>
<td>Don't place grid points on the z-coordinate origin/axes</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>avoid_origin</td>
<td>"yes"</td>
<td>Don't place grid points on the coordinate origin/axes</td>
<td>: :: ""<em>OR</em></td>
</tr>
<tr>
<td>register_default_coordinate_systems</td>
<td>"yes"</td>
<td>register cartnd as the default coordinate systems</td>
<td></td>
</tr>
<tr>
<td>dx</td>
<td>0.3</td>
<td>Coarse grid spacing in x-direction</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>dy</td>
<td>0.3</td>
<td>Coarse grid spacing in y-direction</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>dz</td>
<td>0.3</td>
<td>Coarse grid spacing in z-direction</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>dxyz</td>
<td>0.0</td>
<td>Coarse grid spacing in x,y,z-directions</td>
<td>0:* :: "Positive"<em>OR</em></td>
</tr>
<tr>
<td>xmin</td>
<td>-1.0</td>
<td>Coordinate minimum in x-direction</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ymin</td>
<td>-1.0</td>
<td>Coordinate minimum in y-direction</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>zmin</td>
<td>-1.0</td>
<td>Coordinate minimum in z-direction</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>xyzmin</td>
<td>-424242</td>
<td>Coordinate minimum in x,y,z-directions</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>xmax</td>
<td>1.0</td>
<td>Coordinate maximum in x-direction</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>ymax</td>
<td>1.0</td>
<td>Coordinate maximum in y-direction</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>zmax</td>
<td>1.0</td>
<td>Coordinate maximum in z-direction</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>xyzmax</td>
<td>-424242</td>
<td>Coordinate maximum in xyz-directions</td>
<td>: :: "Anything"<em>OR</em></td>
</tr>
<tr>
<td>type</td>
<td>"box"</td>
<td>Grid type</td>
<td>"box"        :: "Box grid from -0.5 to 0.5"<em>OR</em>  "byrange"    :: "Specify min and max values"<em>OR</em>  "byspacing"  :: "Specify grid spacings"<em>OR</em>  "coordbase"  :: "Get specification from CoordBase"<em>OR</em>  "multipatch" :: "Get specification from MultiPatch"<em>OR</em></td>
</tr>
<tr>
<td>domain</td>
<td>"full"</td>
<td>Domain type</td>
<td>"octant"     :: "Use an octant about the origin"<em>OR</em>  "quadrant"   :: "Use a quadrant in x-y plane"<em>OR</em>  "quadrant_reflect_rotate" :: "Use a quadrant with rotation symmetry about an axis"<em>OR</em>  "bitant"     :: "Use a bitant about the x-y plane"<em>OR</em>  "bitant_rotate"   :: "Use a bitant with rotation symmetry about an axis"<em>OR</em>  "full"       :: "Use the full domain"<em>OR</em></td>
</tr>
<tr>
<td>bitant_plane</td>
<td>"xy"</td>
<td>Plane defining bitant domain</td>
<td>"xy"       :: "xy-plane"<em>OR</em>  "xz"       :: "xz-plane"<em>OR</em>  "yz"       :: "yz-plane"<em>OR</em></td>
</tr>
<tr>
<td>quadrant_direction</td>
<td>"z"</td>
<td>Direction defining quadrant domain</td>
<td>"x"        :: "x-direction"<em>OR</em>  "y"        :: "y-direction"<em>OR</em>  "z"        :: "z-direction"<em>OR</em></td>
</tr>
<tr>
<td>rotation_axis</td>
<td>"z"</td>
<td>Axis about which the rotation symmetry is to be applied</td>
<td>"x"        :: "x-axis"<em>OR</em>  "y"        :: "y-axis"<em>OR</em>  "z"        :: "z-axis"<em>OR</em></td>
</tr>
<tr>
<td>symmetry_xmin</td>
<td>"no"</td>
<td>Symmetry boundary condition on lower x boundary</td>
<td>: :: "Logical"<em>OR</em></td>
</tr>
<tr>
<td>symmetry_ymin</td>
<td>"no"</td>
<td>Symmetry boundary condition on lower y boundary</td>
<td>: :: "Logical"<em>OR</em></td>
</tr>
<tr>
<td>symmetry_zmin</td>
<td>"no"</td>
<td>Symmetry boundary condition on lower z boundary</td>
<td>: :: "Logical"<em>OR</em></td>
</tr>
<tr>
<td>symmetry_xmax</td>
<td>"no"</td>
<td>Symmetry boundary condition on upper x boundary</td>
<td>: :: "Logical"<em>OR</em></td>
</tr>
<tr>
<td>symmetry_ymax</td>
<td>"no"</td>
<td>Symmetry boundary condition on upper y boundary</td>
<td>: :: "Logical"<em>OR</em></td>
</tr>
<tr>
<td>symmetry_zmax</td>
<td>"no"</td>
<td>Symmetry boundary condition on upper z boundary</td>
<td>: :: "Logical"<em>OR</em></td>
</tr>
<tr>
<td>set_coordinate_ranges_on</td>
<td>"all</td>
<td>On which grids to set the coordinate ranges</td>
<td>"all grids"   :: "set ranges in local mode, on the coarsest level"<em>OR</em>  "all maps"    :: "set ranges in singlemap mode, on the coarsest level"<em>OR</em>  "first level" :: "set ranges in level mode, on the first level"<em>OR</em></td>
</tr>
</tbody>
</table>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/YuLiumt/Einstein-Toolkit/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
      <script src="../../search/main.js" defer></script>

</body>
</html>
